<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="http://www.gov.cn/" title="不只是看客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="基础入门语言概述　　Java的3个开发平台： JavaSE、JavaEE、JavaME。  JavaSE（Java标准版），是J2EE和J2ME的基础，本章就是介绍的J2SE。JavaEE（Java企业版），是面向企业开发的。JavaME（Java微型版），是面向小型机、等终端设备开发的(如早年的手机游戏等)。  　　其中Java SE可分为4部分：JVM、JRE、JDK、Java语言。  JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章 Java语言">
<meta property="og:url" content="http://yoursite.com/language-002/index.html">
<meta property="og:site_name" content="不只是看客">
<meta property="og:description" content="基础入门语言概述　　Java的3个开发平台： JavaSE、JavaEE、JavaME。  JavaSE（Java标准版），是J2EE和J2ME的基础，本章就是介绍的J2SE。JavaEE（Java企业版），是面向企业开发的。JavaME（Java微型版），是面向小型机、等终端设备开发的(如早年的手机游戏等)。  　　其中Java SE可分为4部分：JVM、JRE、JDK、Java语言。  JVM">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/base/base001_11.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_12.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_13.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_14.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_15.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_16.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_17.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_18.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_19.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_20.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_21.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_22.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_23.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_24.png">
<meta property="og:updated_time" content="2022-11-11T03:01:37.499Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第二章 Java语言">
<meta name="twitter:description" content="基础入门语言概述　　Java的3个开发平台： JavaSE、JavaEE、JavaME。  JavaSE（Java标准版），是J2EE和J2ME的基础，本章就是介绍的J2SE。JavaEE（Java企业版），是面向企业开发的。JavaME（Java微型版），是面向小型机、等终端设备开发的(如早年的手机游戏等)。  　　其中Java SE可分为4部分：JVM、JRE、JDK、Java语言。  JVM">
<meta name="twitter:image" content="http://yoursite.com/img/base/base001_11.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/language-002/"/>

  <title> 第二章 Java语言 | 不只是看客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">不只是看客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                第二章 Java语言
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2010-09-01T14:43:49+08:00" content="2010-09-01">
              2010-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                    <span itemprop="name">编程语言</span>
                </span>

                
                

              
            </span>
          

          

          
          
             <span id="/language-002/" class="leancloud_visitors" data-flag-title="第二章 Java语言">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><h2 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h2><p>　　<code>Java</code>的3个开发平台： <code>JavaSE</code>、<code>JavaEE</code>、<code>JavaME</code>。</p>
<blockquote>
<p>JavaSE（Java标准版），是J2EE和J2ME的基础，本章就是介绍的J2SE。<br>JavaEE（Java企业版），是面向企业开发的。<br>JavaME（Java微型版），是面向小型机、等终端设备开发的(如早年的手机游戏等)。</p>
</blockquote>
<p>　　其中<code>Java SE</code>可分为4部分：<code>JVM</code>、<code>JRE</code>、<code>JDK</code>、<code>Java语言</code>。</p>
<blockquote>
<p>JVM：Java程序必要使用JVM（Java虚拟机）来解释执行。<br>JRE(Java Runtime Environment)： Java运行环境。如果您只运行Java程序，而不开发程序，则可以只安装JRE，JVM被包括在JRE中。<br>JDK (Java Development kit)：Java开发工具包。如过您打算开发（编译）Java程序，则需要JDK，而且JDK中包含了JRE和其他一些开发过程中可能使用的工具。<br>Java语言：Java语言只占了J2SE的一部分，除了语言之外Java最重要的就是它提供的功能强大的API类库、数据IO、网络组件等功能。</p>
</blockquote>
<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>　　计算机语言的种类非常的多，总的来说可以分成<code>机器语言</code>，<code>汇编语言</code>，<code>高级语言</code>三大类。关于高级程序语言的定义，在上一章“C语言”中已经介绍过了，此处不再冗述。</p>
<p>　　高级程序语言分为： <font color="red">编译型语言</font>和<font color="red">解释型语言</font>。<br>　　高级程序语言有：<code>C</code>、<code>C++</code>、<code>C#</code>、<code>Java</code>、<code>Python</code>等。<br>　　高级程序语言所写的代码被称为<font color="red">“源程序”</font>，但是计算机不能直接识别源程序代码，因此必须将源程序代码翻译成<font color="red">机械语言</font>(0，1代码)，只有这样咱们写的代码才能被计算机执行。由此<font color="red">根据将源程序翻译成机器语言的方式</font>将高级语言划分为：<font color="red">编译型语言</font>和<font color="red">解释型语言</font>。</p>
<p>　　<strong>编译型语言</strong></p>
<blockquote>
<p>编译器根据当前计算机的配置(如CPU的指令集、操作系统的类型等)，将源程序文件一次性编译成当前计算机系统能识别的机器语言，然后再交给CPU去执行，<font color="red">C语言就是编译型语言</font>。</p>
<p>优点： 程序执行速度快。<br>缺点： 由于编译生成的直接是机器语言(0、1代码)，具有与平台有关性，如果程序换到了另一个计算机系统中则就无法执行，且编译速度相对与解释型语言来说要慢一些。<br>注：直接将源程序转换成机器语言比转换成中间代码耗时要长。</p>
</blockquote>
<p>　　<strong>解释型语言</strong></p>
<blockquote>
<p>解释器先将源程序翻译成一个中间代码，当程序运行时由解释器解释这个中间代码，解释器每翻译一句，就交给CPU执行一句，<font color="red">Java语言就是解释型语言</font>。 </p>
<p>优点： 由于解释器生成的是与平台无关的中间码，执行这些中间代码需要特定解释器，因此只需要根据不同的计算机系统设计相应的解释器，就可以在不改源程序的前提下，使程序跨平台运行。<br>缺点： 程序执行的速度比编译型语言慢。<br>注：也有的解释器可以直接执行源程序，当然在这之前同样会进行必要的词法、语法分析。</p>
</blockquote>
<p>　　<strong>Java程序从编写到执行会经历如下步骤：</strong></p>
<blockquote>
<p>编译程序：使用<code>JDK</code>提供的<font color="red">“javac”</font>工具可以将源程序文件(<font color="red">.java</font>文件)编译成与平台无关的字节码文件(<font color="red">.class</font>文件)。<br>运行程序：使用<code>JDK</code>提供的<font color="red">“java”</font>工具，可以将<font color="red">.class</font>文件装入<code>JVM</code>里，由<code>JVM</code>解释执行，使用<font color="red">“java 类名”</font>执行程序。</p>
</blockquote>
<p>　　也就是说<code>Java</code>程序是运行在<code>JVM</code>之上的，<code>JVM</code>才是运行在操作系统上的，另外以<code>Windows</code>为例，每个<code>Java</code>程序执行时都会在操作系统中开一个<code>java.exe</code>的进程，它就是<code>JVM</code>。</p>
<h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><br>　　<strong>PATH变量</strong></p>
<blockquote>
<p><code>PATH</code>变量是<code>Windows</code>系统用来寻找可执行程序(<code>.exe</code>)的一个环境变量。<br>若不人为的去设置，则当我们在命令号中输入命令时，<code>Windows</code>默认去<code>C:/windows/system32</code>文件夹下去寻找可执行程序。<br><code>PATH</code>本质上是一个字符串，其中可以指定多个路径，路径间用分号(<code>;</code>)间隔，在操作系统查找某个可执行程序时，系统会依次查找<code>PATH</code>内的每一个路径。<br>在<code>JAVA</code>中设置此变量主要为了指明<code>javac.exe</code>和<code>java.exe</code>等程序所在位置，因为<code>JAVA</code>程序的编译和运行就需要这两个程序。</p>
</blockquote>
<p><br>　　<strong>ClassPath变量</strong></p>
<blockquote>
<p>类路径，顾名思义是<code>JVM</code>查找“类”时要使用的变量，一般来说至少要写上一个“<code>.</code>” 代表当前目录，多个路径间同样用分号(<code>;</code>)间隔。</p>
<p>当处在如下三种情况时说明此时<code>JVM</code>是在找类：<br>1、当程序中出现<code>import</code>语句导入类时。<br>2、程序中声明了一个未导入的类的对象时。<br>3、使用<code>java</code>执行某个类的时候，<code>JVM</code>会去<code>ClassPath</code>变量指定的路径上去找这个类。</p>
</blockquote>
<h3 id="通用常识"><a href="#通用常识" class="headerlink" title="通用常识"></a>通用常识</h3><p><br>　　范例1：<code>Hello World</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个源程序最多只能有一条package语句，且必须是源程序的第一条非注释语句。</span></span><br><span class="line"><span class="keyword">package</span> com.cutler;</span><br><span class="line"><span class="comment">// 一个.java文件中只能有一个public修饰类，可以有多个不被public修饰的类。</span></span><br><span class="line"><span class="comment">// 被public修饰的类，类名必须和.java文件的文件名相同。</span></span><br><span class="line"><span class="comment">// 一个.java文件中可以有多个类定义，相应的编译后会产生多个.class文件。</span></span><br><span class="line"><span class="comment">// 执行java程序时，执行的是具有main方法的类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输出数据 但不会换行。</span></span><br><span class="line">        System.out.print(<span class="string">"ABC"</span>);  </span><br><span class="line">        <span class="comment">//输出数据 并且换行。 此方法可以不输出任何数据 单独当作换行使用。</span></span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：标识符命名规范。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所谓的标识符，说白了就是指程序中：变量、方法、类、接口等对象的名称。</span></span><br><span class="line"><span class="comment">// 标识符名称必须由“大小写字母”、“下划线”、“数字”、“$”符号组成 且不能以数字开头。</span></span><br><span class="line"><span class="comment">// 最好也别用$符号开头，因为匿名内部类的名称前会有一个$符号应尽量避免混淆，可以有中文。</span></span><br><span class="line"><span class="comment">// Java中标识符区分大小写。变量a和变量A是不同的两个变量。</span></span><br><span class="line"><span class="comment">// 标识符不能使用Java保留字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 通常我们会按照如下规范来命名：</span></span><br><span class="line"><span class="comment">　　包名：全部用小写字母。</span></span><br><span class="line"><span class="comment">　　类名：各单词首字母大写。</span></span><br><span class="line"><span class="comment">　　局部变量名：全小写</span></span><br><span class="line"><span class="comment">　　成员变量名：第一个单词首字母小写，其他单词首字母大写。</span></span><br><span class="line"><span class="comment">　　方法名：第一个单词首字母小写，其他单词首字母大写。</span></span><br><span class="line"><span class="comment">　　常量名：全部大写，每个单词之间用“_”连接。</span></span><br><span class="line"><span class="comment">　　接口名：各单词首字母大写，在接口名前加一个大写字母“I”。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：保留字。<br>　　保留字又称为<font color="red">关键字</font>，说白了保留字就是Java<font color="red">系统专用</font>的标识符，用户无权使用。</p>
<center><br><img src="/img/base/base001_11.png" alt=""><br></center>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><br>　　范例1：运算符划分。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算术运算符：+  -  *  /  %  ++  -- </span><br><span class="line">关系运算符：&gt;  &lt;  &gt;=  &lt;=  == !=</span><br><span class="line">赋值运算符：= += -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</span><br><span class="line">逻辑运算符：&amp;&amp;  ||  !  &amp;  |</span><br><span class="line">位运算符：  !  &amp;  |  &gt;&gt;  &lt;&lt;  &gt;&gt;&gt;</span><br><span class="line">条件运算符：? :</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：逻辑运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑运算包含：与运算、或运算、非运算。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与运算</span></span><br><span class="line"><span class="comment">// 简洁与运算：“a&amp;&amp;b”，如果a为false则不再判断b，表达式的值自动为false。</span></span><br><span class="line"><span class="comment">// 全部与运算：“a&amp;b”， 如果a为false则同样去判断b。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或运算</span></span><br><span class="line"><span class="comment">// 简洁或运算：“a||b”，如果a为true则不再判断b，表达式的值自动为true。</span></span><br><span class="line"><span class="comment">// 全部或运算：“a|b”， 如果a为true则同样去判断b。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非运算</span></span><br><span class="line"><span class="comment">// 非运算“!a”，如果a为true则表达式的值为false，反过来一样。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicCalc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(a++ &gt; <span class="number">0</span> || b++ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"a="</span>+a+<span class="string">" b="</span>+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  此时程序输出：a=4 b=4。若是把“||”换成“|”，则程序输出：a=4 b=5。
</code></pre><p><br>　　范例3：位运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所谓的位运算，其实就是移位。</span></span><br><span class="line"><span class="comment">// 是将一个数字的二进制表示形式，整体(向左或向右)移动若干位。</span></span><br><span class="line"><span class="comment">// 如数字1的二进制为：00000001，左移移1位后为00000010。</span></span><br><span class="line"><span class="comment">// 其中位串“00000001”中，左边称为高位，右边称为低位。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移位时所遵循的规则为：</span></span><br><span class="line"><span class="comment">// 左移：最高位直接被舍弃，最低位补0。</span></span><br><span class="line"><span class="comment">// 右移：又分为有符号右移和无符号右移。</span></span><br><span class="line"><span class="comment">// 有符号右移：正常情况下每右移一位数据会缩小2倍，最低位直接被舍弃，移位之前最高位为1则移位之后最高位补1，为0则补0。</span></span><br><span class="line"><span class="comment">// 无符号右移：正常情况下每右移一位数据会缩小2倍，最低位直接被舍弃，左端补0。</span></span><br><span class="line"><span class="comment">// 左移、右移都是针对数值的“补码”来说的，关于“补码”的概念，在其它笔者的博文中会介绍。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有符号右移运算符(&gt;&gt;)、无符号右移运算符(&gt;&gt;&gt;)、左移运算符(&lt;&lt;)。</span></span><br><span class="line"><span class="comment">// 或运算符(|)：2个数有一个为1，结果就为1，否则为0。</span></span><br><span class="line"><span class="comment">// 与运算符(&amp;)：2个数同为1，结果才为1，否则为0。</span></span><br><span class="line"><span class="comment">// 取反运算符(~)：将0改成1，将1改成0。</span></span><br><span class="line"><span class="comment">// 异或运算符(^)：2个数相同则为0，不同则为1。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><br>　　范例1：数据类型的划分。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、基本数据类型（共8种）。</span></span><br><span class="line"><span class="comment">// 2、复合数据类型：数组、接口、类。</span></span><br><span class="line"><span class="comment">// 3、空类型：void。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8种基本数据类型为：</span></span><br><span class="line"><span class="comment">// 数值类型：</span></span><br><span class="line"><span class="comment">// 　　byte(1字节)、short(2字节)、int(4字节)、long(8字节)、float(4字节)、double(8字节)</span></span><br><span class="line"><span class="comment">// 字符类型：char(2字节)</span></span><br><span class="line"><span class="comment">// 布尔类型：boolean(1字节)，取值：true、false</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  复合类型成员变量默认值为null，局部变量没有默认值。
</code></pre><p><br>　　范例2：变量与常量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量：程序中值可以改变的量，又分为：</span></span><br><span class="line"><span class="comment">//　　局部变量：程序中一对“&#123;&#125;”被称为一个块，局部变量隶属于某一个“块”当程序流程走出这个“块”时，局部变量就消失了。</span></span><br><span class="line"><span class="comment">//　　成员变量：成员变量隶属于对象，对象建立时成员变量诞生，对象消失时成员变量死亡。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量：程序中值不可以改变的量，又分为：</span></span><br><span class="line"><span class="comment">//　　字面常量：如1、’c’、2342f、”String”、false等。</span></span><br><span class="line"><span class="comment">//　　符号常量：final double PI=3.14。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于局部变量还需要知道的是：</span></span><br><span class="line"><span class="comment">//　　(1)必须要先赋值后使用，否则通不过编译，局部变量没有默认初始化值。</span></span><br><span class="line"><span class="comment">//　　(2)作用范围：定义开始到定义它所在的代码块结束。</span></span><br><span class="line"><span class="comment">//　　(3)同一范围内，不允许2个局部变量命名冲突。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：整型数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整型数据分为：整型常量和整型变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整型常量有三种表示方法：</span></span><br><span class="line"><span class="comment">//　　十进制表示法：如1、23、-5。</span></span><br><span class="line"><span class="comment">//　　八进制表示法：以数字0开头，随后的数不能大于7，如01、023、-05等。</span></span><br><span class="line"><span class="comment">//　　十六进制表示法：以0x开头，随后的数不能大于F(A代表10，F代表15)，如-0x12。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整型变量有byte、int、short、long四种：</span></span><br><span class="line"><span class="comment">//　　字节整型（byte）：变量所能保存的值的取值范围：-128~127。</span></span><br><span class="line"><span class="comment">//　　短整型（short）：取值范围：-32768~32767。</span></span><br><span class="line"><span class="comment">//　　基本整型（int）：取值范围：-2147483648~2147483647，默认用十进制表示数字。</span></span><br><span class="line"><span class="comment">//　　　　如“int i=0xF;”，此时输出i,结果为15 。</span></span><br><span class="line"><span class="comment">//　　长整型（long）：取值范围：很大很大很大。</span></span><br><span class="line"><span class="comment">// 需要注意的是：</span></span><br><span class="line"><span class="comment">//　　整数型成员变量默认值0，整型的局部变量没有默认值，必须手工赋值。</span></span><br><span class="line"><span class="comment">//　　long型常量之后跟一个“L”或者“l”，如：12L。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：实型数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实型数据（实数）又称为浮点数，分为：实型常量和实型变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实型常量有两种表示方法：</span></span><br><span class="line"><span class="comment">// 十进制小数形式：由数字和小数点组成(注意必须要有小数点，但小数点之后，可以没有内容)，如 1.2f、2.3、-5.等都是十进制小数形式</span></span><br><span class="line"><span class="comment">// 指数形式：12E3或者12e3都是12000的指数形式。</span></span><br><span class="line"><span class="comment">//　　指数形式是实型数据特有的表示方法，e就代表10的次幂，E3就代表103次幂，E和e大小写任意。</span></span><br><span class="line"><span class="comment">//　　E的左右两边都必须有数字，且右边的数字必须是整数，但可以是负整数。</span></span><br><span class="line"><span class="comment">//　　规范化指数形式：在字符e的左面的数字中，小数点的左面有且仅有一位非零数字。如：1.2e2 就是规范化指数形式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实型变量分为单精度(float)型、双精度(double)型。</span></span><br><span class="line"><span class="comment">//　　单精度型（float）占4字节，float型常量后面跟着一个“F”或者“f” 。</span></span><br><span class="line"><span class="comment">//　　双精度型（double）占8字节，double型常量后面可以加上“d”或“D”。</span></span><br><span class="line"><span class="comment">// 浮点数默认为double型，因此“float f=12.4;”是错误的，因为double的精度float高，不可以直接赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是：</span></span><br><span class="line"><span class="comment">// 1. 浮点成员变量默认值为0.0，浮点局部变量同样没有默认值。</span></span><br><span class="line"><span class="comment">// 2. 浮点数/0结果为+-Infinity(正负无穷大)，0.0/0.0结果为NaN(Not a Number，即这是一个数学上没有定义的值)。</span></span><br><span class="line"><span class="comment">// 3. float、double 如果取值达到上界以上，则会取值：+Infinity或者-Infinity，整数型变量数值达到最大时会自动跳到最小，达到最小时会跳到最大，即所谓的物极必反。</span></span><br><span class="line"><span class="comment">// 4. double比float范围更广、精度更高,但float比double更速度、更节省空间。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：字符和布尔。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符型数据分为：字符型常量和字符型变量。</span></span><br><span class="line"><span class="comment">// 字符型数据（char）占2个字节，是无符号型数据，取值范围：0~65535。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = (<span class="keyword">char</span>) -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// char类型所有字符都是用2个字节存储的，即‘a’和‘崔’都是使用2个字节。</span></span><br><span class="line">    <span class="comment">// 输出65535</span></span><br><span class="line">    System.out.println((<span class="keyword">int</span>) ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若是字符串“a”则本质上却仍是1字节。</span></span><br><span class="line">    <span class="comment">// 输出1,1</span></span><br><span class="line">    System.out.println(<span class="string">"a"</span>.length() + <span class="string">","</span> + <span class="string">"a"</span>.getBytes().length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在字符串里出现的汉字，所占的字节数是变化的，占2、3、4字节都有可能。</span></span><br><span class="line">    <span class="comment">// 输出1,3</span></span><br><span class="line">    System.out.println(<span class="string">"崔"</span>.length() + <span class="string">","</span> + <span class="string">"崔"</span>.getBytes().length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此汉字占两个字符长度，如果尝试打印charAt(0)和charAt(1)则会出现“?”</span></span><br><span class="line">    <span class="comment">// 也就是说，下面这个汉字占2位长度。</span></span><br><span class="line">    <span class="comment">// 输出2,4</span></span><br><span class="line">    System.out.println(<span class="string">"𠮷"</span>.length() + <span class="string">","</span> + <span class="string">"𠮷"</span>.getBytes().length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的语句无法编译通过，因为这个汉字不在char数据类型的收藏范围内。</span></span><br><span class="line">    <span class="keyword">char</span> ch=<span class="string">'𠮷'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔型数据分为：布尔型常量（只有true和false两个取值）和布尔型变量。</span></span><br><span class="line"><span class="comment">// 成员变量默认值为false，局部变量没有默认值。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：数据类型转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整型、实型、字符型混合运算时，从低级到高级的优先关系如下：</span></span><br><span class="line"><span class="comment">// byte → short → char → int → long → float → double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个低优先级的常量或变量赋给一个高优先级的变量时，会产生自动转换：</span></span><br><span class="line"><span class="keyword">long</span> i=<span class="number">5</span>;     <span class="comment">// 5默认为int型的常量，此时赋给一个long型变量。</span></span><br><span class="line"><span class="keyword">double</span> d= <span class="number">2.4f</span> <span class="comment">//2.4f是float型的常量,如果去掉f则默认为double型常量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型自动提升规则：</span></span><br><span class="line"><span class="comment">// a和b作某种运算，先把低级类型转成高级类型后在开始运算。</span></span><br><span class="line"><span class="comment">// a和b中最高是double，结果就是double。</span></span><br><span class="line"><span class="comment">// a和b中最高是float，结果就是float。</span></span><br><span class="line"><span class="comment">// a和b中最高是long，结果就是long。</span></span><br><span class="line"><span class="comment">// 除此之外，结果都是int。</span></span><br><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">a = a+b;      <span class="comment">//编译出错自动类型提升成int</span></span><br><span class="line">a += b;       <span class="comment">//+=没有自动类型提升问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个整数相除，计算出的结果也是一个整数。</span></span><br><span class="line"><span class="comment">// 如3/2结果为1，Java会自动截断小数部分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把高字节转成低字节，需要作强制类型转换。</span></span><br><span class="line"><span class="keyword">byte</span> c=(<span class="keyword">byte</span>)(a+b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是“byte a = 1;”中的“1”是一个整数常量，整数常量默认为int型。</span></span><br><span class="line"><span class="comment">// 而int型又比byte、short、char型的优先级高，按道理来说是不可以将一个整数常量赋值给这三个类型的，但事实上是：</span></span><br><span class="line"><span class="comment">// 整数 -128~127 之间(包括)的数可以直接赋值给byte型。</span></span><br><span class="line"><span class="comment">// 整数 -32768~32767 之间(包括)的数可以直接赋值给short型。</span></span><br><span class="line"><span class="comment">// 整数 0~65535 之间(包括)的数可以直接赋值给char型。</span></span><br><span class="line"><span class="comment">// 整数 +-21亿之间的数可以直接赋值给一个int型。</span></span><br><span class="line"><span class="comment">// 如果一个整常量超过int型的范围，则必须在这个整数后面加上一个“L”来指明这个数是一个long型的常量，否则编译出错。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例6：封装类。</p>
<center><br><img src="/img/base/base001_12.png" alt=""><br></center>

<p>　　其中6种数字类型均派生自<code>Number</code>类，而<code>Boolean</code>和<code>Character</code>则直接派生自<code>Object</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱：</span></span><br><span class="line"><span class="comment">// 将基本数据类型，使用其封装类封装起来，就称为装箱。</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆箱：</span></span><br><span class="line"><span class="comment">// 使用各封装类中的特定方法，可以将一个封装类的对象，拆箱成一个基本数据类型。</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(<span class="number">30</span>).intValue();     <span class="comment">//将Integer对象转成int型变量</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="keyword">new</span> Integer(<span class="number">20</span>).floatValue(); <span class="comment">// 将Integer对象转成float型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK1.5之后产生了自动装箱、拆箱。</span></span><br><span class="line"><span class="comment">// 将基本数据类型常量赋值给其封装类时，就会自动装箱。</span></span><br><span class="line">Integer i = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将各封装类对象赋值给各基本类型时，就会自动拆箱。</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 说白了咱们怎么使用一个int型的变量，就可以怎么使用Integer类型的对象。</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">6</span> * <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 六个数值型数据的封装类都有两个字段：MAX_VALUE和MIN_VALUE用于得到该类型的最大值和最小值。</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 六个数值型数据的封装类都有一个将字符串转换成对应数据类型的方法。 </span></span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(“<span class="number">123</span>”);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(“<span class="number">1.4</span>”);</span><br></pre></td></tr></table></figure>
<p><br>　　范例7：对象重用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>, j = <span class="number">10</span>, m = <span class="number">200</span>, n = <span class="number">200</span>;</span><br><span class="line">        System.out.println(i == j); <span class="comment">// true</span></span><br><span class="line">        System.out.println(m == n); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在自动装箱时，对于值在-128~127之间的值，它们被装箱为Integer对象后会在内存中被重用。
-  如果超过了这个范围，被装箱后的Integer对象并不会重用。
-  为什么这么做？因为人们认为-128~127之间的数使用的频率特别频繁，若每用到这些数都new一个新的对象，则很浪费空间。
</code></pre><p><br>　　范例8：关于“==”号。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Java中有两种数据类型可以使用“==”进行比较。</span></span><br><span class="line"><span class="comment">// “基本数据类型 == 基本数据类型”   比较的是变量值。</span></span><br><span class="line"><span class="comment">// “复合数据类型 == 复合数据类型”   比较的是对象的引用变量的值，不是hashCode码。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><br>　　范例1：单分支结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单分支结构中只有两个分支，程序将只能选择其中一个分支，然后执行下去，使用if语句来表达。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b=<span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Java中If语句里只能是boolean类型的常量或表达式，不能是数字。</span></span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">if</span>(b)</span><br><span class="line">                System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">// 下面的else和第二个if配对，因此程序执行的结果是输出false。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  因此应该在第一if后，加上一对大括号将下面的if...else给括起来。
</code></pre><p><br>　　范例2：多分支结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单分支结构中只有两个分支，程序将只能选择其中一个分支，然后执行下去，使用if语句来表达。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">            <span class="comment">// 同级的每一个case后常量不能相同。</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">// 每一个case执行完后应该加一个break，否则程序流程会继续执行下去，不再匹配case。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// default 后面不跟常量，当所有case都失配时，会执行default后的语句。</span></span><br><span class="line">            <span class="comment">// 可以没有default，若没有default并且所有case都失配，则程序不执行任何操作。</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 最后一个语句可以不写break，各个case和default任意排列，不用分先后。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：循环结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环结构：分为直到循环和当型循环。</span></span><br><span class="line"><span class="comment">// 　　直到循环：程序流程至少会循环一次，使用do…while()实现，在while()后要加上一个“;”</span></span><br><span class="line"><span class="comment">// 　　当型循环：只有当条件满足时，循环体才会执行，最少时一次都不执行，使用while(..)&#123;&#125;和 for(..)来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for语句的语法</span></span><br><span class="line"><span class="comment">// for(表达式1；表达式2；表达式3)</span></span><br><span class="line"><span class="comment">// 　　表达式1用来初始化循环控制变量。</span></span><br><span class="line"><span class="comment">// 　　表达式2用来判断循环是否应该结束。</span></span><br><span class="line"><span class="comment">// 　　表达式3用来迭代循环控制变量。</span></span><br><span class="line"><span class="comment">// 其中3个表达式都可以省写，如果省写表达式2，则默认为真(此时可能产生死循环)，但是for语句中的2个分号不能省写。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于break和continue：</span></span><br><span class="line"><span class="comment">// break可以在循环体和switch中使用，continue只能在循环体中使用。</span></span><br><span class="line"><span class="comment">// break结束最内层的循环，然后执行最内层循环体之后的语句。 </span></span><br><span class="line"><span class="comment">// continue结束最内层循环的当前这一次，然后执行最内层循环体的下一轮循环。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带标号的跳转语句：</span></span><br><span class="line"><span class="comment">// “break 标号;” 可以跳出任意层的循环，然后执行标号指向的循环体之后的语句。 </span></span><br><span class="line"><span class="comment">// “continue 标号;” 可以执行标号指向的循环的下一轮循环。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><br>　　范例1：一维数组定义格式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只定义不赋值</span></span><br><span class="line"><span class="comment">// 　　数组类型[] 数组名 =new 数组类型[数组长度];</span></span><br><span class="line"><span class="comment">// 　　数组类型  数组名[]=new 数组类型[数组长度];</span></span><br><span class="line"><span class="comment">// 定义的同时进行赋值</span></span><br><span class="line"><span class="comment">// 　　数组类型[] 数组名 =new 数组类型[]&#123;参数1,参数2,…..参数n&#125;;</span></span><br><span class="line"><span class="comment">// 　　数组类型  数组名[]=&#123;参数1,参数2,…..参数n&#125;;</span></span><br><span class="line"><span class="comment">// 其中[数组长度]可以是变量也可以是常量，变量最高只能是int型的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组下标从0~9，并且所有元素都有默认值，且默认为0。</span></span><br><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]  </span><br><span class="line"><span class="comment">// 定义数组的同时，为数组初始化，此时“new int[]”的中括号内不能指定长度。</span></span><br><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; </span><br><span class="line"><span class="comment">// 但是此方式只能在定义的同时使用。</span></span><br><span class="line"><span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写是错误的：</span></span><br><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">null</span>;</span><br><span class="line">array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：二维数组定义格式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只定义不赋值</span></span><br><span class="line"><span class="comment">// 　　数组类型[][] 数组名 =new 数组类型[行长度][列长度];</span></span><br><span class="line"><span class="comment">// 　　数组类型[][] 数组名 =new 数组类型[行长度][];</span></span><br><span class="line"><span class="comment">// 定义的同时进行赋值</span></span><br><span class="line"><span class="comment">// 　　数组类型[][] 数组名 =new 数组类型[][]&#123; &#123;参数1&#125; , &#123;参数2,…..参数n&#125; &#125;;</span></span><br><span class="line"><span class="comment">// 　　数组类型[][] 数组名 = &#123; &#123;参数1&#125; , &#123;参数2,…..参数n&#125; &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Java中定义多维数组时，可以只指定最高维的长度，低维的长度可以稍后指定。  </span></span><br><span class="line"><span class="comment">// Java中多维数组每一行的列数可以互不相同，C语言中数组所有行的列数必须相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是建立了一个引用变量，此时并无对象产生。</span></span><br><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line"><span class="comment">// “int[]”代表一个数据类型，不能在中括号里写长度。 </span></span><br><span class="line"><span class="comment">// 数组的长度使用“数组名.length”来表示，如：array.length。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：数组遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">        System.out.print(array[i]+<span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">// i的类型必须和数组的类型相同。</span></span><br><span class="line">    <span class="comment">// 遍历时会自动使i依次指向array中的每一个元素。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:array)</span><br><span class="line">        System.out.print(i+<span class="string">"、"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说白了就是i必须要比数组小一级，接着看遍历2维对象数组：</span></span><br><span class="line">    Person[][] array=<span class="keyword">new</span> Person[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(Person[] i:array)</span><br><span class="line">        <span class="keyword">for</span>(Person j:i)</span><br><span class="line">            System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><p><br>　　现在木匠要做一个木箱子，按照面向对象和面向过程两种方法做。</p>
<p>　　<strong>面向对象</strong> </p>
<blockquote>
<p>将箱子看成多个部分，首先分析箱子的结构，得出箱子由箱盖、箱体、拉坏等部分组成。<br>然后分别去做完 箱子的箱盖、箱体、拉坏等部分，各部分的尺寸按公共标准来。<br>各个部分都留有插口，用于与其他部分连接，最后将各部分组装成一个箱子。</p>
</blockquote>
<p>　　<strong>面向过程</strong> </p>
<blockquote>
<p>将箱子看成一个整体，箱子所有的组件之间联系紧密。<br>制作箱子的时候每做好箱子的一部分就将那部分“用钉子”嵌到到箱子上去，并不会去刻意的将各组件间的联系给疏远。</p>
</blockquote>
<p>　　说白了对于面向过程来说只要“能做出一个箱子”就是万事大吉了，不会去考虑：</p>
<blockquote>
<p>箱子中各个部件的连接是否合理<br>箱子某一组件损坏后，是否何以轻易的更换掉该组件<br>箱子无用后，是否能再重复利用箱子的一些组件</p>
</blockquote>
<p>　　这就是所谓的面向过程是“专注于解决问题”，对于面向对象来说不仅要做出一个箱子，而且要做出一个设计合理、可维护、可重用的箱子，这就是所谓的面向对象是“专注于分析问题”。</p>
<p>　　比如现在出现了如下两个问题：</p>
<blockquote>
<p>1、木匠觉得箱子的拉环做的不完美想要重新做一个拉环。<br>2、箱子用坏了，但是箱子的锁环由于是铁打的，所以还可以用，木匠想把这个锁环装到大门上继续使用。</p>
</blockquote>
<p>　　对于面向过程来说，由于设计箱子的时候将箱子看成一个整体，因此箱子的锁环是在设计的时候是根据箱子的大小、木质等特点，为这个箱子“量身定做”的，如果箱子坏了或者想重做一个拉环，那么箱子的锁环也就没什么用了。而面向对象思路做成的箱子，它的各组件拼装的时候就设计好了组件间拼装的接口，因此 如果门上面也有这个可以插入箱子锁环的接口，那么就可以直接将箱子的锁环拿到门上面重用了。</p>
<p>　　需要注意的是：</p>
<blockquote>
<p>面向过程编程还有一个特点：代码自顶向下一步一步顺序执行。<br>面向过程是面向对象的基础，不管你怎么分析问题，一切的分析都结束后，仍然需要按照面向过程的编程思路“自顶向下 一步一步 顺序执行”进行具体的编码。<br>换句话说就是，在大的方向上使用面向对象分析，在具体的实施阶段上，使用面向过程编程。</p>
</blockquote>
<p>　　<strong>面向对象的三大特性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装性</span></span><br><span class="line"><span class="comment">// 定义：所谓的封装性就是指，使类中重要的东西对外部不可见。</span></span><br><span class="line"><span class="comment">// 作用：保护类中的属性不被外部直接访问。</span></span><br><span class="line"><span class="comment">// 意义：</span></span><br><span class="line"><span class="comment">// 1、保护数据安全。比如说一个人的心脏，都是被皮肤、肌肉、骨头一层一层的包围(封装)起来的。如果不被保护在身体里面，而放到身体外面，那么任何人都可以看到、伤害到这个人的心脏 那么这个人要是和谁有仇，那么他不就完蛋了吗？随便拿个针就能戳破他的心脏。</span></span><br><span class="line"><span class="comment">// 2、封装复杂度。比如说电脑的显示器，咱们不需要知道它的工作原理，只需要插上电源使用它就可以了，至于显示器具体的组成、工作原理都被封装到一个显示器外壳内部了，用户不用去管它。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承性</span></span><br><span class="line"><span class="comment">// 和现实世界中的继承是一个意思。 </span></span><br><span class="line"><span class="comment">// 在现实世界中：孩子继承老子的遗产。</span></span><br><span class="line"><span class="comment">// 在编程中：子类继承父类的属性和方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态性</span></span><br><span class="line"><span class="comment">// Java中多态分为两种：方法重载、方法重写。</span></span><br><span class="line"><span class="comment">// 咱们在大街上喊一声“我爱中国”，路人听到咱们这句话(即接受到咱们的消息)后，每个人对此所做出的反应是不同的，有“惊讶，偷笑，无聊，赞许”等等，路人这些反应，就称为多态。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p><br>　　类：就是对一群事或物共有特征和行为的抽象。它是抽象的、不是客观存在的。它是一个模板、一张图纸。比如说：</p>
<blockquote>
<p>人类<br>特征： 姓名、年龄、性别<br>行为： 说话、吃饭、学习、工作</p>
<p>鸟类<br>特征： 羽毛、翅膀<br>行为： 飞翔、下蛋</p>
</blockquote>
<p>　　显然不能说“人类”就是指“张三”或者指“李四”，因为“人类”是抽象的。</p>
<p>　　对象：就是类的一个个体，一个具体的实例。它是具体的、客观存在的，它是类的一个样品、一个实物。比如说：</p>
<blockquote>
<p>张三<br>特征：张三、30岁、男<br>行为：说话、吃饭、学习、工作</p>
<p>麻雀<br>特征：灰色的羽毛、短小的翅膀<br>行为：飞翔、下蛋</p>
</blockquote>
<p><br>　　范例1：类的基本组成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类通常由两部分组成：属性和方法。类的定义格式：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> name;       <span class="comment">// 属性;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;&#125;;   <span class="comment">// 方法;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><br>　　类的属性又称为：字段和成员变量。<br>　　成员变量分为：</p>
<blockquote>
<p>实例变量：不用static修饰的变量，隶属于对象。<br>静态变量：使用static修饰的变量，隶属于类。</p>
</blockquote>
<p><br>　　范例1：属性定义的格式。</p>
<blockquote>
<p>[访问修饰符] [存在修饰符] 数据类型 变量名[=默认值];</p>
</blockquote>
<pre><code>语句解释：
-  中括号内的内容代表是可省写的。
</code></pre><p><br>　　范例2：修饰符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问修饰符就是起到限制别人访问本类中变量和方法的功能的修饰符。</span></span><br><span class="line"><span class="comment">// public    公开访问修饰符权限最大，在任何地方都可以访问。</span></span><br><span class="line"><span class="comment">// protected 保护访问修饰符权限第二，同一个包中的类和不同包的子类可访问。</span></span><br><span class="line"><span class="comment">// default   包访问修饰符权限第三，同一个包中的类可访问，不给变量写访问修饰符，则就默认为包访问。如果使用default关键词修饰变量反而错了，default只存在于switch、annotation等语句中。</span></span><br><span class="line"><span class="comment">// private  私有访问修饰符权限最低，只有本类内部的代码才可以访问。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在修饰符 ： static、final、transient。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><br>　　类的方法又称为：函数、行为、成员方法。<br>　　成员方法分为：</p>
<blockquote>
<p>实例方法：不用static修饰的方法，隶属于对象。<br>静态方法：使用static修饰的方法，隶属与类。</p>
</blockquote>
<p><br>　　范例1：方法定义的格式。</p>
<blockquote>
<p>[访问修饰符] [存在修饰符] 返回值类型|void 方法名称(参数列表){<br>   // 方法体。<br>   [return 返回值]<br>}</p>
</blockquote>
<pre><code>语句解释：
-  中括号内的内容代表是可省写的。
-  如果方法没有返回值，则要使用void关键字，方法体中可以有return语句也可以没有return语句，如果有则return语句不能带回返回值。
-  如果方法有返回值类型，方法中必须要有return语句，且return必须带回返回值，且返回数据的类型与方法的返回值类型要兼容。
-  方法体中可以有多个return语句，执行到哪一个return语句，哪一个就起作用。
-  返回值类型可以是数组类型的，可以这么直接获取数组第一个元素“int i=getArray()[0]”。
</code></pre><p><br>　　范例2：方法的调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法调用的时候，传递给方法的参数，会有自动数据类型晋升的机制。</span></span><br><span class="line"><span class="comment">// 例如：public void method(double param)&#123;&#125;</span></span><br><span class="line"><span class="comment">// 然后执行“method(5)；”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用的流程：</span></span><br><span class="line"><span class="comment">// 由于实参是int类型变量，所以编译器首先会在类中查找方法</span></span><br><span class="line"><span class="comment">// public void method(int param)&#123;&#125; </span></span><br><span class="line"><span class="comment">// 如果没有查找到，则会继续查找public void method(long param)&#123;&#125;</span></span><br><span class="line"><span class="comment">// 如果仍然没有查找到，则会继续查找public void method(float param)&#123;&#125;</span></span><br><span class="line"><span class="comment">// 如果仍然没有查找到，则会继续查找public void method(double param)&#123;&#125;</span></span><br><span class="line"><span class="comment">// 如果仍然没有查找到，则编译报错。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：方法的重载(overloading)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法重载时，方法的名称必须相同。</span></span><br><span class="line"><span class="comment">// 方法重载时，方法的参数列表必须不相同，包括参数的个数、类型、顺序，也就是说两个同名的方法在这三项中至少要有一项互不相同。</span></span><br><span class="line"><span class="comment">// 方法重载时，方法的返回值类型可以不相同，即方法重载只检查方法名称和参数列表。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：可变参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        print(<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>);</span><br><span class="line">        print(<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">32</span>);</span><br><span class="line">        print(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">32</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int和temp之间的那三个“.”是固定的，不能多也不能少。</span></span><br><span class="line">    <span class="comment">// 可变参数必须放在方法参数列表的最后一个位置。</span></span><br><span class="line">    <span class="comment">// 编译器使用数组来存储可变参数中的参数，因此可以在方法中，以数组的形式访问可变参数。</span></span><br><span class="line">    <span class="comment">// 可变参数可以传递0个或多个参数，若传递0个参数，则数组的长度为0，而非null。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>...temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:temp)</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：修饰符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问修饰符：public、protected、default、private</span></span><br><span class="line"><span class="comment">// 存在修饰符：static、final、abstract</span></span><br><span class="line"><span class="comment">// 操作修饰符：synchronized</span></span><br></pre></td></tr></table></figure></p>
<h3 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h3><p><br>　　范例1：学生类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;      <span class="comment">// 学生的姓名属性</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 学生的学号属性</span></span><br><span class="line">      <span class="comment">// static修饰的变量被称为类变量或静态变量，类中所有的对象 共用这个变量。 </span></span><br><span class="line">      <span class="comment">// 对象a改变这个变量的值，对象b再引用此变量的时候，引用的值是已经改变之后的了。</span></span><br><span class="line">      <span class="comment">// static修饰的变量存在于全局数据区，static不能修饰局部变量。</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id;    </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构造方法的特点：</span></span><br><span class="line">      <span class="comment">// 构造方法名必须和类名相同，方法没有返回值，也不是void。</span></span><br><span class="line">      <span class="comment">// 不能在构造方法中使用return返回一个内容。</span></span><br><span class="line">      <span class="comment">// 构造方法在实例化对象的时候(new的时候)被自动调用。</span></span><br><span class="line">      <span class="comment">// Java会为每一个类提供一个默认的(无参)构造方法。</span></span><br><span class="line">      <span class="comment">// 如果一个类显式的定义了一个有参的构造方法 则Java不会在为其提供无参的构造方法。</span></span><br><span class="line">      <span class="comment">// 构造方法可以重载。 </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 无参构造方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">// this表示“当前对象”，即当前正在调用本方法的对象。</span></span><br><span class="line">          <span class="comment">// 使用this(参数)转调用其它构造方法。</span></span><br><span class="line">          <span class="comment">// 此语句必须在构造方法中才能使用，必须是方法体中的第一条语句。 </span></span><br><span class="line">          <span class="comment">// 本类中必须要有一个构造方法没有调用其他构造，该方法作为递归调用的出口，一般使用无参的构造来作为这个出口。</span></span><br><span class="line">          <span class="keyword">this</span>(<span class="string">"学生"</span>+id);</span><br><span class="line">          id++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 有参构造方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">          <span class="comment">// this.name用来调用当前对象的name属性。</span></span><br><span class="line">          <span class="comment">// 局部变量的范围内，成员变量被隐藏，因此需要使用this。</span></span><br><span class="line">          <span class="keyword">this</span>.name=name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="comment">// static修饰的成员是隶属于类的，即使程序中没有该类的对象存在，也可以通过类名引用该类静态变量和静态方法。 </span></span><br><span class="line">    <span class="comment">// static定义的方法被称为类方法或静态方法，调用方式“类名.方法名(推荐使用此方式)”或者“对象名.方法名”。</span></span><br><span class="line">    <span class="comment">// static修饰的方法内部，只能访问静态成员(静态方法、变量)不能访问实例成员、不能使用this、super关键字，因为当前程序中可能还没有该类的对象存在。</span></span><br><span class="line">    <span class="comment">// static方法可以被继承但是不可以被重写，若子类存在一个和父类完全相同的一个方法，则父类的方法会被隐藏。</span></span><br><span class="line">    <span class="comment">// static修饰的内部类被称为 静态内部类。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Student对象</span></span><br><span class="line">        <span class="comment">// 前半句只是在栈中声明一个引用变量，此时并没有对象产生，只是开辟的栈空间，而没有开辟堆空间，此时还不能使用stu调用类的方法和属性。</span></span><br><span class="line">        <span class="comment">// 后半句才是实例化对象，开辟了堆空间，此时可以调用类的方法和属性。</span></span><br><span class="line">        Student stu=<span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例属性和实例方法是隶属与对象的，每一个对象的属性和方法都独立于其它对象，即被这个对象自己独占。因此修改对象stu1的name字段，对对象stu2的name字段没有任何影响。</span></span><br><span class="line">        <span class="comment">// 调用属性</span></span><br><span class="line">        stu.name=<span class="string">"张三"</span>;</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        stu.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定姓名 则按指定的姓名给学生初始化。</span></span><br><span class="line">        Student stu2=<span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有指定姓名 则调用无参的构造方法 进行自动命名。</span></span><br><span class="line">        Student stu3=<span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        Student stu4=<span class="keyword">new</span> Student(<span class="string">"李四"</span>);</span><br><span class="line">        System.out.println(stu.getName());</span><br><span class="line">        System.out.println(stu2.getName());</span><br><span class="line">        System.out.println(stu3.getName());</span><br><span class="line">        System.out.println(stu4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存简述"><a href="#内存简述" class="headerlink" title="内存简述"></a>内存简述</h3><p><br>　　在操作系统中内存被划分为如下几个部分。</p>
<p>　　<strong>静态数据区</strong> </p>
<blockquote>
<p>存放程序中的静态数据，如static变量、常量等。<br>变量的内存地址在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。</p>
</blockquote>
<p>　　<strong>代码区</strong> </p>
<blockquote>
<p>存放程序中源代码。如函数、语句等。</p>
</blockquote>
<p>　　<strong>栈</strong> </p>
<blockquote>
<p>存放简单变量、对象的引用变量。<br>当程序流程走出局部变量所在的代码块后，局部变量会被从栈中弹出。其所占内存会被操作系统自动回收。</p>
<p>每当需要为函数中局部变量开辟空间时，都会从栈中申请。若栈中的内存足够，则系统将为程序提供内存，否则将报异常并提示栈溢出。当函数执行完毕后，会按照后进先出的原则，将局部变量依次弹栈，并将释放出的资源加入到栈中的空闲内存中。</p>
</blockquote>
<p>　　<strong>堆</strong> </p>
<blockquote>
<p>存放程序动态申请的数据。<br>如<code>Java</code>中的对象和<code>C</code>语言使用<code>malloc()</code>函数申请的空间都保存在堆中。 </p>
<p>堆是由内存中的多个分散的存储空间组成的一个不连续的存储空间，各个存储空间基于数据结构中的链表，而组织在一起。当系统收到程序的空间申请时会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p>
<p>保存在堆中的数据，由于是用户自己动态申请的空间，所以当堆中的数据不再需要被使用时，则应该由用户手工释放该数据所占据的空间。因为系统并不知道空间中的数据，何时才不再会被用户使用，在<code>Java</code>中却不需要用户手工释放空间。</p>
</blockquote>
<p><br>　　<strong>名词：内存溢出（Out of Memory，OOM）</strong> </p>
<blockquote>
<p>通常在两种情况下，会出现OOM的问题：<br>1、操作系统中当前剩余内存容量，不足以满足进程当前的申请的空间的需求。<br>2、进程当前所占的内存 + 其本次申请的内存 &gt; OS允许单个进程的上限。<br>在Java中若进程遇到了OOM，则该进程会被操作系统给杀掉。</p>
</blockquote>
<p><br>　　<strong>名词：内存泄漏</strong> </p>
<blockquote>
<p>堆内存的空间由各个进程自己申请和释放，当某块申请的内存不再会被使用时，若没有被程序员及时释放，就会导致进程中明明存在可用的内存空间，却偏偏不能使用。<br>进程的内存泄漏情况严重后，最终会导致OOM。</p>
</blockquote>
<p><br>　　<strong>名词：栈溢出（Stack Overflow）</strong> </p>
<blockquote>
<p>栈中剩余空闲空间不足以满足应用程序所需要的空间。<br>递归死循环可以模拟出栈溢出的问题。</p>
</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><br>　　在Java中使用<code>“{}”</code>括起来的代码就称为代码块。 </p>
<p>　　范例1：代码块的使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 构造块</span></span><br><span class="line">    <span class="comment">// 在方法外部、类的内部出现的代码块。</span></span><br><span class="line">    <span class="comment">// 通常用于初始化成员变量，每产生一个对象就会调用一次。</span></span><br><span class="line">    <span class="comment">// 但是由于构造方法也能完成这个作用，所以构造块了解就可以了。</span></span><br><span class="line">    &#123;   </span><br><span class="line">        name=<span class="string">"张三"</span>;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态块</span></span><br><span class="line">    <span class="comment">// 在方法外部、类的内部、使用static修饰的代码块。</span></span><br><span class="line">    <span class="comment">// 通常用于初始化静态变量，只会在类加载的时候调用一次。</span></span><br><span class="line">    <span class="comment">// 静态块和静态方法一样，不可以引用实例变量和实例方法。 </span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 普通代码块 ： 在方法内部出现的代码块。</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line">          System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><br>　　范例1：学生也是人啊。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java中使用extends关键字来实现继承。</span></span><br><span class="line"><span class="comment">// 子类可以继承父类中的非private属性和方法。</span></span><br><span class="line"><span class="comment">// 在Java中不允许多继承，一个子类只能有一个直接父类，C++中允许有多继承。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.score=score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student stu=<span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">90</span>);</span><br><span class="line">        stu.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在Java中可以使用多层继承，一个子类可以有多个间接父类，通俗的说一个人可以有老爸、爷爷、祖宗。。。。。
</code></pre><p><br>　　范例2：关键词super。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="comment">// super关键字的用法和this是一样的，super代表父类的意思，this代表当前对象。</span></span><br><span class="line">        <span class="keyword">super</span>(name);  </span><br><span class="line">        <span class="keyword">this</span>.score=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的属性和方法</span></span><br><span class="line">        System.out.println(<span class="string">"姓名: "</span>+<span class="keyword">super</span>.getName()+<span class="string">"\t分数:"</span>+<span class="keyword">this</span>.score);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// super有三种用法：</span></span><br><span class="line">        <span class="comment">// 调用父类的构造方法。</span></span><br><span class="line">        <span class="comment">// 调用父类的属性。</span></span><br><span class="line">        <span class="comment">// 调用父类的方法。</span></span><br><span class="line">        Student stu=<span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">90</span>);</span><br><span class="line">        stu.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法重写与属性隐藏"><a href="#方法重写与属性隐藏" class="headerlink" title="方法重写与属性隐藏"></a>方法重写与属性隐藏</h2><p><br>　　<strong>方法重写</strong> </p>
<p>　　所谓的方法重写(over riding) 就是指，在子类中定义一个与父类方法中同名的方法。<br>　　方法重写具有如下特点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类中的方法必须和父类中的方法同名。</span></span><br><span class="line"><span class="comment">// 子类方法的参数列表必须和父类方法的完全相同，参数列表的内容包括：参数的个数、顺序、类型。</span></span><br><span class="line"><span class="comment">// 子类中重写的方法的访问权限不能小于父类中方法的访问权限，可以增大访问权限。</span></span><br><span class="line"><span class="comment">// 子类方法的返回值必须和父类方法的返回值相同，如果父类返回double型 则子类也必须是double，或者子类方法返回值的类型是父类方法返回值类型的子类。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果父类方法抛出了异常</span></span><br><span class="line"><span class="comment">//　　子类方法可以不抛异常。</span></span><br><span class="line"><span class="comment">//　　子类方法可以抛出父类方法抛出的异常。</span></span><br><span class="line"><span class="comment">//　　子类方法不可以抛出父类方法没有抛出的异常。</span></span><br><span class="line"><span class="comment">//　　子类方法抛出的异常可以是父类方法抛出的异常的子类，如果父类方法抛出的异常是Exception则子类方法可以抛出任意类型的异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  父类中的private、final修饰的方法不会被重写。</span></span><br><span class="line"><span class="comment">//　　子类无法继承父类中的使用private。如果你重写成功了，那只不过是重新定义。</span></span><br><span class="line"><span class="comment">//　　final修饰的方法 被称为最终方法 不能被重写。即“可以被继承 但不能重写”。</span></span><br><span class="line"><span class="comment">//　　Static修饰的方法可以被重写、继承。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例1：父子冲突。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类中的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 由于父类中的fun()方法是public权限，因此在Student类中继承了该方法。</span></span><br><span class="line">    <span class="comment">// 由于Student类中又定义了一个fun()方法，此时和从父类中继承来的fun方法产生了冲突。</span></span><br><span class="line">    <span class="comment">// 因此就形成了Java中的“方法重写”。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类中的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// 调用重写后的方法</span></span><br><span class="line">        stu.fun();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  使用子类对象调用被重写的方法时 调用的永远都是子类重写后的方法。
</code></pre><p><br>　　范例2：不留遗产给儿子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类中的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类中的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行结果：“父类中的方法”</span></span><br><span class="line">        Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">        stu.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  定理1：如果调用的方法“在子类中被重写”，那么调用一定是子类中的方法。
-  定理2：如果调用的方法“在子类中没被重写”，那么调用的一定是父类中的方法。
-  定理3：父类中的private方法在子类中“永远不是重写，而是重新定义”。
</code></pre><p><br>　　<strong>属性隐藏</strong> </p>
<p>　　所谓的属性隐藏就是指，在子类中定义了一个与父类中同名的属性。</p>
<p><br>　　范例1：父子都有名字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name=<span class="string">"张三"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 由于在子类中定义了一个与父类中同名的实例变量。 </span></span><br><span class="line">    <span class="comment">// 因此父类中的变量被隐藏起来了，不再起作用。</span></span><br><span class="line">    String name=<span class="string">"李四"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(stu.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  private修饰的属性同样不可以被继承。
-  如果希望调用父类中被隐藏的属性，可以在子类中使用super关键字。
-  子类中的属性可以和父类中的属性的类型不相同，只要变量名相同，就可以达到属性隐藏的效果。
-  实际开发中，属性都是private的，因此关于属性的隐藏了解即可。
</code></pre><p><br>　　范例2：请记住隐藏并不是绝对的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age=<span class="number">23</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age =<span class="number">24</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 程序输出的结果为：23</span></span><br><span class="line">        <span class="comment">// 原因：</span></span><br><span class="line">        <span class="comment">// 若在子类中引用了子类的与父类同名的属性，那么引用的一定是子类的。</span></span><br><span class="line">        <span class="comment">// 若在父类中引用了二者同名的属性，那么引用的一定是父类的。</span></span><br><span class="line">        Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">        s.printer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  隐藏父类的属性，其实和局部变量与成员变量同名的处理方法是一个样的，在局部变量的范围内，成员变量被隐藏；在子类的范围内，父类的同名属性被隐藏。
</code></pre><center><br><img src="/img/base/base001_13.png" alt=""><br></center>

<h2 id="关键字final"><a href="#关键字final" class="headerlink" title="关键字final"></a>关键字final</h2><p>　　final关键字四种用法：</p>
<blockquote>
<p>修饰类：此类不可以被继承。<br>修饰方法： 此方法可以被继承但不可以被重写。<br>修饰变量： 此变量被标为常量，只能赋值一次，赋值后其值不可以改变。<br>和static组合一起修饰变量：被成为全局常量或类常量，可以使用类名调用。</p>
</blockquote>
<p>　　关于常量，需要知道的是：</p>
<blockquote>
<p>局部常量：使用之前必须赋值，赋值后其值不可再更改。<br>实例常量：可以在定义的同时赋值，也可以通过“实例块”、“构造方法”赋值。但是实例常量不会有默认值，因此使用之前必须手工赋值。<br>类常量：只能且必须在“定义的同时”或者“静态块”中赋值。</p>
</blockquote>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>　　所谓的抽象类就是指一个不完整的类。</p>
<p><br>　　范例1：定义格式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用abstract class关键字定义抽象类。</span></span><br><span class="line"><span class="comment">// 如果一个类中定义了抽象方法，那么这个类必须是抽象类，即使用abstract定义。</span></span><br><span class="line"><span class="comment">// 抽象类中可以有抽象方法，也可以没有抽象方法。</span></span><br><span class="line"><span class="comment">// 如果一个类继承了抽象类，则必须重写完抽象类中所有抽象方法，否则它也必须使用abstract修饰。</span></span><br><span class="line"><span class="comment">// 抽象类是不可以实例化对象的。</span></span><br><span class="line"><span class="comment">// 被final修饰的类不能有子类，而abstract类必须被继承，因此二者不能同时修饰类。</span></span><br><span class="line"><span class="comment">// 抽象类中可以存在构造方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用abstract关键字定义的方法称为抽象方法。</span></span><br><span class="line">    <span class="comment">// 抽象方法没有方法体，即没有“&#123;&#125;”。</span></span><br><span class="line">    <span class="comment">// 抽象方法只有在被重写后才可以使用。</span></span><br><span class="line">    <span class="comment">// 抽象方法不可以使用private修饰。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>　　接口是一个特殊的类，其内定义的所有属性都是静态常量，所有方法都是抽象方法。</p>
<p><br>　　范例1：定义格式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口使用interface关键字定义。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不论你是否明写，接口中所有的属性默认为public static final。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STR=<span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="comment">// 不论你是否明写，接口中所有的方法默认为public abstract。</span></span><br><span class="line">    <span class="comment">// 因此不能将public改成private、protected关键字。  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能在接口定义构造方法。 即接口只能存在一个系统提供的无参的构造方法。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个类使用implements关键字来实现一个接口。</span></span><br><span class="line"><span class="comment">// 一个类只能同时继承一个类，但是可以同时实现多个接口。</span></span><br><span class="line"><span class="comment">// 类定义完整的格式：class 类名 extends 父类名 implements 接口A名, 接口B名…;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(stu.STR);</span><br><span class="line">        stu.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  接口只能继承接口，接口可以实现多继承，即一个接口可以同时继承多个接口。
-  若在抽象类中定义抽象方法，则需要在方法头部，手工加上abstract关键字。
-  一个抽象类同样可以实现多个接口，但是接口不可以继承类。
</code></pre><p><br>　　范例2：向上转型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类fun()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类fun()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类fun1()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 将子类对象赋值给父类的引用变量的行为，就是向上转型。</span></span><br><span class="line">        <span class="comment">// 进行向上转型后stu只能调用父类中存在的fun()，不能调用fun1()。</span></span><br><span class="line">        Person stu=<span class="keyword">new</span> Student();</span><br><span class="line">        stu.fun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为本质上stu是Student类的对象，它还是可以调用fun1()的，但需要向下转型。</span></span><br><span class="line">        Student stu2= (Student)stu;  </span><br><span class="line">        stu2.fun1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的代码，是无法向下转型的，因为stu本质是Person对象。</span></span><br><span class="line">        <span class="comment">// 强行操作的话，运行时会抛异常。</span></span><br><span class="line">        <span class="comment">// Person   stu= new Person();</span></span><br><span class="line">        <span class="comment">// Student stu1=(Student)stu;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了避免抛出异常可以在向下转型之间使用instanceof关键字进行验证。</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student )&#123;</span><br><span class="line">            Student stu3 = (Student)p;</span><br><span class="line">            System.out.println(<span class="string">"转换成功 p是Studnt类的对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3-1：多态的作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student子类fun()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student子类fun1()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Worker子类fun()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Worker子类fun1()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        demo.calls(<span class="keyword">new</span> Student());</span><br><span class="line">        demo.calls(<span class="keyword">new</span> Worker());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calls</span><span class="params">(Student stu)</span></span>&#123;</span><br><span class="line">        stu.fun();</span><br><span class="line">        stu.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calls</span><span class="params">(Worker worker)</span></span>&#123;</span><br><span class="line">        worker.fun();</span><br><span class="line">        worker.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在Demo类中使用方法重载来实现调用每一个子类的fun()和fun1()方法。
-  假设Person类有100个子类，则就需要在Demo类中重载100方法，这是根本不行的。
-  此时使用对象的多态性就可以很简单的解决这个问题。
</code></pre><p><br>　　范例3-2：修改代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        demo.calls(<span class="keyword">new</span> Student());</span><br><span class="line">        demo.calls(<span class="keyword">new</span> Worker());</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calls</span><span class="params">(Person per)</span></span>&#123;</span><br><span class="line">        per.fun();</span><br><span class="line">        per.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  此时就使用到了 对象多态性中的 向上转型。
-  因为每一个子类中都重写了父类中的方法，JVM使用会调用子类重写后的方法。
-  此时不论有多少个子类，都不需要修改calls方法。
</code></pre><p><br>　　在继承关系中，父类的设计很重要，只要父类设计合理了，代码的开发就非常方便了。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><br>　　定义：所谓的内部类就是指，在一个类的内部定义一个类。<br>　　分类： </p>
<blockquote>
<p>局部内部类<br>实例内部类<br>静态内部类<br>匿名内部类</p>
</blockquote>
<p><br>　　范例1：局部内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"张三："</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> j=<span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 所谓的局部内部类，就是指在一个块中定义的类。</span></span><br><span class="line">        <span class="comment">// 局部内部类和局部变量的地位是一样的，它们都不可以使用访问修饰符和static修饰。</span></span><br><span class="line">        <span class="comment">// 局部内部类的作用范围就是其定义位置开始到“块”结束。</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Outer().name+<span class="string">"说"</span>+j;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Inner().getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  局部内部类可以访问其外部类的私有成员变量和其所在块内定义的局部变量，但是局部变量必须使用final修饰。
</code></pre><p><br>　　范例2：实例内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str=<span class="string">"Hello World"</span>;</span><br><span class="line">    <span class="comment">// 实例内部类就是指在类内方法外定义的内部类。</span></span><br><span class="line">    <span class="comment">// 实例内部类的地位和实例方法是一样的。</span></span><br><span class="line">    <span class="comment">// 实例内部类可以使用private、public、default、protected修饰。</span></span><br><span class="line">    <span class="comment">// private内部类只有其外部类可以访问。</span></span><br><span class="line">    <span class="comment">// protected内部类只有其同一个包中的类和不同包中的其外部类的子类可以访问。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类的全名：外部类名.内部类名。</span></span><br><span class="line">    <span class="comment">// 内部类生成的.class文件，命名为“外部类名$内部类名.class”。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 没有外部类对象，就没有实例内部类的对象。</span></span><br><span class="line">        <span class="comment">// 因此要通过外部类对象，来创建实例内部类的对象。</span></span><br><span class="line">        Outer out=<span class="keyword">new</span> Outer();  </span><br><span class="line">        <span class="comment">// 通过外部类对象实例化内部类对象</span></span><br><span class="line">        Outer.Inner in=out.new Inner();  </span><br><span class="line">        System.out.println(in.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在以后要学的各种框架(FrameWork)时会大量使用内部类，因此最好此时打好基础。
</code></pre><p><br>　　范例3：在外部类的实例方法中，建立内部类的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"张三"</span>;</span><br><span class="line">    <span class="comment">// 内部类不能与外部类同名。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Inner</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str=name + str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">fun</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//在外部类的实例方法中建立实例内部类的对象。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner(<span class="string">" :  Hello World"</span>).str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Outer().fun());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：静态内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，就是指在类内、方法外使用static关键字定义的内部类。</span></span><br><span class="line">    <span class="comment">// 静态内部类的地位和静态方法是一样的。</span></span><br><span class="line">    <span class="comment">// 静态内部类和静态方法中的局部内部类，不能直接访问其外部类的实例成员。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类隶属于外部类，即使没有外部类的对象，静态内部类也同样存在。</span></span><br><span class="line">        <span class="comment">// 因此可以使用“外部类名.内部类名”来实例化。</span></span><br><span class="line">        Outer.Inner in=<span class="keyword">new</span> Outer.Inner(); </span><br><span class="line">        System.out.println(in.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：匿名内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 所谓的匿名内部类，说白了就是指这个类没有名字。</span></span><br><span class="line">        <span class="comment">// 匿名内部类必须继承一个已经存在了的类或者接口。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// “new A()&#123;&#125;”这句话的意思是：建立了一个实现了A接口的匿名内部类的对象 这个内部类没有名字，匿名类中重写了A接口中的fun()方法。</span></span><br><span class="line">        <span class="keyword">new</span> A()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">              System.out.println(<span class="string">"Hello World"</span>);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.fun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “new A()&#123;&#125;”匿名类调用了A接口的无参构造方法，如果需要调用有参构造方法 则在小括号中加上参数即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  匿名内部类意味着只能用一次，而所谓的用，其实就是实例化对象，同时既然只用一次，所以就没必要起名字了，因而我们使用匿名内部类的时候，就将类定义和实例化两个操作合二为一了。
-  本例中，匿名内部类写全了就是：“class 类名 implements A{}”，省写后就成了“new A(){}”。
-  匿名内部类的名称为“Demo$1.class”因为没有名字，所以使用数字进行编号。
</code></pre><h2 id="对象实例化与类加载"><a href="#对象实例化与类加载" class="headerlink" title="对象实例化与类加载"></a>对象实例化与类加载</h2><p><br>　　<strong>对象实例化过程</strong> </p>
<p>　　一个类的对象产生过程从两方面来说：“有父类”和“无父类”。</p>
<p><br>　　范例1：无父类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java中类名是可以使用汉字的，上面的代码可以直接执行。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 盘子</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> 盘子(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        System.out.println(<span class="string">"盘子的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"盘子的实例块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 桌子</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> 盘子  p=<span class="keyword">new</span> 盘子(<span class="string">"盘子"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> 桌子(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        System.out.println(<span class="string">"桌子的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"桌子的实例块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行结果：</span></span><br><span class="line">        <span class="comment">// 盘子的实例块</span></span><br><span class="line">        <span class="comment">// 盘子的构造方法</span></span><br><span class="line">        <span class="comment">// 桌子的实例块</span></span><br><span class="line">        <span class="comment">// 桌子的构造方法</span></span><br><span class="line">        桌子 desk=<span class="keyword">new</span> 桌子(<span class="string">"桌子"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象的建立过程：</span></span><br><span class="line">        <span class="comment">// 程序执行到“new 桌子("桌子");”时，会在堆中申请一定大小的空间。</span></span><br><span class="line">        <span class="comment">// 然后在桌子类中，从上到下，扫描或初始化类的“实例属性”和执行“实例块”。</span></span><br><span class="line">        <span class="comment">// 一切执行完后，才执行桌子类的构造方法，最后将对象在堆中的引用，传递给引用变量。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面执行到桌子类的第13行代码的时候 又跳转到盘子类去执行。
</code></pre><p><br>　　范例2：有父类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 动物</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> 动物(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        System.out.println(<span class="string">"父类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的实例块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 猫  <span class="keyword">extends</span> 动物</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> 猫(String name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"小动物"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        System.out.println(<span class="string">"子类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的实例块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行结果：</span></span><br><span class="line">        <span class="comment">// 父类的实例块</span></span><br><span class="line">        <span class="comment">// 父类的构造方法</span></span><br><span class="line">        <span class="comment">// 子类的实例块</span></span><br><span class="line">        <span class="comment">// 子类的构造方法</span></span><br><span class="line">        猫 cat=<span class="keyword">new</span> 猫(<span class="string">"小狗"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  如果一个类具有父类，则一定会先建立完父类的对象后才会建立子类的对象。
-  在建立子类对象时，默认情况下会在子类的构造方法中会自动调用父类的无参构造方法。
   -  如果父类中没有定义无参的构造方法，则编译就会出错。
-  因此在第14行代码处，显式的指明了要调用父类的哪一个构造方法。
-  需要知道的是，每建立一个此类的对象，都会重复执行一边上面的执行结果。
</code></pre><p><br>　　<strong>类加载过程</strong> </p>
<p>　　所谓的类加载，就是JVM将类加载到内存中，加载完毕后就可以在内存中建立这个类的对象。Java中类加载发生在如下三种情况：</p>
<blockquote>
<p>创建一个类的对象。<br>调用一个类的静态变量。<br>调用一个类的静态方法。</p>
</blockquote>
<p><br>　　范例1：类加载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 猫 </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> 猫(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">          System.out.println(<span class="string">"子类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"猫的静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的实例块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一个类只会被加载到内存一次，不会重复被加载。</span></span><br><span class="line">        <span class="comment">// static块是在类加载的时候被调用，由于类只会被加载一次，所以静态块也只执行一次。</span></span><br><span class="line">        <span class="comment">// “类加载”的过程要早于“对象实例化”的过程，如果有父类则同样先加载父类。</span></span><br><span class="line">        <span class="comment">// 类加载的时候同样是自上向下的扫描静态变量和静态块。谁先定义 先执行谁。</span></span><br><span class="line">        <span class="comment">// 类装载时只扫描静态变量和静态块，不执行静态方法。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行结果：</span></span><br><span class="line">        <span class="comment">// 猫的静态块</span></span><br><span class="line">        <span class="comment">// 子类的实例块</span></span><br><span class="line">        <span class="comment">// 子类的构造方法</span></span><br><span class="line">        <span class="comment">// 子类的实例块</span></span><br><span class="line">        <span class="comment">// 子类的构造方法</span></span><br><span class="line">        猫 cat=<span class="keyword">new</span> 猫(<span class="string">"小狗"</span>);</span><br><span class="line">        猫 cat2=<span class="keyword">new</span> 猫(<span class="string">"小狗"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：一个变态的范例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 生物类</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"生物类的静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"生物类的实例块"</span>);</span><br><span class="line">        System.out.println(<span class="string">"this:"</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    生物类()&#123;</span><br><span class="line">        i=<span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"生物类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"i="</span>+<span class="keyword">this</span>.i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 动物类 <span class="keyword">extends</span> 生物类</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">22</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"动物类的静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"动物类的实例块"</span>);</span><br><span class="line">        System.out.println(<span class="string">"this:"</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    动物类(<span class="keyword">int</span> j)&#123;</span><br><span class="line">        <span class="keyword">this</span>.j=j;</span><br><span class="line">        System.out.println(<span class="string">"动物类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">",j="</span>+<span class="keyword">this</span>.j;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 猫类 <span class="keyword">extends</span> 动物类</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k=<span class="number">33</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"猫类的静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    猫类(<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        System.out.println(<span class="string">"猫类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"猫类的实例块"</span>);</span><br><span class="line">        System.out.println(<span class="string">"this:"</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">",k="</span>+<span class="keyword">this</span>.k;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行结果：        </span></span><br><span class="line">        <span class="comment">// 生物类的静态块</span></span><br><span class="line">        <span class="comment">// 动物类的静态块</span></span><br><span class="line">        <span class="comment">// 猫类的静态块</span></span><br><span class="line">        <span class="comment">// 生物类的实例块</span></span><br><span class="line">        <span class="comment">// this:i=11,j=0,k=0</span></span><br><span class="line">        <span class="comment">// 生物类的构造方法</span></span><br><span class="line">        <span class="comment">// 动物类的实例块</span></span><br><span class="line">        <span class="comment">// this:i=100,j=22,k=0</span></span><br><span class="line">        <span class="comment">// 动物类的构造方法</span></span><br><span class="line">        <span class="comment">// 猫类的实例块</span></span><br><span class="line">        <span class="comment">// this:i=100,j=200,k=33</span></span><br><span class="line">        <span class="comment">// 猫类的构造方法</span></span><br><span class="line">        <span class="comment">// in main:i=100,j=200,k=300</span></span><br><span class="line">        猫类 cat=<span class="keyword">new</span> 猫类(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"in main:"</span>+cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><br>　　异常处理机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。</p>
<p>　　Object类派生出<code>Throwable</code>类，<code>Throwable</code>类是<code>Java</code>中最大的处理异常的类，其又有2个子类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error类 </span></span><br><span class="line"><span class="comment">// Error一般表示由程序运行异常或其他原因导致的一个JVM错误。</span></span><br><span class="line"><span class="comment">// 它们通常是一个致命的错误，不是一般程序能控制的。</span></span><br><span class="line"><span class="comment">// 因此在程序中一般也无法解决此类问题。</span></span><br><span class="line"><span class="comment">// 例如当发生OOM的时候，就会抛出“java.lang.OutOfMemoryError”。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Exception类一般是指程序中可以进行处理的错误。如除数为0、数组下表越界等，其本身又分为两类：</span></span><br><span class="line"><span class="comment">// RuntimeException 异常：此类表示运行时的异常，即在程序运行的时候，由于某些变量的值非法等导致的错误，若出现RuntimeException，那么一定是程序员的错误。</span></span><br><span class="line"><span class="comment">// 其他非RuntimeException异常，如IOException，这类异常一般是外部错误，并不完全是程序本身的错误，而是在应用环境中出现的外部错误。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例1：简单异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 下面会抛出一个数学异常ArithmeticException。</span></span><br><span class="line">        System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：异常处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用try…catch块来捕获异常。</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// try…catch块之间的语句代表是可能产生异常的语句。</span></span><br><span class="line">            <span class="comment">// 一个语句可能会产生多种异常(但是在某一瞬间上只会产生一种异常)，此时可以使用多个catch语句。</span></span><br><span class="line">            <span class="comment">// 当产生一个异常的时候，程序会立刻终止本行代码的执行，直接跳到catch块中进行异常匹配，如果抛出的异常对象的类型和某一个catch块后面指定的类型兼容，则就执行此catch内的语句，否则继续匹配下一个catch语句。</span></span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> j = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            System.out.println(i/j);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">            <span class="comment">// 在Java中“万物皆对象”，异常也是一个对象，JVM会自动根据不同的情况产生不同的异常对象。 </span></span><br><span class="line">            <span class="comment">// 例如：如果程序执行到了10/0则会产生“数学异常”。</span></span><br><span class="line">            <span class="comment">// 例如：如果程序引用了大于等于数组长度的下标 则会产生“数组越界异常”。</span></span><br><span class="line">            System.out.println(<span class="string">"NumberFormatException 被执行"</span>+e);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"ArithmeticException 被执行"</span>);</span><br><span class="line">            <span class="comment">// 打印异常信息和异常抛出的完整路线(即异常堆栈轨迹)，此种打印方法最常用。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 由于Exception是“最大”的异常处理类，所以任何异常只要是遇到了包含Exception的catch块，都会进去执行此catch块。</span></span><br><span class="line">            <span class="comment">// 范围大的catch块一定要放在范围小的catch块之后，否则编译出错。</span></span><br><span class="line">            System.out.println(<span class="string">"Exception 被执行"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// finally块中的语句不论程序中是否抛出异常，都会去执行。</span></span><br><span class="line">            System.out.println(<span class="string">"不论是否产生异常 finally都会被执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：只有一句啊？太没诚意了吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 下面的代码会编译出错</span></span><br><span class="line">        <span class="comment">// Java中在if后面定义一个对象是完全没有意义的，因为没有人可以使用到它。</span></span><br><span class="line">        <span class="comment">// 解决的方法：在if后面，加上一对大括号。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)</span><br><span class="line">            Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：手动抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 由于IllegalArgumentException是一个运行异常，因此不需要在构造方法头部使用throws关键字。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span> || (age&lt;<span class="number">0</span> || age &gt; <span class="number">150</span>))</span><br><span class="line">            <span class="comment">// 使用throw关键字手动抛出异常。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数非法"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name ;</span><br><span class="line">        <span class="keyword">this</span>.age = age ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 由于方法头部没有throws关键字，那么在方法的调用处也就不需要使用try…catch语句了。</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,-<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：异常信息阅读。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        div(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 不能单独使用try块，try块之后必须跟随一个catch块或者一个finally块。</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i / j ;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常信息：</span></span><br><span class="line"><span class="comment">//java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">//    at Demo.div(Demo.java:7)</span></span><br><span class="line"><span class="comment">//    at Demo.main(Demo.java:3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出的异常对象是 java.lang.ArithmeticException 类的。</span></span><br><span class="line"><span class="comment">// 异常信息是：by zero(即 除数为零)</span></span><br><span class="line"><span class="comment">// 异常抛出的起点：Demo.div(Demo.java:7) ，即Demo.java文件中的第7行代码，同时也是指Demo.java文件中的Demo类中的div方法中抛出。</span></span><br><span class="line"><span class="comment">// 异常抛出的终点： main方法。  (Demo.java:3)</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  如果程序中同时有return和finally语句 那么程序会先执行finally块中的语句 执行完后 才会执行return返回到方法的调用处。
</code></pre><p><br>　　范例6：自定义异常类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IamSorry</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IamSorry</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IamSorry</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span> || (age&lt;<span class="number">0</span> || age &gt; <span class="number">150</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IamSorry(<span class="string">"参数非法"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name ;</span><br><span class="line">        <span class="keyword">this</span>.age = age ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,-<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常非常简单，共分4步：</span></span><br><span class="line"><span class="comment">// 第一步 自己想一个类名 。</span></span><br><span class="line"><span class="comment">// 第二步 让这个类继承Exception 类或者 RuntimeException类。</span></span><br><span class="line"><span class="comment">// 第三步 重写两个构造方法： 无参的 和 有一个String参数的构造方法。</span></span><br><span class="line"><span class="comment">// 第四步 然后就可以使用了。</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  我们都是使用系统自定义好的异常，一般来说不会去自定义异常。
</code></pre><p><br>　　范例7：断言。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所谓的断言就是程序员告诉JVM：“我肯定 程序执行到某条语句的时候 其结果肯定是我说的值”。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">        <span class="comment">// 使用assert关键字来进行“断言”。</span></span><br><span class="line">        <span class="keyword">assert</span> i == <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证断言需要在执行程序的时候使用如下命令： java -ea Demo</span></span><br><span class="line"><span class="comment">// -ea 就代表验证断言是否正确的意思。</span></span><br><span class="line"><span class="comment">// 如果不加 –ea 则程序不会自主的进行断言判断。</span></span><br><span class="line"><span class="comment">// 如果断言正确，则什么事都没有，如果断言错误，则会抛出错误：Exception in thread "main" java.lang.AssertionError。</span></span><br><span class="line"><span class="comment">// 也可以自定义错误信息“assert i == 100：“断言错误”;”，那么抛出的异常信息则为：</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.lang.AssertionError: 断言错误</span></span><br></pre></td></tr></table></figure></p>
<h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p><br>　　包实际上就是一个文件夹。<br>　　包机制的主要目的：实现在不同的文件夹中可以存在同名的类。</p>
<p><br>　　范例1：简单包定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用package关键字定义包，cxy.zy.demo是包名，包名可以任意自定义。</span></span><br><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译此程序使用：“javac  -d  .  Demo.java”</span></span><br><span class="line"><span class="comment">// -d  代表创建目录。根据package语句来生成目录。</span></span><br><span class="line"><span class="comment">// .   代表在当前目录下创建。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译此程序后，会在当前目录下生成一个名为cxy的文件夹，其下又有zy文件夹，zy下面又有一个demo文件夹。</span></span><br><span class="line"><span class="comment">// 在Demo.java文件中定义的所有类都会被放到cxy.zy.demo包下面。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后生成的.class文件中的类名就成为：  包名.类名。</span></span><br><span class="line"><span class="comment">// 如Demo类的全名为 ：cxy.zy.demo.Demo</span></span><br><span class="line"><span class="comment">// 如Student类的全名为 ：cxy.zy.demo.Student</span></span><br><span class="line"><span class="comment">// 因此在执行类的时候应该使用如下语句：java cxy.zy.demo.Demo</span></span><br><span class="line"><span class="comment">// 此时JVM会自动进入到cxy/zy/demo文件夹下执行名为cxy.zy.demo.Demo的类。</span></span><br><span class="line"><span class="comment">// 但是不能人为的进入到cxy/zy/demo文件夹下执行“java Demo”或者“java cxy.zy.demo.Demo”语句，这是不可能成功的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：导入包。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用import语句导入cxy.zy.demo包中的Demo类。</span></span><br><span class="line"><span class="comment">// import可以有多条，但是必须放在所有类定义之前及package语句之后。</span></span><br><span class="line"><span class="comment">// 如果要导入一个包中的多个类 可以使用“import cxy.zy.demo.*;”</span></span><br><span class="line"><span class="comment">// 使用.*导入包时，只会导入程序中使用到的类，那些没使用到的类不会被导入。</span></span><br><span class="line"><span class="keyword">import</span> cxy.zy.demo.Demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        d.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：2个包中具有同名类啊。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Demo1包中的Test类"</span>) ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cxy.zy.demo2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Demo2包中的Test类"</span>) ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="keyword">import</span> cxy.zy.demo1.*;</span><br><span class="line"><span class="keyword">import</span> cxy.zy.demo2.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于上例中两个包中都有Test类，所以在建立对象的时候需要指定类的全名，否则编译报错： 引用不明确。</span></span><br><span class="line">        <span class="comment">// 在开发时所有的类都必须存在于包中。</span></span><br><span class="line">        cxy.zy.demo1.Test t = <span class="keyword">new</span> cxy.zy.demo1.Test();</span><br><span class="line">        t.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在进行包导入的时候需要先配置classpath变量，此变量是JVM“找类”用的。
</code></pre><p><br>　　范例4：静态导入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="comment">// 所谓的静态导入就是，只导入一个类中的静态成员。</span></span><br><span class="line"><span class="comment">// 使用 import static 来进行静态导入Math类的静态变量和方法。</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用静态导入，导入某一个具体的静态方法或静态常量。 </span></span><br><span class="line"><span class="comment">// import static java.lang.Math.pow ;</span></span><br><span class="line"><span class="comment">// import static java.lang.Math.PI ;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 静态导入可以直接使用方法或变量的名称调用其他类的一个静态方法或变量，而不需要再使用类名.方法名来调用。</span></span><br><span class="line">        System.out.println(PI);</span><br><span class="line">        System.out.println(pow(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：系统常用包。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang包 ：此包包含了各种常用类，例如：Object、String等。在JDK1.0中此包需要手工导入，但是在现在此包会自动导入到程序中。</span></span><br><span class="line"><span class="comment">// ava.lang.reflect包 ：此包为反射机制包，是整个Java乃至整个Java世界中最重要的包，此包可以完成大量的底层操作。</span></span><br><span class="line"><span class="comment">// java.util包 ： 工具包，包含各种常用的操作类 如类库、类集等中的类都在此包中。</span></span><br><span class="line"><span class="comment">// java.io包 ： 没的说 是Java中的IO包。</span></span><br><span class="line"><span class="comment">// java.net包 ：网络编程。</span></span><br><span class="line"><span class="comment">// java.sql包：数据库编程。</span></span><br><span class="line"><span class="comment">// java.text包：在国际化时候使用此包。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Jar命令"><a href="#Jar命令" class="headerlink" title="Jar命令"></a>Jar命令</h2><p><br>　　在开发中一个软件会有很多的类，如果现在把这写类散装着给用户则肯定不好，因为太多了、容易乱，所以一般会将这些类压缩成一个jar包，然后将jar包发给用户就行了。<br>　　Jar文件其实就是一个压缩文件。</p>
<p><br>　　范例1：假设有一个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　编译文件：</p>
<blockquote>
<p>javac -d . Demo.java</p>
</blockquote>
<p>　　压缩文件：</p>
<blockquote>
<p>jar -cvf  my.jar  cxy</p>
</blockquote>
<center><br><img src="/img/base/base001_14.png" alt=""><br></center>

<pre><code>语句解释：
-  c ：创建文档
-  v ：详细的输出到底哪个类被导入到了jar包中了。
-  f ：指定文件的名称。 上例中文件名称为 my.jar
-  cxy ：要压缩的文件夹。 压缩时会将其子文件夹一起压缩。
</code></pre><p>　　此时就可以将这个jar文件发给客户了，客户拿到此文件后需要设置一下classpath，在其中加上此文件的路径就可以在程序中使用了。</p>
<p><br>　　范例2：双击可运行的Java程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将所有的类压缩成一个jar文件。</span></span><br><span class="line"><span class="comment">// 建立一个文件： mainclass.mf  使用记事本打开它。</span></span><br><span class="line"><span class="comment">// 在其中加上： Main-Class: 包名.类名</span></span><br><span class="line"><span class="comment">// 再在最后面加上一个回车键。</span></span><br><span class="line"><span class="comment">// 使用 jar –ufm  jar文件的名称 mainclass.mf</span></span><br><span class="line"><span class="comment">// 　　u 代表：更新现有的归档文件。</span></span><br><span class="line"><span class="comment">// 　　代表：指定文件名。</span></span><br><span class="line"><span class="comment">// 　　m代表：包含指定清单文件中的清单信息。</span></span><br><span class="line"><span class="comment">// 双击jar文件即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：jar –ufm  my.jar  mainclass.mf</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  要始终记住 Java程序只能在JVM上运行，离开了JVM它是无法执行的。
-  所谓的双击运行只是方便程序的执行而已，电脑中必须得安装JDK或者JRE后才可以执行，否则 即使建立好了jar文件也没用，因为没有虚拟机。
-  有一种软件可以将java程序转换成.exe程序，原理也是一样的，如果电脑中没有JVM即使是转成.exe文件，也照样不能执行。
</code></pre><h1 id="类库基础"><a href="#类库基础" class="headerlink" title="类库基础"></a>类库基础</h1><h2 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><br>　　在<code>Java</code>中<code>String</code>类用来表示一个字符串，它是<code>final</code>的不可被继承。同时<code>Java</code>中所有的字符串文字都是一个<code>String</code>的对象。</p>
<p>　　有两种方式可以创建一个String对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接赋值字符串常量，此时内存中建立了一个String对象。</span></span><br><span class="line">String str = <span class="string">"Hello World"</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过使用new关键字调用构造方法来实例化字符串对象。</span></span><br><span class="line"><span class="comment">// 此时内存中建立了两个String对象，一个是字符串常量"Hello World"，另一个是new出来的。</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure></p>
<p>　　常量池(constant pool)指的是在编译期被确定、并被保存在<code>.class</code>文件中的一些数据，组成的集合。它包括了关于类、方法、接口等中的常量，也包括字符串常量。<br>　　常量池中的字符串常量是唯一的，在池中不会同时存在两个相同的字符串常量。<br>　　使用第一种方法创建String对象时，JVM会从常量池中查找出常量”Hello World”的引用然后赋值给变量str。<br>　　使用第二种方法创建String对象是很浪费空间，因此很少用那种方法。</p>
<p><br>　　范例1：怎么证明只有一个呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"this is message"</span>;</span><br><span class="line">        String str2 = <span class="string">"this is message"</span>;</span><br><span class="line">        <span class="comment">// 程序输出true。</span></span><br><span class="line">        <span class="comment">// 两个引用变量使用“==”进行相等运算时，比较的是它们是否同时指向同一个对象。</span></span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">        String a = <span class="string">"A"</span>;</span><br><span class="line">        String b = <span class="string">"C"</span>;</span><br><span class="line">        String c = <span class="string">"AC"</span>;</span><br><span class="line">        a = a+b;</span><br><span class="line">        <span class="comment">// 程序输出false。</span></span><br><span class="line">        <span class="comment">// 新串"AC"是在程序运行的时候产生的，它存在于堆中，因此他和常量"AC"不是一个。</span></span><br><span class="line">        System.out.println(a == c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：其它常用函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串指定位置上的字符，index&gt;=0 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将字符串转成字符数组。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">toCharArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将String变成字节数组。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getBytes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 构造方法，将字节数组转成String对象。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比如：new String(new byte[]&#123;97,98,99&#125;)，结果为：abc</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断是否以指定的字符串开始。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String pref)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 判断是否以指定的字符串结束。     </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 替换字符串的内容，注意String类实现了CharSequence接口。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence oldString, CharSequence newString)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比如："---- Hello World ----".replace("-", "+");</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将字符串中所有的-号替换为+号，并将新串返回来，但此时str的值并没有改变。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 字符串截取。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex,  <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比如1：str.substring(5, 10)从下标为5的位置开始，到10(不包括)结束。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比如2：str.substring(5)从下标为5截取到字符串末尾。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 从0开始查找字符串，如果找到了则返回下标，如果未找到则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从指定位置开始向后进行字符串查找，如果未找到则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 字符串查找，如果查找到了则返回true否则返回false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span> <span class="params">(CharSequence s)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 消掉字符串首尾的小于等于\u0020的字符 (空格符的编码是(32)10)。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 计算字符串长度。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>      </span></span><br><span class="line"><span class="function"><span class="comment">// 将字符串中的所有大写字母转成小写，不是大写字母则不变。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 将字符串中的所有小写字母转成大写，不是小写字母则不变。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较两个字符串，返回两个字符串中第一个不相同的字符间的差。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果第一个字符串大则返回一个正数，否则返回一个负数，如果两个字符串相同则返回0.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String ano)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// “equals()”方法：比较的是两个字符串的内容。</span></span></span><br><span class="line"><span class="function"><span class="comment">// “equalsIgnoreCase()”方法：忽略大小写比较2个字符串的内容。</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><br>　　在<code>Java</code>中所有的类都是从<code>Object</code>类派生出来的。如果一个类没有明确的继承一个类，则它默认继承<code>Object</code>类，如果有父类，则它的父类或父类的父类….中，总有一个类是默认继承<code>Object</code>。</p>
<p><br>　　范例1：接收任何类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">// Object类可以接受任意引用类型的对象，包括一维、二维数组</span></span><br><span class="line">        <span class="comment">// 只要是new出来的东西都可以赋值给Object类的引用变量。 </span></span><br><span class="line">        Object obj = array;</span><br><span class="line">        print(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object array)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 但是若想再次使用原来的对象，则需要向下类型转化。</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = (<span class="keyword">int</span>[])array;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:temp)</span><br><span class="line">            System.out.print(i+<span class="string">"、"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：常用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student temp = (Student)obj ;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(temp.name) &amp;&amp; <span class="keyword">this</span>.age == temp.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果不重写toString()方法则输出的数据：</span></span><br><span class="line">        <span class="comment">// 对象所在类类名@对象的hashcode码(16进制形式)。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是一个学生"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当一个对象需要被转换成String类型的，就会调用该对象的toString方法。</span></span><br><span class="line">        <span class="comment">// 常见的需要转换的场景有：</span></span><br><span class="line">        <span class="comment">// 1、System.out.println()，输出一个对象。</span></span><br><span class="line">        <span class="comment">// 2、“转换吧：”+ new Student()，和一个字符串链接。</span></span><br><span class="line">        <span class="comment">// 3、我们手动调用toString()方法。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为此方法在Student类被重写了，所以输出的结果为："我是一个学生"。</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">30</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 使用“==”号比较两个对象的时候，比较的是对象引用变量中保存的值。</span></span><br><span class="line">        <span class="comment">// 如果想比较两个对象的内容(即字段)则需要重写object类的equals方法。</span></span><br><span class="line">        System.out.println(stu1.equals(stu2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String类也有一个equals()方法，其实这个方法就是重写Object中的方法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h2><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p><br>　　<code>Java</code>程序是以进程的形式运行在操作系统中的，<code>Runtime</code>类代表当前<code>JVM</code>的运行时环境，<code>Runtime</code>类是<code>Singleton</code>的由<code>JVM</code>来实例化。<br>　　使用<code>Runtime</code>类可以获取当前进程中<code>JVM</code>的内存状态、操作子进程等。</p>
<p><br>　　范例1：取得系统内存信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Runtime类的单例对象。</span></span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        <span class="comment">// 返回JVM试图使用的最大内存量。单位：字节。</span></span><br><span class="line">        System.out.println(<span class="string">"试图使用的最大内存："</span>+r.maxMemory());</span><br><span class="line">        <span class="comment">// 返回JVM中实际可用的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。单位：字节。</span></span><br><span class="line">        System.out.println(<span class="string">"实际可用总内存："</span>+r.totalMemory());</span><br><span class="line">        <span class="comment">// 返回当前JVM中的空闲内存量。单位：字节。</span></span><br><span class="line">        System.out.println(<span class="string">"空闲内存："</span>+r.freeMemory());</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            str += i;</span><br><span class="line">        System.out.println(<span class="string">"空闲内存："</span>+r.freeMemory());</span><br><span class="line">        <span class="comment">// 运行垃圾回收器。</span></span><br><span class="line">        <span class="comment">// 调用此方法意味着 Java 虚拟机做了一些努力来回收未用对象，以便能够快速地重用这些对象当前占用的内存。</span></span><br><span class="line">        r.gc();</span><br><span class="line">        System.out.println(<span class="string">"gc后，空闲内存："</span>+r.freeMemory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：垃圾回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于垃圾回收。</span></span><br><span class="line"><span class="comment">// 在每个Java应用程序运行的时候，其内都会开启多个线程，每个线程用来完成不同的任务。</span></span><br><span class="line"><span class="comment">// 这些线程中包含有：执行程序的入口代码的主线程、执行垃圾回收的gc线程等等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从线程的重要角度来说，线程可以被分为：后台线程和非后台线程。 </span></span><br><span class="line"><span class="comment">// 后台线程是在后台为别人提供服务的线程，但当程序的所有非后台线程结束时，即使后台线程还没有结束，程序也将终止。</span></span><br><span class="line"><span class="comment">// 主(main)线程是非后台线程，gc是一个后台线程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当虚拟机判定内存不够的时候，gc会自动进行垃圾回收，因此在Java中通常不需要程序员手工的回收内存空间。</span></span><br><span class="line"><span class="comment">// 谁是垃圾？</span></span><br><span class="line"><span class="comment">// 在Java中，不再被引用的对象(没有引用变量指向的对象) 将被Java虚拟机视为垃圾。</span></span><br><span class="line"><span class="comment">// 注意：GC线程执行垃圾回收操作的时间是不确定，因此可以调用System.gc()方法来通知gc线程去执行垃圾回收操作。 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">";年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 当一个类对象被回收之间，会调用该类的finalize()方法进行收尾工作。</span></span><br><span class="line">        <span class="comment">// finalize方法来自于Object类，重写时应将访问权限改为public。</span></span><br><span class="line">        <span class="comment">// 对象的收尾工作和人死之前要写遗书是一个概念。</span></span><br><span class="line">        System.out.println(<span class="string">"("</span> + <span class="keyword">this</span> + <span class="string">")因为犯罪被回收了."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">30</span>);</span><br><span class="line">        p = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：运行本机上的exe程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本范例需要运行在Windows系统中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        <span class="comment">// Process类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（killing）进程的方法。 </span></span><br><span class="line">        <span class="comment">// 通过ProcessBuilder.start()和Runtime类的exec()方法可以创建一个本机进程。</span></span><br><span class="line">        <span class="comment">// 事实上在Runtime类的exec()方法中就是调用的ProcessBuilder类完成进程的创建。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开Windows画图程序。</span></span><br><span class="line">        <span class="comment">// exec方法会在单独的进程中执行指定的字符串命令。 </span></span><br><span class="line">        <span class="comment">// 其会返回一个Process对象，代表当前进程的子进程，使用Process可以进一步操作子进程。</span></span><br><span class="line">        Process p = r.exec(<span class="string">"mspaint"</span>); </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 2秒后关闭子进程。</span></span><br><span class="line">        <span class="comment">// 关闭进程</span></span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止当前正在运行的JVM，此方法从不正常返回，可以将变量作为一个状态码。</span></span><br><span class="line"><span class="comment">// 根据惯例非零的状态码表示非正常终止。</span></span><br><span class="line"><span class="comment">// 此方法是Runtime类的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>　　<code>System</code>类是一个系统类，其内的方法和变量都是静态的，其构造方法被隐藏。<br>　　在<code>System</code>类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</p>
<p><br>　　范例1：计算程序执行的时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1秒=1000毫秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 返回当前时间距离1970年1月1日午夜之间的时间差(单位：毫秒)。</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++)</span><br><span class="line">            str += i;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"耗时"</span> + ((end - start) / <span class="number">1000</span>)+<span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：数组复制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// System.arraycopy方法，用来复制数组中的元素到另一数组中。</span></span><br><span class="line">        <span class="comment">// 第一个参数：源数组。</span></span><br><span class="line">        <span class="comment">// 第二个参数：从源数组的此位置上的元素开始copy。</span></span><br><span class="line">        <span class="comment">// 第三个参数：目标数组。 </span></span><br><span class="line">        <span class="comment">// 第四个参数：将copy来的元素放到目标数组从此位置上开始。</span></span><br><span class="line">        <span class="comment">// 第五个参数：从源数组中copy多少个元素。</span></span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, array2, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Arrays类在后面就会讲到，此处的toString方法是将数组中的所有元素转换成String类型。</span></span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><br>　　范例1：数组操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="comment">// 若两个数组以相同顺序包含相同的元素，则两个数组是相等的。</span></span><br><span class="line">        <span class="comment">// 此外，若两个数组引用都为null，则认为它们是相等的。</span></span><br><span class="line">        System.out.println(Arrays.equals(a, b)); </span><br><span class="line">        <span class="comment">// 将当前数组内的元素按照从小到大的顺序排序。</span></span><br><span class="line">        <span class="comment">// sort方法可以对除了boolean类型之外的7种基本类型排序和对象数组进行按非递减的顺序排序。</span></span><br><span class="line">        Arrays.sort(b); </span><br><span class="line">        System.out.println(Arrays.equals(a, b));</span><br><span class="line">        <span class="comment">// 将指定的int值（第二个参数）分配给指定int型数组的每个元素。</span></span><br><span class="line">        Arrays.fill(b, <span class="number">5</span>); </span><br><span class="line">        <span class="comment">// 返回指定数组内容的字符串表示形式。</span></span><br><span class="line">        System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] arrChar = &#123;<span class="string">'C'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arrInt = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">// 输出：China</span></span><br><span class="line">        <span class="comment">// 由于System.out对象提供了println(char[] x)方法，所以能直接输出字符串。</span></span><br><span class="line">        System.out.println(arrChar);    </span><br><span class="line">        <span class="comment">// 输出：[C@de6ced</span></span><br><span class="line">        System.out.println(<span class="string">"输出char数组："</span>+arrChar);</span><br><span class="line">        <span class="comment">// 输出：[I@c17164</span></span><br><span class="line">        System.out.println(<span class="string">"输出int数组："</span>+arrInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：对象数组排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  如果一个自定义类想使用Arrays类的sort方法进行排序，需要实现Comparable接口。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name , <span class="keyword">int</span> age ,<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.score =score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span>+<span class="keyword">this</span>.name+<span class="string">","</span>+<span class="keyword">this</span>.age+<span class="string">"岁,"</span>+<span class="keyword">this</span>.score+<span class="string">"分&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现Comparable接口后，需要重写此方法，此方法用来比较当前对象与指定对象的顺序。</span></span><br><span class="line">    <span class="comment">// 如果当前对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</span></span><br><span class="line">    <span class="comment">// 　　返回一个大于0的数，意味着需要将当前对象和参数对象交换位置。 </span></span><br><span class="line">    <span class="comment">// 　　返回一个小于0的数，意味着不需要将当前对象和参数对象交换位置。 </span></span><br><span class="line">    <span class="comment">// 　　返回0代表相等。</span></span><br><span class="line">    <span class="comment">// 按成绩从高到低排序学生，如果成绩相同，则按年龄从小到大排序。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student stu)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.score &gt; stu.score)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.score &lt; stu.score) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; stu.age)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.age &lt; stu.age)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student[] array =&#123;</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">21</span>,<span class="number">99</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">25</span>,<span class="number">91</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">22</span>,<span class="number">94</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">"赵六"</span>,<span class="number">24</span>,<span class="number">42</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">"秦七"</span>,<span class="number">23</span>,<span class="number">42</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"==========排序之前============="</span>);</span><br><span class="line">        print(array);</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        System.out.println(<span class="string">"==========排序之后============="</span>);</span><br><span class="line">        print(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Student stu:array)</span><br><span class="line">            System.out.println(stu) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：数学运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Math类在java.lang包中，主要用来执行一些数学运算，如求绝对值、正弦、余弦等。</span></span><br><span class="line"><span class="comment">// 其内的所有方法和字段都是静态的。</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"E = "</span> + E)  ;</span><br><span class="line">        System.out.println(<span class="string">"PI = "</span> + PI) ;</span><br><span class="line">        System.out.println(<span class="string">"max(2,3) = "</span> + max(<span class="number">2</span>,<span class="number">3</span>)) ;<span class="comment">//计算最大数</span></span><br><span class="line">        System.out.println(<span class="string">"min(5,4.3) = "</span> + min(<span class="number">5</span>,<span class="number">4.3</span>)) ;</span><br><span class="line">        System.out.println(<span class="string">"pow(2,4) = "</span> + pow(<span class="number">2</span>,<span class="number">4</span>)) ;<span class="comment">//计算 24 </span></span><br><span class="line">        System.out.println(<span class="string">"abs(-44)"</span> + abs(-<span class="number">44</span>)) ; <span class="comment">// 计算绝对值</span></span><br><span class="line">        System.out.println(<span class="string">"round(83.652)"</span> + round(<span class="number">83.652</span>)) ;<span class="comment">//四舍五入</span></span><br><span class="line">        <span class="comment">// 向上取整，即ceil(1.1)的值为2.0 ，但是咱下面这个语句则输出2.0 。</span></span><br><span class="line">        System.out.println(<span class="string">"ceil = "</span> + ceil(<span class="number">50</span> / <span class="number">20</span>)); </span><br><span class="line">        <span class="comment">// 因为两个整数相除的结果一定是整数。 50/20的值为2，然后才进行ceil(2)。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：Random类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Random类在java.util包中。此类用于产生一个伪随机数，详见(官方API)。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        System.out.println(<span class="string">"随机一个int数："</span>+r.nextInt());</span><br><span class="line">        System.out.println(<span class="string">"随机一个long数："</span>+r.nextLong());</span><br><span class="line">        <span class="comment">// 返回一个从 0.0d(包括)到 1.0d(不包括)范围的数</span></span><br><span class="line">        System.out.println(<span class="string">"随机一个double数："</span>+r.nextDouble());</span><br><span class="line">        <span class="comment">// 返回一个从 0.0f(包括)到 1.0f(不包括)范围的数</span></span><br><span class="line">        System.out.println(<span class="string">"随机一个float数："</span>+r.nextFloat());</span><br><span class="line">        System.out.println(<span class="string">"随机一个boolean数："</span>+r.nextBoolean());</span><br><span class="line">        <span class="comment">// 随机0(包括)~100(不包括)间的数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            System.out.print(r.nextInt(<span class="number">100</span>) + <span class="string">"、"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：Scanner类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本类需要用到后面IO一节中讲解的知识，请看完后在回来看此类。</span></span><br><span class="line"><span class="comment">// Scanner类一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">if</span>(sc.hasNextInt())</span><br><span class="line">           System.out.println(<span class="string">"读到数字：  "</span>+sc.nextInt());</span><br><span class="line">        <span class="keyword">if</span>(sc.hasNextBoolean())</span><br><span class="line">               System.out.println(<span class="string">"读到boolean：  "</span>+sc.nextBoolean());</span><br><span class="line">        <span class="keyword">if</span>(sc.hasNext())</span><br><span class="line">               System.out.println(<span class="string">"读到一个单词：  "</span>+sc.next());</span><br><span class="line">        System.out.println(<span class="string">"读到一行数据：  "</span>+sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 64</span></span><br><span class="line"><span class="comment">// 读到数字：  64</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// 读到boolean：  false</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// 读到一个单词：  Hello</span></span><br><span class="line"><span class="comment">// 世界,你好！ \n HelloWorld</span></span><br><span class="line"><span class="comment">// 读到一行数据：  世界,你好！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断后面是否有一个int型的数据，如果有则返回true。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 读取后面的int型数据。如果后面的数据不是int型数据 则抛异常。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断后面是否有一个单词，如果有则返回true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 读取一个单词（即遇到间隔符或者回车符就停止读取）。</span></span></span><br><span class="line"><span class="function"><span class="comment">// Scanner类的默认分隔符：空格、tab、回车符等 “空白符”。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这些间隔符对除了nextLine()以外的任何方法都有效。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 修改分隔符，但对nextLine()无效，它只认换行符。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Scanner <span class="title">useDelimiter</span><span class="params">(String pattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 读取一行字符串，以换行符为结束标志（遇到间隔符照样读取）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">nextLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Scanner类可以读取七种基本类型，没有nextChar()方法，对应的hasNextXxx()也没有。</span></span></span><br><span class="line"><span class="function"><span class="comment">// Scanner类中next的含义：下一个间隔符之前的内容。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比如nextInt()就是指读取下一个间隔符之前的int型数据。</span></span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例6：字符串处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String类是一个不可改变的字符串。</span></span><br><span class="line"><span class="comment">// StringBuffer是一个类似于String的字符串缓冲区，可以对字符串缓冲区中的字符进行修改(添加、删除)操作。由于可以修改缓冲区的数据，因而就涉及到多线程访问的问题，所以本类的大部分方法都是同步方法(后述)。每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此容量，就无需分配新的内部缓冲区数组。如果内部缓冲区溢出，则此容量自动增大。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 本类提供的很多与String相同功能的API，若程序需要动态的去修改一个字符串则应该使用StringBuffer或StringBuilder类，若是使用String类，则在操作完成后，内存中会产生大量的中间字符串。</span></span><br><span class="line">        <span class="comment">// 注意String和StringBuffer没有任何继承关系，因此不能将一个String对象赋值给一个StringBuffer对象。</span></span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello World"</span>);</span><br><span class="line">        buf.append(<span class="string">"---&gt; cxy"</span>).append(<span class="string">"-----&gt; tsx"</span>);</span><br><span class="line">        buf.insert(<span class="number">0</span>, <span class="string">"cxy@zy ---&gt;"</span>);</span><br><span class="line">        <span class="comment">// 将StringBuffer对象转成String类型。</span></span><br><span class="line">        System.out.println(buf.toString());</span><br><span class="line">        System.out.println(buf.indexOf(<span class="string">"Hello"</span>));</span><br><span class="line">        System.out.println(buf.charAt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(buf.delete(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer类是一个线程安全的可变字符序列。</span></span><br><span class="line"><span class="comment">// StringBuilder类提供了和StringBuffer类相同的接口，但是不是线程安全的，不去考虑多个线程同时操作。</span></span><br><span class="line"><span class="comment">// 因此StringBuilder比StringBuffer的效率要高一些。</span></span><br><span class="line"><span class="comment">// 通常更多的会使用StringBuilder类。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例7：性能测试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在频繁改变字符串的时候 使用StringBuffer比使用String效率要好上很多。</span></span><br><span class="line"><span class="comment">// 在我这里，执行结果： </span></span><br><span class="line"><span class="comment">// 　　stringbuff耗时：16毫秒!</span></span><br><span class="line"><span class="comment">// 　　string耗时：4515毫秒!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start,end;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        stringBuff();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"stringbuff耗时："</span>+(end - start)+<span class="string">"毫秒!"</span>);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        string();</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"string耗时："</span>+(end - start)+<span class="string">"毫秒!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">string</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20000</span>;i++)&#123;</span><br><span class="line">            str += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringBuff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer sub = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20000</span>;i++)&#123;</span><br><span class="line">            sub.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><p><br>　　Date类表示特定的瞬间，精确到毫秒。  </p>
<p><br>　　范例1：日期类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 直接打印Date类的对象就可以得到当前时间。</span></span><br><span class="line">       <span class="comment">// 但是得到的日期格式不符合国人的习惯，因此需要使用其他类对Date类的输出格式进行调整。</span></span><br><span class="line">       Date time = <span class="keyword">new</span> Date();</span><br><span class="line">       System.out.println(time);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：三年之后。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="comment">// Calendar类表示一个日历，它是对Date的一个封装(即增强版的Date)。</span></span><br><span class="line"><span class="comment">// Calendar可以方便的在某个时间上增加或减去一个时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用默认时区和语言环境获得一个日历。</span></span><br><span class="line">        <span class="comment">// 返回的Calendar默认表示的是当前时间，使用了默认时区和默认语言环境。</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        c.add(Calendar.YEAR, <span class="number">3</span>); <span class="comment">//将日历向后翻三年。</span></span><br><span class="line">        <span class="comment">// 参数field：日历字段，常用的取值为：</span></span><br><span class="line">        <span class="comment">// Calendar.YEAR：年。</span></span><br><span class="line">        <span class="comment">// Calendar.MONTH：月。</span></span><br><span class="line">        <span class="comment">// Calendar.DAY_OF_MONTH：日。</span></span><br><span class="line">        <span class="comment">// Calendar.HOUR_OF_DAY：时。</span></span><br><span class="line">        <span class="comment">// Calendar.MINUTE：分。</span></span><br><span class="line">        <span class="comment">// Calendar.SECOND：秒。</span></span><br><span class="line">        <span class="comment">// Calendar.MILLISECOND：毫秒。</span></span><br><span class="line">        System.out.print(c.get(Calendar.YEAR)+<span class="string">"年"</span>);</span><br><span class="line">        <span class="comment">// 月份是从0开始计算的，范围为0~11，因此在输出的时候应该在月份后面+1。</span></span><br><span class="line">        System.out.print(c.get(Calendar.MONTH)+<span class="number">1</span>+<span class="string">"月"</span>);</span><br><span class="line">        System.out.print(c.get(Calendar.DAY_OF_MONTH)+<span class="string">"日"</span>);</span><br><span class="line">        System.out.print(c.get(Calendar.HOUR_OF_DAY)+<span class="string">"时"</span>);</span><br><span class="line">        System.out.print(c.get(Calendar.MINUTE)+<span class="string">"分"</span>);</span><br><span class="line">        System.out.print(c.get(Calendar.SECOND)+<span class="string">"秒"</span>);</span><br><span class="line">        System.out.println(c.get(Calendar.MILLISECOND)+<span class="string">"毫秒"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例如要从当前日历时间减去5天，可以通过调用以下方法做到这一点： </span></span><br><span class="line">        Calendar.getInstance().add(Calendar.DAY_OF_MONTH,-<span class="number">5</span>)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">2012</span>);</span><br><span class="line">        System.out.println(<span class="string">"本年第 "</span> + c.get(Calendar.DAY_OF_YEAR) + <span class="string">" 天"</span>);</span><br><span class="line">        <span class="comment">// 通常国外认为，每周的第一天是周日。</span></span><br><span class="line">        System.out.println(<span class="string">"本周第 "</span> + c.get(Calendar.DAY_OF_WEEK) + <span class="string">" 天"</span>);</span><br><span class="line">        System.out.println(<span class="string">"日期为： "</span> + c.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：日期格式化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在SimpleDateFormat类构造对象的时候，指定格式化后的日期格式。</span></span><br><span class="line">        SimpleDateFormat simple = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日HH时mm分ss秒SSS毫秒"</span>);</span><br><span class="line">        <span class="comment">// 使用format()将Date对象格式化成刚才指定的格式。</span></span><br><span class="line">        System.out.println(simple.format(<span class="keyword">new</span> Date()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<center><br><img src="/img/base/base001_15.png" alt=""><br></center>

<h3 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h3><p><br>　　范例1：对象克隆。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="comment">// 所谓的对象克隆，其实就是指对象的复制。</span></span><br><span class="line"><span class="comment">// Java中不是所有对象都可以克隆的，只有实现了Cloneable接口的类才可被克隆。</span></span><br><span class="line"><span class="comment">// Cloneable接口中没有任何方法实现这个接口类就表示具有了一种能力、一种特点。</span></span><br><span class="line"><span class="comment">// 对象克隆的时候需要重写Object类的clone()方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span>  CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">// 从表面上来说既然转调用clone()方法，那还不如不去重写呢。 </span></span><br><span class="line">        <span class="comment">// 其实不然，仔细观察Object类的clone()方法，它的访问权限是protected的 在不同包的非子类中是无法访问的。 </span></span><br><span class="line">        <span class="comment">// 因此我们重写clone()方法的主要目的就是，扩大clone()方法的访问权限为public。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 而具体的克隆操作，交由父类完成即可。 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>);</span><br><span class="line">        Person p2 = (Person)p1.clone();</span><br><span class="line">        p2.setName(<span class="string">"李四"</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：大数操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="comment">// 所谓的大数据操作就是指，数字超过了基本数据类型的取值范围，此时就不能使用基本数据类型进行数据操作了。</span></span><br><span class="line"><span class="comment">// 在Java中使用了对象的形式进行大数操作，有两个常用的类。</span></span><br><span class="line"><span class="comment">// 　　BigInteger     操作整数</span></span><br><span class="line"><span class="comment">// 　　BigDecimal     操作小数</span></span><br><span class="line"><span class="comment">// BigInteger和BigDecimal都是java.math包中的类，它们都继承自java.lang.Number。</span></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String num = <span class="keyword">new</span> String(<span class="string">"99999999999999999999999999"</span>);</span><br><span class="line">        BigInteger big1 = <span class="keyword">new</span> BigInteger(num);</span><br><span class="line">        BigInteger big2 = <span class="keyword">new</span> BigInteger(num);</span><br><span class="line">        System.out.println(<span class="string">"加法操作：  "</span>+big1.add(big2));  <span class="comment">//加法运算</span></span><br><span class="line">        System.out.println(<span class="string">"减法操作：  "</span>+big1.subtract(big2));<span class="comment">//减法运算</span></span><br><span class="line">        System.out.println(<span class="string">"乘法操作：  "</span>+big1.multiply(big2));<span class="comment">//乘法运算</span></span><br><span class="line">        System.out.println(<span class="string">"除法操作：  "</span>+big1.divide(big2));<span class="comment">//除法运算</span></span><br><span class="line">        <span class="comment">// 有余数的除法运算</span></span><br><span class="line">        BigInteger[] result = big1.divideAndRemainder(big2);  </span><br><span class="line">        <span class="comment">// 第一个数代表商 第二个数代表余数。</span></span><br><span class="line">        System.out.println(<span class="string">"商为：  "</span>+result[<span class="number">0</span>]+<span class="string">"\t余数为： "</span>+result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：大数操作2。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cxy.zy.demo;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加法运算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">oper</span><span class="params">(BigDecimal num1, BigDecimal num2,<span class="keyword">char</span> op)</span></span>&#123;</span><br><span class="line">        BigDecimal  result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: result = num1.add(num2)      ;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: result = num1.subtract(num2) ;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>: result = num1.multiply(num2) ;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除法运算 scale 指定保留的小数位数。BigDecimal.ROUND_HALF_UP 进行四舍五入。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal num1, BigDecimal num2 ,<span class="keyword">int</span> scale)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1.divide(num2,scale,BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BigDecimal big1 = <span class="keyword">new</span> BigDecimal(<span class="string">"1231231.23"</span>);</span><br><span class="line">        BigDecimal big2 = <span class="keyword">new</span> BigDecimal(<span class="string">"12523.12"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"相加："</span>+oper(big1,big2,<span class="string">'+'</span>));</span><br><span class="line">        System.out.println(<span class="string">"相减："</span>+oper(big1,big2,<span class="string">'-'</span>));</span><br><span class="line">        System.out.println(<span class="string">"相乘："</span>+oper(big1,big2,<span class="string">'*'</span>));</span><br><span class="line">        <span class="comment">// 将计算结果保留2位小数。</span></span><br><span class="line">        System.out.println(<span class="string">"相除："</span>+divide(big1,big2,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="国际化类"><a href="#国际化类" class="headerlink" title="国际化类"></a>国际化类</h2><p><br>　　一个经过国际化的处理后软件，会根据用户的国家(语言)不同，在软件的按钮、菜单上面使用不同的文字，以及对日期、货币的显示格式进行转换。<br>　　国际化又称为 i18n：单词internationalization 中i和n之间有18个字符 。<br>　　国际化操作有两种：</p>
<blockquote>
<p>固定文本元素国际化：对按钮、菜单的文字进行国际化。<br>动态文本元素国际化：对日期、数字、消息进行国际化。</p>
</blockquote>
<h3 id="Locale"><a href="#Locale" class="headerlink" title="Locale"></a>Locale</h3><p>　　既然国际化程序，考虑的是适应各个国家语言要求，那么首当其冲的一个问题就是，如何表示一个国家。 在Java中使用java.util.Locale类就可以完成这个任务。</p>
<p><br>　　范例1：中美关系。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个参数，是两位小写的字母，代表语言。</span></span><br><span class="line">        <span class="comment">// 第二个参数，是两位大写的字母，代表国家或地区。</span></span><br><span class="line">        <span class="comment">// 中文(台湾)： zh_TW</span></span><br><span class="line">        <span class="comment">// 中文(香港特别行政区)：zh_HK</span></span><br><span class="line">        <span class="comment">// 需要注意的是：Locale对象本身并不会验证它代表的语言和国家地区信息是否正确 。</span></span><br><span class="line">        Locale china = <span class="keyword">new</span> Locale(<span class="string">"zh"</span>,<span class="string">"CN"</span>);   <span class="comment">// 中文_中国</span></span><br><span class="line">        Locale usa = <span class="keyword">new</span> Locale(<span class="string">"en"</span>,<span class="string">"US"</span>);     <span class="comment">// 英语_美国</span></span><br><span class="line">        System.out.println(china);</span><br><span class="line">        System.out.println(usa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：省点力气。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得此Java虚拟机实例的当前默认语言环境值。</span></span><br><span class="line">        Locale china = Locale.getDefault(); </span><br><span class="line">        System.out.println(china);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="固定文本元素"><a href="#固定文本元素" class="headerlink" title="固定文本元素"></a>固定文本元素</h3><p>　　如果想要实现国际化，光靠Locale是不够的，还需要配置多个属性文件。每个属性文件代表一个国家的语言，其内保存了一套完整的用于在按钮、菜单上面显示的文字，当程序执行时，程序根据用户计算机当前的语言，从不同的属性文件中，读取文字，然后显示到按钮、菜单上面。<br>　　所谓的属性文件，就是指后缀名为<code>“*.properties”</code>的文件。</p>
<p><br>　　范例1：配置文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hi_en_US.properties文件。</span></span><br><span class="line"><span class="comment">// 属性文件的命名规则：基名_语言_国家.properties 。</span></span><br><span class="line"><span class="comment">// 基名：多个属性文件的文件名中共有的那部分。本范例中基名：hi 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性文件中 “=”号左边的被成为“key(键)”，右边的被成为“value(值)” 。</span></span><br><span class="line"><span class="comment">// 在程序中，通过指定某个key来访问所对应的value。</span></span><br><span class="line">button=A Button!</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi_zh_CN.properties文件。</span></span><br><span class="line"><span class="comment">// 在properties文件中不允许出现汉字，因此若想使用汉字则需要将汉字转换成Unicode编码。</span></span><br><span class="line"><span class="comment">// 可以使用“jdk1.6.0_06\bin\native2ascii.exe”文件，来对汉字进行编码，然后将编码的结果存入properties文件中去即可。</span></span><br><span class="line">button=\u6211\u662F\u4E00\u4E2A\u6309\u94AE\!</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：访问文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置完属性文件后，就可以在程序中，根据用户的语言环境，来选择不同的属性文件。</span></span><br><span class="line"><span class="comment">// 然后从属性文件读出数据，最终将数据显示给用户看。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ResourceBundle类，来完成对某个属性文件的读取操作。</span></span><br><span class="line">        <span class="comment">// 使用指定的基本名称、语言环境和调用者的类加载器获取资源包。</span></span><br><span class="line">        <span class="comment">// 文件的名称为：baseName +“_”+ locale.toString() + “.properties”</span></span><br><span class="line">        ResourceBundle rsb = ResourceBundle.getBundle(<span class="string">"hi"</span>,<span class="keyword">new</span> Locale(<span class="string">"en"</span>,<span class="string">"US"</span>));</span><br><span class="line">        <span class="comment">// 若ResourceBundle对象在资源包中找不到与用户匹配的资源文件，它将选择该资源包中与用户最相近的资源文件，如果再找不到，则使用默认资源文件。若仍找不到默认资源文件则抛异常。</span></span><br><span class="line">        System.out.println(rsb.getString(<span class="string">"button"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="动态文本元素"><a href="#动态文本元素" class="headerlink" title="动态文本元素"></a>动态文本元素</h3><p>　　数值，货币，时间，日期等数据由于可能在程序运行时动态产生，所以无法像文字一样简单地将它们从应用程序中分离出来，而是需要特殊处理。</p>
<p>　　<code>java.text.Format</code>是一个抽象类，其下面有三个常用的子类：</p>
<blockquote>
<p>DateFormat  ：用于格式化日期，此类是SimpleDateFormat的父类。<br>NumberFormat：用于格式化数字。<br>MessageFormat：用于批量格式化。</p>
</blockquote>
<p><br>　　范例1：日期国际化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得日期格式化对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Date对象的日期部分抽出来显示。</span></span><br><span class="line">        DateFormat date = DateFormat.getDateInstance();</span><br><span class="line">        <span class="comment">// 将Date对象的时间部分抽出来显示。</span></span><br><span class="line">        DateFormat time = DateFormat.getTimeInstance();</span><br><span class="line">        <span class="comment">// 将Date对象的日期和时间部分抽出来显示。</span></span><br><span class="line">        DateFormat dateTime = DateFormat.getDateTimeInstance();</span><br><span class="line">        <span class="comment">// 获得当前时间。</span></span><br><span class="line">        Date current = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 使用格式化对象对当前日期进行格式化。</span></span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span>+date.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前时间："</span>+time.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前日期+当前时间："</span>+dateTime.format(current));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 程序执行结果：</span></span><br><span class="line">        <span class="comment">// 当前日期：2011-9-7</span></span><br><span class="line">        <span class="comment">// 当前时间：1:46:18</span></span><br><span class="line">        <span class="comment">// 当前日期+当前时间：2011-9-7 1:46:18 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：指定显示风格。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.cxy.i18n;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得日期格式化对象。</span></span><br><span class="line">        DateFormat date1 = DateFormat.getDateInstance(DateFormat.SHORT);</span><br><span class="line">        DateFormat date2 = DateFormat.getDateInstance(DateFormat.MEDIUM);</span><br><span class="line">        DateFormat date3 = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line">        DateFormat date4 = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">        <span class="comment">// 获得当前时间。</span></span><br><span class="line">        Date current = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 使用格式化对象对当前日期进行格式化。</span></span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span>+date1.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span>+date2.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span>+date3.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span>+date4.format(current));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 程序执行结果：</span></span><br><span class="line">        <span class="comment">// 当前日期：11-9-7</span></span><br><span class="line">        <span class="comment">// 当前日期：2011-9-7</span></span><br><span class="line">        <span class="comment">// 当前日期：2011年9月7日</span></span><br><span class="line">        <span class="comment">// 当前日期：2011年9月7日 星期三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应的时间也有四种格式：</span></span><br><span class="line"><span class="comment">// 当前日期：上午1:50</span></span><br><span class="line"><span class="comment">// 当前日期：1:50:13</span></span><br><span class="line"><span class="comment">// 当前日期：上午01时50分13秒</span></span><br><span class="line"><span class="comment">// 当前日期：上午01时50分13秒 CST</span></span><br><span class="line">DateFormat date1 = DateFormat.getTimeInstance(DateFormat.SHORT);</span><br><span class="line">DateFormat date2 = DateFormat.getTimeInstance(DateFormat.MEDIUM);</span><br><span class="line">DateFormat date3 = DateFormat.getTimeInstance(DateFormat.LONG);</span><br><span class="line">DateFormat date4 = DateFormat.getTimeInstance(DateFormat.FULL);</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：指定国家。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.cxy.i18n;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 美国。</span></span><br><span class="line">        Locale locale = <span class="keyword">new</span> Locale(<span class="string">"en"</span>,<span class="string">"US"</span>);</span><br><span class="line">        <span class="comment">// 获得日期格式化对象。</span></span><br><span class="line">        DateFormat date1 = DateFormat.getDateInstance(DateFormat.SHORT,locale);</span><br><span class="line">        DateFormat date2 = DateFormat.getDateInstance(DateFormat.MEDIUM,locale);</span><br><span class="line">        DateFormat date3 = DateFormat.getDateInstance(DateFormat.LONG,locale);</span><br><span class="line">        DateFormat date4 = DateFormat.getDateInstance(DateFormat.FULL,locale);</span><br><span class="line">        <span class="comment">// 获得当前时间。</span></span><br><span class="line">        Date current = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 使用格式化对象对当前日期进行格式化。</span></span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span> + date1.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span> + date2.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span> + date3.format(current));</span><br><span class="line">        System.out.println(<span class="string">"当前日期："</span> + date4.format(current));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序执行结果：</span></span><br><span class="line"><span class="comment">// 当前日期：9/7/11</span></span><br><span class="line"><span class="comment">// 当前日期：Sep 7, 2011</span></span><br><span class="line"><span class="comment">// 当前日期：September 7, 2011</span></span><br><span class="line"><span class="comment">// 当前日期：Wednesday, September 7, 2011</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：数字国际化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.NumberFormat;</span><br><span class="line"><span class="comment">// NumberFormat可以将一个数值格式化为符合某个国家地区习惯的数值字符串，也可以将符合某个国家地区习惯的数值字符串解析为对应的数值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 货币显示对象。</span></span><br><span class="line">        NumberFormat format1 = NumberFormat.getCurrencyInstance();</span><br><span class="line">        <span class="comment">// 通用数值显示对象。</span></span><br><span class="line">        NumberFormat format2 = NumberFormat.getInstance();</span><br><span class="line">        <span class="comment">// 整数显示对象。</span></span><br><span class="line">        NumberFormat format3 = NumberFormat.getIntegerInstance();</span><br><span class="line">        <span class="keyword">double</span> num = <span class="number">1200000000</span>;</span><br><span class="line">        System.out.println(<span class="string">"货币："</span>+format1.format(num));</span><br><span class="line">        System.out.println(<span class="string">"整数："</span>+format3.format(num));</span><br><span class="line">        System.out.println(<span class="string">"通用数值："</span>+format2.format(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序执行结果：</span></span><br><span class="line"><span class="comment">// 货币：￥1,200,000,000.00</span></span><br><span class="line"><span class="comment">// 整数：1,200,000,000</span></span><br><span class="line"><span class="comment">// 通用数值：1,200,000,000</span></span><br><span class="line"><span class="comment">// getCurrencyInstance方法相对于其他两个方法来说比较常用。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应的，也可以将字符串转成数字。</span></span><br><span class="line">NumberFormat format1 = NumberFormat.getCurrencyInstance();</span><br><span class="line">String str = <span class="string">"￥1200000000"</span>;</span><br><span class="line"><span class="keyword">double</span> num = format1.parse(str).doubleValue();</span><br><span class="line">System.out.println(<span class="string">"货币："</span>+num);</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：消息国际化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果一个字符串中包含了多个与国际化相关的数据，可以使用MessageFormat类对这些数据进行批量处理。</span></span><br><span class="line"><span class="comment">// MessageFormat类允许开发人员用占位符替换掉字符串中的数据。</span></span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个“消息”，其中使用了占位符。</span></span><br><span class="line">        <span class="comment">// 占位符的编号从0开始，调用format方法时会自动将传递过去的Object[]中的数据依次放到占位符中去，其实就是进行了字符串替换。</span></span><br><span class="line">        String pattern = <span class="string">"Hi,&#123;0&#125;! 好久不见,&#123;1&#125;你中了&#123;2&#125;万大奖呢!"</span>;</span><br><span class="line">        MessageFormat message = <span class="keyword">new</span> MessageFormat(pattern);</span><br><span class="line">        String name = <span class="string">"Tom"</span>;</span><br><span class="line">        String date = <span class="string">"2011-1-1年时"</span>;</span><br><span class="line">        <span class="keyword">double</span> money = <span class="number">800000000</span>;</span><br><span class="line">        Object[] param = &#123;name,date,money&#125;;</span><br><span class="line">        System.out.println(message.format(param));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例6：消息国际化2。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String pattern = <span class="string">"At &#123;0, time, short&#125; on &#123;0, date&#125;, a destroyed'\n'"</span></span><br><span class="line">            + <span class="string">"&#123;1&#125; houses and caused &#123;2, number, currency&#125; of damage."</span>;</span><br><span class="line">        MessageFormat message = <span class="keyword">new</span> MessageFormat(pattern);</span><br><span class="line">        String datetimeString = <span class="string">"Jul 3, 1998 12:30 PM"</span>;</span><br><span class="line">        Date date = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,</span><br><span class="line">        DateFormat.SHORT,Locale.US).parse(datetimeString);</span><br><span class="line">        String event = <span class="string">"a hurricance"</span>;</span><br><span class="line">        Object []msgArgs = &#123;date, event, <span class="keyword">new</span> Integer(<span class="number">99</span>), <span class="keyword">new</span> Double(<span class="number">1E7</span>)&#125;;</span><br><span class="line">        System.out.println(message.format(msgArgs));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 程序执行结果：</span></span><br><span class="line">        <span class="comment">// At 下午12:30 on 1998-7-3, a destroyed</span></span><br><span class="line">        <span class="comment">// a hurricance houses and caused ￥99.00 of damage.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><br>　　正则表达式(英语：Regular Expression、regex或regexp，缩写为RE)。<br>　　在讨论正则表达式之前，先复习一下表达式的概念。表达式是由数字、算符、数字分组符号(如括号)、变量等以能求得数值的有意义排列方法所得的组合。在Java中有如下几种表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算术表达式  如： 3 * 4</span></span><br><span class="line"><span class="comment">// 关系表达式  如： 3 &gt; 4</span></span><br><span class="line"><span class="comment">// 赋值表达式  如： a = 4</span></span><br><span class="line"><span class="comment">// 逻辑表达式  如： 3 == 4</span></span><br><span class="line"><span class="comment">// 条件表达式  如： 3 &gt; 4?  true : false</span></span><br><span class="line"><span class="comment">// 位运算表达式  如： 3 | 4</span></span><br></pre></td></tr></table></figure></p>
<p>　　在计算机科学中，正则表达式是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。正则表达式和普通表达式的异同点：</p>
<center><br><img src="/img/base/base001_16.png" alt=""><br></center>

<p>　　因此简单地说，正则表达式主要用来进行字符串匹配和替换的。<br><br>　　也许你早已用过它：</p>
<blockquote>
<p>在Windows中打开“我的电脑”后，点击工具栏上的“搜索”按钮，然后输入“文件的名称”并选择查找的目录后，系统就会在你指定的目录下搜索你想要的文件。<br>在你输入的“文件的名称”中是可以使用通配符(wildcard) ： * 和 ? 。<br>若你想查找某个目录下的所有的Word文档的话，你会搜索*.doc，它的含义是查找出所有名称是以“.doc”为结尾的文件或目录。 在这里，*会被解释成任意的字符串。</p>
<p>正则表达式中所使用的各种符号，比起这些简单的通配符来说，它们能更精确地描述你的需求，当然代价就是更复杂。</p>
</blockquote>
<p><br>　　它是如何工作的?</p>
<blockquote>
<p>与正则表达式相对应，存在有相应的“正则表达式引擎”，由“正则表达式引擎”来负责解析正则表达式，程序员只需要写出正则表达式即可。</p>
<p>在很多文本编辑器或其他工具里，正则表达式通常被用来“检索”或“替换”那些符合某个模式的文本内容，许多程序设计语言都支持利用正则表达式进行字符串操作。</p>
</blockquote>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><br>　　在Java中也是支持正则表达式的，可以通过有两种方式进行正则匹配：</p>
<blockquote>
<p>通过String类，进行简单的正则匹配。<br>通过java.util.regex包提供的对正则表达式支持的两个类（Pattern类和Matcher类），用于进行更复杂的匹配操作。</p>
</blockquote>
<p>　　本节将先以String类为例进行讲解。<br>　　在使用正则表达式匹配字符串时，需要提供两个参数，一个是正则式，一个是待匹配串。</p>
<p><br>　　范例1：最简单的正则表达式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通配符，在正则表达式中也被称为元字符(metacharacter)，在正则表达式中提供了很多元字符，接下来会一一介绍。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regexExpress = <span class="string">"hi"</span>;      <span class="comment">// 正则式。</span></span><br><span class="line">        String str1 =<span class="string">"hi"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str2 =<span class="string">"Hi"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str3 =<span class="string">"hi world, hi java!"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        <span class="comment">// 判断str是否符合regexExpress的要求。</span></span><br><span class="line">        <span class="comment">// matches()方法，只有在“匹配串”完全满足“正则式”的情况下才会返回true。</span></span><br><span class="line">        <span class="comment">// 本范例中没有使用任何的元字符，它只用来判断待匹配串的内容是否是“hi”，所以需要二者完全相等。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str3.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是String类提供的与正则表达式相关的API。</span></span><br><span class="line"><span class="comment">// 告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex,String replacement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String regex,String replacement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据给定正则表达式的匹配拆分此字符串。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String regex)</span></span></span><br></pre></td></tr></table></figure></p>
<p>　　在正则表达式中预定义了一些具有特殊意义(即有语法意义)的字符，使用这些字符可以方便的进行匹配操作。预定义字符类的元字符有如下几个：</p>
<center><br><img src="/img/base/base001_17.png" alt=""><br></center>

<p><br>　　范例2：元字符“\d”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于“\”在Java中有语法意义，因此需要将“\d”写成“\\d”。</span></span><br><span class="line">        <span class="comment">// 元字符“\\d”只用来匹配一位数字。</span></span><br><span class="line">        String regexExpress = <span class="string">"\\d"</span>; </span><br><span class="line">        String str1 =<span class="string">"1"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str2 =<span class="string">"a"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str3 =<span class="string">"我"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str4 =<span class="string">"123"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str3.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str4.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元字符“\\D”只用来匹配一位数字。</span></span><br><span class="line">        <span class="comment">// 另外对于“\s、\S、\w、\W”都是一样的用法。</span></span><br><span class="line">        regexExpress = <span class="string">"\\D"</span>;</span><br><span class="line">        str1 =<span class="string">"1"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        str2 =<span class="string">"a"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        str3 =<span class="string">"我"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        str4 =<span class="string">"a23"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str3.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str4.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　但是，若是只会使用这些预定义的字符类，则可能会遇到一些麻烦。比如：<br><br>　　范例2：匹配5个数字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若是要匹配100个数字呢? 就目前的情况来看，咱们只有去乖乖的写上100个“\\d”。</span></span><br><span class="line">        String regexExpress = <span class="string">"\\d\\d\\d\\d\\d"</span>; </span><br><span class="line">        String str1 =<span class="string">"1234"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str2 =<span class="string">"43254"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　Greedy数量词用来指定其所修饰的正则表达式所要连续出现的次数。</p>
<center><br><img src="/img/base/base001_18.png" alt=""><br></center>

<p><br>　　范例3：判断一个字符串是否由数字组成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在正则式的后面直接加上一个Greedy数量词即可。</span></span><br><span class="line">        String regexExpress = <span class="string">"\\d+"</span>;</span><br><span class="line">        String str1 =<span class="string">"1234"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str2 =<span class="string">"43254"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有长度x的满足：3&lt;= x &lt;=4的，并且在其内只包含有字母、数字、下划线的字符串，都将被匹配。</span></span><br><span class="line">        <span class="comment">// 相应的“\\w&#123;3,&#125;”只需要满足长度&gt;=3且其内只包含有字母、数字、下划线即可。</span></span><br><span class="line">        regexExpress = <span class="string">"\\w&#123;3,4&#125;"</span>;</span><br><span class="line">        str1 =<span class="string">"1234"</span>;</span><br><span class="line">        str2 =<span class="string">"abc"</span>;</span><br><span class="line">        String str3 =<span class="string">"a2_d"</span>;</span><br><span class="line">        String str4 =<span class="string">"abcde"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str3.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str4.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：匹配汉字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用“.”表示任何字符，但是只表示一位任何字符，强调字符类型。</span></span><br><span class="line">        <span class="comment">// 使用“*”表示任意多个字符，强调字符数量。</span></span><br><span class="line">        <span class="comment">// 使用“.*”表示任意多位任意字符。</span></span><br><span class="line">        String str = <span class="string">"cxy紫zy"</span>;</span><br><span class="line">        String pattern = <span class="string">".*紫.*"</span>    ;</span><br><span class="line">        System.out.println(str.matches(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　若是需要枚举出多个字符，则可以使用字符类的元字符。</p>
<pre><code>[]  若待匹配字符 是中括号里列出的任意一个字符，则返回true。
[^] 若待匹配字符 不是中括号里列出的任意一个字符，则返回true。

若需要指定一个范围(集合)，则可以使用“开始字符-结束字符”来表示。
</code></pre><p>　　依据上面的元字符，我们可以写出如下正则式：</p>
<pre><code>[a-z0-9A-Z] 若待匹配字符是a~z、A~Z、0~9之间则返回true。
[a-d[m-p]]  若待匹配字符是a~d或者m-p之间则返回true。即此处将“[m-p]”视为一个子集合，即并集。
[a-z&amp;&amp;[def]]  若待匹配字符是d、e、f则返回true，即取集合“a-z”与集合“def”的交集。
[a-z&amp;&amp;[^bc]]  若待匹配字符是a~z之间且不是b、c则返回true。
              此正则等价于：[ad-z]，即由a和d-z组成的集合。即差集。
[a-z&amp;&amp;[^m-p]] 若待匹配字符是a~l或q~z之间则返回true。
</code></pre><p><br>　　范例5：“[]”元字符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 只要待匹配串中的字符是“[]”中列出的任意一个，则视为匹配成功。</span></span><br><span class="line">        <span class="comment">// 字符类的元字符，同样是只会匹配一位。</span></span><br><span class="line">        String regexExpress = <span class="string">"[abcd123]"</span>;    </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 相应的也可以加上Greedy数量词：“[abcd123]+”。</span></span><br><span class="line">        <span class="comment">// 含义为：待匹配串的长度&gt;=1的且待匹配串内的每个字符都必须是已在“[]”中列出来的。</span></span><br><span class="line"></span><br><span class="line">        String str1 =<span class="string">"123"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str2 =<span class="string">"a"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str3 =<span class="string">"2"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str4 =<span class="string">"我"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str3.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str4.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制只能由数字、下划线、字符组成，且第一位不能是数字，且总长度必须在6~16位之间。</span></span><br><span class="line">String regexExpress = <span class="string">"[a-z_A-Z]\\w&#123;5,15&#125;"</span>;</span><br><span class="line"><span class="comment">// 在“[]”中可以指定一个字符范围，范围的起止字符之间使用“-”符号即可，如[0-9]。</span></span><br><span class="line"><span class="comment">// 值得注意的是，只有在“[]”的内部，连字符“-”才被视作位元字符，否则它就只能匹配普通的连字符号。</span></span><br><span class="line"><span class="comment">// 其实即使在“[]”内部，“-”也不一定就是元字符，若在连字符两端只有一端有字符（如：“[-ab]”）或者两端都没有（如：“[-]”），则它表示的就只是一个普通的字符，而不是一个范围，而且顺序也不可以乱，如“[z-a]”是错误的。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的道理，问号和点号通常被当作元字符处理，但是在字符组中则不是如此。</span></span><br><span class="line"><span class="comment">// 如：“[.+?]”可以匹配成功下面的字符串。</span></span><br><span class="line">String str =<span class="string">"."</span>；</span><br></pre></td></tr></table></figure></p>
<p><br>　　若是想匹配元字符本身的话，比如“.”或者“*”，那么就得使用“\”来取消这些字符的特殊意义。也就是说应该使用“\.” 和“\*”，当然要查找“\”本身，你也得用“\\”。</p>
<p><br>　　范例6：字符转义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String regexExpress = <span class="string">"\\\\"</span>;        <span class="comment">// 正则式。</span></span><br><span class="line">        String str1 =<span class="string">"\\\\"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str2 =<span class="string">"\\"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例7：或运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式支持“或”运算。</span></span><br><span class="line"><span class="comment">// 与“[]”类似，或运算也是提供几种规则，如果满足其中任意一种规则都视为匹配成功，具体方法是用“|”把不同的规则分隔开。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用或运算时，要注意各个条件的顺序。因为匹配时，将会从左到右地测试每个条件，如果满足了某个条件的话，就不会去再管其它的条件了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regexExpress = <span class="string">"abc|1234|ak47"</span>;       <span class="comment">// 正则式。</span></span><br><span class="line">        String str1 =<span class="string">"abc"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str2 =<span class="string">"1234"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str3 =<span class="string">"ak47"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        String str4 =<span class="string">"asdfghjkl"</span>;<span class="comment">// 匹配串。</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str3.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str4.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p><br>　　在正则表达式中，组本质上也是一个正则式，它是由一个或多个基本正则表达式组合在一起形成的一个大的正则式。</p>
<p><br>　　范例1：捕获组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 以字符“a”开头，中间出现1~n个数字，并以“abc”结尾。</span></span><br><span class="line">        String regexExpress = <span class="string">"a\\d+abc"</span>;</span><br><span class="line">        String str1 = <span class="string">"a2abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"a3ab"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress)); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用“()”来将一段正则式括起来后，这段正则式就可以被称为一个组了。</span></span><br><span class="line">        <span class="comment">// 在正则式中，组有捕获组和非捕获组之分，下面定义了3个捕获组。</span></span><br><span class="line">        <span class="comment">// 捕获组并不会影响正则式的匹配，其作用和上面的正则式一样。</span></span><br><span class="line">        <span class="comment">// 捕获组的作用是将正则式匹配到的内容保存到组里，供以后使用。</span></span><br><span class="line">        regexExpress = <span class="string">"(a)(\\d)+(abc)"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正则式中的每个捕获组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推，分组0对应整个正则表达式。</span></span><br><span class="line">        <span class="comment">// 通过“\组号”可以引用捕获组捕获到的内容，这种引用方式被称为“反向引用”。</span></span><br><span class="line">        <span class="comment">// 下面的“\\1”就是引用“(a)”捕获到的内容。</span></span><br><span class="line">        regexExpress = <span class="string">"(a)(\\d)+\\1"</span>;</span><br><span class="line">        str2 = <span class="string">"a322a"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关于反向引用（也称为后向引用）有两个点需要知道：</span></span><br><span class="line">    <span class="comment">// 后向引用不能用于它自身，比如“([abc]\\1)”是错误的；因此你不能将“\\0”用于一个正则表达式匹配本身，它只能用于替换操作中。</span></span><br><span class="line">    <span class="comment">// 后向引用不能用于字符集内部，比如“(a)[\\1b]”中的“\\1”并不表示后向引用，在字符集内部“\\1”可以被解释为八进制形式的转码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：命名捕获组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当正则表达式比较复杂的时候，里面含有大量的捕获组和非捕获组。</span></span><br><span class="line">    <span class="comment">// 通过从左至右数括号来得知捕获组的组号也是一件很烦人的事情，</span></span><br><span class="line">    <span class="comment">// 而且这样做代码的可读性也不好，当正则表达式需要修改的时候也会改变里面捕获组的组号。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在正则式的前面，使用“?&lt;组名&gt;”的语法来给组命名</span></span><br><span class="line">        <span class="comment">// 使用“\\k&lt;组名&gt;”的方式引用组。</span></span><br><span class="line">        String regexExpress = <span class="string">"(?&lt;group1&gt;a)(\\d)+\\k&lt;group1&gt;"</span>;</span><br><span class="line">        String str1 = <span class="string">"a2abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"a322a"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：中c国</span></span><br><span class="line">        str2 = <span class="string">"中a322a国"</span>;</span><br><span class="line">        System.out.println(str2.replaceAll(regexExpress,<span class="string">"c"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：捕获组特殊用法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在本范例中，量词“&#123;3&#125;”用在了“good”上，若是去掉“()”，则将会用在“d”上。</span></span><br><span class="line">        <span class="comment">// 假设有正则式：“4th|4”，则可以化简为“4(th)?”。 </span></span><br><span class="line">        <span class="comment">// 即括号内的表达式可以任意复杂，但是“从括号外来看”它们是个整体。</span></span><br><span class="line">        String regexExpress = <span class="string">"(good)&#123;3&#125;"</span>;</span><br><span class="line">        String str1 =<span class="string">"goodgoodgood"</span>;</span><br><span class="line">        String str2 =<span class="string">"gooddd&gt;"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配邮箱</span></span><br><span class="line">        <span class="comment">// 使用“()”可以限制“|”的作用范围。</span></span><br><span class="line">        String regexExpress = <span class="string">"\\w+@[a-zA-Z]+\\.(com|com.cn|net|edu|gov|org)"</span>; </span><br><span class="line">        String str1 =<span class="string">"123d@qq.com"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：非捕获组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式引擎会把匹配到的结果保存到一个捕获组里。</span></span><br><span class="line"><span class="comment">// 而有时候我们只是想用“()”进行分组操作，并不需要保存这部分内容的。</span></span><br><span class="line"><span class="comment">// 这就带来一定的副作用，浪费了系统资源，降低了效率。</span></span><br><span class="line"><span class="comment">// 此时就可以使用非捕获组。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用“(?:)”来定义一个非捕获组。 </span></span><br><span class="line">        <span class="comment">// 由于非捕获组不会捕获内容，也不会拥有组号，因此第一个正则表达式会失配。</span></span><br><span class="line">        String regexExpress = <span class="string">"(?:\\d&#123;1&#125;)\\1"</span>;       <span class="comment">// 正则式。</span></span><br><span class="line">        String regexExpress2 = <span class="string">"(\\d&#123;1&#125;)\\1"</span>;        <span class="comment">// 正则式。</span></span><br><span class="line">        String str1 =<span class="string">"22"</span>;</span><br><span class="line">        System.out.println(str1.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str1.matches(regexExpress2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从执行结果可以看出，虽然“(?:\\d&#123;2&#125;)”左右两侧都有捕获组，但仍然没有被分配组号。</span></span><br><span class="line">        regexExpress = <span class="string">"(\\d&#123;1&#125;)(?:\\d&#123;2&#125;)(\\w&#123;1&#125;)\\2"</span>;</span><br><span class="line">        System.out.println(<span class="string">"123aa"</span>.matches(regexExpress));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">"123ab"</span>.matches(regexExpress));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>　　在正式介绍零宽断言之前，先说说“缝隙”的概念：</p>
<pre><code>“缝隙”是零宽度的，它只是字符串中的一个位置，而不是实际的字符。
</code></pre><p>　　比如在字符串“ab”中就存在有三个“缝隙”，如下图所示：</p>
<center><br><img src="/img/base/base001_19.png" alt=""><br></center>

<pre><code>字符“a”前面，“a”和“b”中间以及“b”后面，分别有一个“缝隙”。
</code></pre><p>　　在正则表达式中，零宽断言用于匹配缝隙，这个缝隙应该满足一定的条件(即满足断言)，只有当断言为真时才会继续进行匹配。使用零宽断言匹配到某个(或某些个)缝隙后，我们就可以在该缝隙上插入若干个字符，从而达到通过正则表达式来修改字符串的目的。</p>
<p>　　零宽断言又分两类共四种，它们都属于非捕获组：</p>
<blockquote>
<p>lookahead：零宽度正预测先行断言、零宽度负预测先行断言。<br>lookbehind：零宽度正回顾后发断言、零宽度负回顾后发断言。</p>
</blockquote>
<p><br>　　范例1：零宽度正预测先行断言。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用符号“(?=断言表达式)”来定义零宽度正预测先行断言。</span></span><br><span class="line"><span class="comment">// 主要查看缝隙的右侧。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在字符串“cooking singing”中总共有16个缝隙。</span></span><br><span class="line">        <span class="comment">// 匹配时依次查看每个缝隙，看哪个缝隙的“右侧”是ing，则该缝隙将被匹配成功。</span></span><br><span class="line">        String str1 =<span class="string">"cooking singing"</span>;</span><br><span class="line">        String regexExpress = <span class="string">"(?=ing)"</span>;</span><br><span class="line">        <span class="comment">// 本范例中“k和i”、“s和i”、“g和i”之间的缝隙将被匹配。 </span></span><br><span class="line">        <span class="comment">// 输出：cookCing sCingCing</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress,<span class="string">"C"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 零宽断言属于预匹配，它的匹配操作是在其他所有字符匹配之前进行的。</span></span><br><span class="line">        <span class="comment">// 下面代码的匹配的过程：</span></span><br><span class="line">        <span class="comment">// 1、先是对“(?=ing)”进行匹配，并得到3个缝隙。</span></span><br><span class="line">        <span class="comment">// 2、在3个缝隙的基础上，查看哪个缝隙的左边还有一个字符“g”。 </span></span><br><span class="line">        regexExpress = <span class="string">"g(?=ing)"</span>;</span><br><span class="line">        str1 =<span class="string">"cooking singing"</span>;</span><br><span class="line">        <span class="comment">//输出：cooking sinCing</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress,<span class="string">"C"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：零宽度负预测先行断言。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用符号“(?!断言表达式)”来定义零宽度负预测先行断言。</span></span><br><span class="line"><span class="comment">// 与零宽度正预测先行断言对应，“零宽度负预测先行断言”取断言表达式的反值。</span></span><br><span class="line"><span class="comment">// 即如果断言表达式不成立，则匹配这个位置；如果断言表达式成立，则不匹配。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regexExpress = <span class="string">"(?!\\d)"</span>;</span><br><span class="line">        String str1 =<span class="string">"1234d5678a"</span>;</span><br><span class="line">        <span class="comment">//输出：1234Cd5678CaC</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress,<span class="string">"C"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：零宽度正回顾后发断言。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用符号“(?&lt;=断言表达式)”来定义零宽度正回顾后发断言。</span></span><br><span class="line"><span class="comment">// 如果断言表达式成立，则匹配这个位置；如果断言表达式不成立，则不匹配。</span></span><br><span class="line"><span class="comment">// 主要查看缝隙的左侧。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匹配的过程：</span></span><br><span class="line">        <span class="comment">// 依次查看字符串“abcdefgabc”的每个缝隙，看哪个缝隙的左侧是abc。</span></span><br><span class="line">        <span class="comment">// 下面的代码中，“c和d”之间的缝隙 以及“最后一个c后面”的缝隙将被匹配。</span></span><br><span class="line">        String regexExpress = <span class="string">"(?&lt;=abc)"</span>;</span><br><span class="line">        String str1 =<span class="string">"abcdefgabc"</span>;</span><br><span class="line">        <span class="comment">//输出：abcCdefgabcC</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress,<span class="string">"C"</span>));</span><br><span class="line">        <span class="comment">// 若正则式为“abc(?&lt;=abc)d”则本范例将输出“Cefgabc”。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：零宽度负回顾后发断言。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用符号“(?&lt;!断言表达式)”来定义零宽度负回顾后发断言。</span></span><br><span class="line"><span class="comment">// 与零宽度正回顾后发断言对应，即如果断言表达式不成立，则匹配这个位置，成立则不匹配。</span></span><br><span class="line"><span class="comment">// 主要查看缝隙的左侧。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哪一个缝隙的左侧不是数字</span></span><br><span class="line">        String regexExpress = <span class="string">"(?&lt;!\\d)"</span>;</span><br><span class="line">        String str1 =<span class="string">"1234d5678a"</span>;</span><br><span class="line">        <span class="comment">//输出：C1234dC5678aC</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress,<span class="string">"C"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：混合运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regexExpress = <span class="string">"(?=\\d)(?&lt;!\\d)"</span>; </span><br><span class="line">        <span class="comment">// 下面的字符串中总共有20个缝隙。</span></span><br><span class="line">        <span class="comment">// 执行“(?=\\d)”匹配后，还剩下9个符合要求的缝隙。</span></span><br><span class="line">        <span class="comment">// 接着执行“(?&lt;!\\d)”匹配后，还剩下4个符合要求的缝隙。</span></span><br><span class="line">        String str1 =<span class="string">"斯蒂芬3341是分123是否3斯蒂芬3"</span>;</span><br><span class="line">        <span class="comment">// 程序输出：斯蒂芬A3341是分A123是否A3斯蒂芬A3</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress,<span class="string">"A"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="贪婪和懒惰"><a href="#贪婪和懒惰" class="headerlink" title="贪婪和懒惰"></a>贪婪和懒惰</h3><p><br>　　范例1：贪婪与懒惰。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当正则式中包含能接受重复的限定符(如Greedy数量词)时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</span></span><br><span class="line">        <span class="comment">// 下面的正则式将会匹配最长的“以a开始，以b结束”的字符串。</span></span><br><span class="line">        String regexExpress = <span class="string">"a.*b"</span>;</span><br><span class="line">        String str1 =<span class="string">"aabab"</span>;</span><br><span class="line">        <span class="comment">// 输出：W。</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress, <span class="string">"W"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。</span></span><br><span class="line">        <span class="comment">// 前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号“?”。</span></span><br><span class="line">        <span class="comment">// 下面的正则式将会匹配最短的“以a开始，以b结束”的字符串。</span></span><br><span class="line">        <span class="comment">// “a.*?b”会匹配aab（第1~3个字符）和ab（第4~5个字符）。</span></span><br><span class="line">        regexExpress = <span class="string">"a.*?b"</span>;</span><br><span class="line">        str1 =<span class="string">"aabab"</span>;</span><br><span class="line">        <span class="comment">// 输出：WW。</span></span><br><span class="line">        System.out.println(str1.replaceAll(regexExpress, <span class="string">"W"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><br>　　<strong>程序</strong><br>　　程序是一段静态代码，它不占内存空间，不受操作系统调度，不能作为独立的运行单元，也不占用系统的运行资源，只占硬盘空间。</p>
<p><br>　　<strong>进程</strong><br>　　进程是程序的一次执行，程序本身只是一块死代码、指令的集合，程序需要被加载到内存中后，才可以执行，而程序被加载入内存，OS就会为其启动一个进程。</p>
<p><br>　　<strong>线程</strong><br>　　在进程的创建、撤销、切换中，系统必须为之付出较大的时间开销。<br>　　因此在系统中设置的进程数目不能过多，进程切换的频率不宜太高，这就限制了并发程度的提高。因此在现代操作系统中，引入了线程。此时进程仅仅是OS进行资源分配的基本单位，调度的基本单位变为了线程。</p>
<blockquote>
<p>线程是程序运行的基本单元，线程隶属于进程。<br>一个进程中可以有多个线程，当一个进程消失了，那么进程中的所有线程都将死亡。<br>一个线程死亡了，进程却可能仍在运行着，线程不是程序，不能独立运行。</p>
</blockquote>
<p><br>　　<strong>并发</strong><br>　　线程的并发执性是指：多个线程轮流执行。由于线程间切换的速度非常快，所以感觉像是同时执行。但并发线程的数量不是越多越好，线程多不但不会提高程序效率，反而会增加CPU在多个线程间切换的时间，这就是一种很大的浪费。 </p>
<blockquote>
<p>因此迅雷在下载时，最多同时也就能有4~5个任务在执行，其他任务只有等待的份了。</p>
</blockquote>
<p><br>　　<strong>并行</strong><br>　　线程的并行执行是指：只有在计算机有多个CPU(或一个CPU有多个核心)时 线程间才可能真正的同时执行。</p>
<blockquote>
<p>当程序中有多条执行路径并发执行时，就称为多线程。<br>所有的线程共享进程最初从内存中申请的空间。 当新建一个线程时，是在进程所占的内存内为其分配空间，而不是在内存中的其他地方,重新为其申请资源。</p>
</blockquote>
<p><br>　　<strong>时间片轮转</strong><br>　　OS在执行进程的时候，会不断的为每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。 在进程中的多个线程同样采用时间片轮转。</p>
<blockquote>
<p>每个线程根据优先级来决定谁先占有CPU。</p>
</blockquote>
<p><br>　　<strong>Java主线程</strong><br>　　当一个Java程序启动时，JVM会创建主线程，并在该线程中调用程序的main方法。</p>
<blockquote>
<p>主线程是程序最早执行的线程，程序中所有的线程都是由主线程创建的。<br>程序启动时JVM同时还创建了其他线程，如垃圾收集的线程（gc线程）等。<br>Java中多线程实行抢占式工作方式，若当前就绪的线程中有优先级高于正在执行的线程，则CPU会放弃当前线程的执行，而去执行优先级高的线程，即使当前线程是主线程也不例外。</p>
</blockquote>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p><br>　　在Java中有两种方式可以实现多线程，但是不论使用哪种方式都需要用到<code>Thread</code>类。</p>
<blockquote>
<p>第一种，直接继承Thread类，然后重写run()方法。<br>第二种，实现Runnable接口并重写run()方法，然后将此类的对象放到Thread类对象中。</p>
</blockquote>
<p><br>　　范例1：Thread类实现线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Java中一个Thread类(或其子类)的对象就代表一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程所要做的事情需要在run方法里，这个run方法继承自Thread类。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name+<span class="string">": i="</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread n1 = <span class="keyword">new</span> MyThread(<span class="string">"张三"</span>);</span><br><span class="line">        MyThread n2 = <span class="keyword">new</span> MyThread(<span class="string">"李四"</span>);</span><br><span class="line">        <span class="comment">// 启动线程需要调用Thread类的start()方法，这个方法负责建立线程。</span></span><br><span class="line">        <span class="comment">// 如果线程建立成功，则自动转调用run()方法。</span></span><br><span class="line">        <span class="comment">// 在start()方法中除了会转调用run()方法外，还会进行一些其它操作。</span></span><br><span class="line">        <span class="comment">// 比如调用操作系统（windows、macOS等）的建立线程函数CreateThread。</span></span><br><span class="line">        <span class="comment">// 因此若人为的调用run()方法则并不是启动线程，而仅仅是方法调用。</span></span><br><span class="line">        n1.start();</span><br><span class="line">        n2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：Runnable接口实现线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然实现了Runnable接口，但是最终还是要将MyThread对象放到Thread类的构造方法。</span></span><br><span class="line"><span class="comment">// 因为必须要调用Thread类的start()方法才能启动线程。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Runnable接口本身并没有任何对线程的支持，它仅提供了线程运行所需要的run方法。</span></span><br><span class="line">    <span class="comment">// 也就是说，Runnable接口不止可以用在线程上。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable n = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">// Thread类本身也实现了Runnable接口。</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(n);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(n);</span><br><span class="line">        <span class="comment">// 启动线程时，会调用MyRunnable的run方法。</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：Thread类的常用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Thread类的静态方法currentThread()方法可以得到当前线程的引用。</span></span><br><span class="line">        <span class="comment">// 打印一个线程对象的时候默认输出的格式：Thread[线程名,线程优先级,所在线程组]</span></span><br><span class="line">        <span class="comment">// 如打印主线程时输出：Thread[main,5,main]</span></span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java中每个线程都是有自己的名字的，若不手工指定，则JVM会自动分配一个唯一的名字。</span></span><br><span class="line">        <span class="comment">// 在构造Thread对象的同时可以通过Thread类的构造方法来设置线程的名称。</span></span><br><span class="line">        <span class="comment">// 也可以使用Thread类的getName()和setName()获得和修改名称。</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">": 我进入了run()，开始睡眠20秒"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 使用Thread类的静态方法sleep()可以使当前线程睡眠指定的时间。</span></span><br><span class="line">                    <span class="comment">// sleep方法的参数以毫秒为单位。</span></span><br><span class="line">                    <span class="comment">// 线程进入睡眠后，CPU会被其他线程占有。</span></span><br><span class="line">                    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 当前线程睡眠被打断的时候会抛出 InterruptedException异常。</span></span><br><span class="line">                    System.out.println(name + <span class="string">": 我的睡眠被打断了，我很生气!"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name + <span class="string">": 我自然睡醒了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"印度阿三"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">": 3秒后我会对你说一句话！"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">// 手动唤醒线程的睡眠</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"请起床！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：Thread的优先级。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":  "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyThread  bug1= <span class="keyword">new</span> MyThread(<span class="string">"虫子1号"</span>);</span><br><span class="line">        MyThread  bug2= <span class="keyword">new</span> MyThread(<span class="string">"虫子2号"</span>);</span><br><span class="line">        <span class="comment">// 在Java中线程的优先级被分为1~10级，也可用三个全局常量表示。</span></span><br><span class="line">        <span class="comment">// public static final int MAX_PRIORITY     最高优先级 ： 10级</span></span><br><span class="line">        <span class="comment">// public static final int MIN_PRIORITY     最低优先级 ： 1级</span></span><br><span class="line">        <span class="comment">// public static final int NORM_PRIORITY    标准优先级 ： 5级</span></span><br><span class="line">        <span class="comment">// 通过setPriority()和getPriority()方法来设置和访问线程的优先级。</span></span><br><span class="line">        <span class="comment">// 操作系统会先执行优先级高的线程，下面虽然“虫子2号”是后启动的，但是它总是先执行的。</span></span><br><span class="line">        bug1.setPriority(<span class="number">1</span>);</span><br><span class="line">        bug2.setPriority(<span class="number">10</span>);</span><br><span class="line">        bug1.start();</span><br><span class="line">        bug2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程的优先级高度依赖于OS，当JVM依赖于宿主机平台的线程实现机制时。</span></span><br><span class="line"><span class="comment">// Java线程的优先级会被映射成宿主机平台上的优先级，如 Window NT/XP有7个优先级。</span></span><br><span class="line"><span class="comment">// 因此应该将线程的优先级看作是线程调度的参考因素，千万不要将程序构建为其功能的正确性依赖于线程的优先级，这是十分危险的。</span></span><br><span class="line"><span class="comment">// 但一般来说，当调度器决定挑选一个线程时，都会首先在优先级高的线程中选择。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java线程除了能向你保证每一个定义的线程都会被启动，每个启动的线程都会运行到完成，除了这些之外不会有任何保证。</span></span><br><span class="line"><span class="comment">// Java规范中不能百分百保证线程将按照它们调用start()的顺序开始执行。</span></span><br><span class="line"><span class="comment">// 一系列线程以某种顺序启动并不意味着它们将按照该顺序执行。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：强行连接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":  "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main方法中的当前线程就是指的  主线程。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyThread  bug1= <span class="keyword">new</span> MyThread(<span class="string">"虫子1号"</span>);</span><br><span class="line">        bug1.start();</span><br><span class="line">        <span class="comment">// join方法就是强行连接的意思，使当前线程等待调用此方法的线程死亡后才继续执行。</span></span><br><span class="line">        <span class="comment">// 当前线程是：主线程。</span></span><br><span class="line">        <span class="comment">// 调用join方法的线程：bug1线程。</span></span><br><span class="line">        <span class="comment">// 因此本范例中主线程总是等待bug1执行完run()方法死亡后才继续执行。</span></span><br><span class="line">        bug1.join();</span><br><span class="line">        System.out.println(<span class="string">"主线程执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例6：线程让步。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":  "</span>+i);</span><br><span class="line">            <span class="comment">// 使用Thread类的静态方法yield()进行让步操作。</span></span><br><span class="line">            <span class="comment">// yield()方法使当前线程放弃本次抢到的CPU，回到就绪状态，从而使其他线程可以运行。</span></span><br><span class="line">            <span class="comment">// 但此方法同样没有任何保障，因为让步的线程可能再次被选中。</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　<strong>Java中线程有五个状态</strong><br><br>　　新建状态</p>
<pre><code>使用 Thread t = new Thread() 语句建立一个线程对象，新线程就处于了新建状态。
此时它只是一个空的线程对象，若要执行它，还需要将这个线程在OS中进行登记并为它分配系统资源，这些工作由start()方法来完成。
</code></pre><p>　　就绪状态</p>
<pre><code>当一个线程调用start()方法后，它便进入了就绪状态。但是并不会马上执行，它们会被放到就绪队列中等待执行，何时执行取决于线程的优先级和就绪队列的当前状况。
</code></pre><p>　　执行状态</p>
<pre><code>线程被分配到CPU时间片，开始运行run()方法时，线程就处于正在执行状态。
</code></pre><p>　　阻塞状态</p>
<pre><code>因为一些原因导致线程需要“等待”，处于“等待”状态的线程就称为“阻塞”。
常见的造成阻塞的原因有：
|-  线程自己调用了sleep()方法进行睡眠。
|-  线程自己调用了wait()方法进行等待。
|-  线程等待用户输入或输出操作时同样会阻塞。
相应的解决方法有：
|-  等待睡眠时间结束或其他线程调用interrupt()方法将其唤醒。
|-  等待它等待的时间结束或其他线程调用notify()、notifyAll()将其唤醒。
|-  等待用户输入或输出结束。
</code></pre><p>　　死亡状态</p>
<pre><code>一个线程被创建后只能调用一次start()，当线程完成其run()方法时，该线程不再是一个可执行的线程，该线程的栈已解散，我们就认为该线程死去，一旦一个线程死去，它将永远无法被重新启动，造成线程死亡有如下三种情况：
|-  正常执行完run()方法。
|-  在run()方法中因为一个未捕获的异常终止了run()方法，而使线程猝死。
|-  使用stop()和destroy()终止线程。
</code></pre><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p><br>　　背景：我们使用private修饰对象的属性 以此来保证此属性只能被本类的方法使用，这个可以防止别人修改重要的变量。<br>　　问题：虽然外界不能访问本类的私有变量了，但是本类中的所有方法都能访问到这些变量，那这意味着在多线程的环境中，同一个类内的方法，在同一时间有2个以上的线程对一个变量进行操作，这样变量的值就可能产生错误了。</p>
<p><br>　　范例1：卖票。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> token = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(token&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"卖出一张票,还剩:"</span>+(--token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="comment">// 程序运行结束：</span></span><br><span class="line">        <span class="comment">// 卖出一张票,还剩:4</span></span><br><span class="line">        <span class="comment">// 卖出一张票,还剩:3</span></span><br><span class="line">        <span class="comment">// 卖出一张票,还剩:2</span></span><br><span class="line">        <span class="comment">// 卖出一张票,还剩:1</span></span><br><span class="line">        <span class="comment">// 卖出一张票,还剩:0</span></span><br><span class="line">        <span class="comment">// 卖出一张票,还剩:-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行的不是上面的结果 就多执行几遍程序。</span></span><br><span class="line">        <span class="comment">// 观察发现最后一次票的余数居然到达了负数，这就是不同步的原因。</span></span><br><span class="line">        <span class="comment">// 上面的程序中有2个线程在卖票，假设此时程序中还有最后一张票：</span></span><br><span class="line">        <span class="comment">// -  线程A从到if(token&gt;0)进行判断，结果token&gt;0则线程A继续向下走。</span></span><br><span class="line">        <span class="comment">// -  线程A执行到sleep方法 进行睡眠300毫秒。</span></span><br><span class="line">        <span class="comment">// -  此时线程B获得CPU同样走到if(token&gt;0)进行判断，此时A还在睡眠当中，虽然A通过了检测，已经具备了卖票的资格，但是还没有进行卖票，token还没有减1，结果线程B顺利通过检测，也继续向下走。</span></span><br><span class="line">        <span class="comment">// -  线程B执行到sleep方法，进行睡眠300毫秒。</span></span><br><span class="line">        <span class="comment">// -  线程A醒来后，卖一张票，此时最后一张票卖完。</span></span><br><span class="line">        <span class="comment">// -  线程B醒来后，又卖一张票，此时票数就到负数了。</span></span><br><span class="line">        <span class="comment">// 上面的程序线程A和线程B一共执行了100次循环，它们仅仅共享使用成员变量。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　解决问题的方法就是：进行线程同步。<br>　　所谓的线程同步就是说，设定一个程序块或者方法，此方法同一时间内只能有一个线程进入，其他线程必须等待那个线程从里面出来后，才能进去。<br>　　在Java中可以使用两种方式来实现线程的同步： 同步块和同步方法。</p>
<pre><code>同步块： 使用synchronized关键字修饰的代码块。
同步方法： 使用synchronized关键字修饰的方法。
</code></pre><p><br>　　线程是凌驾于对象之上的，如下图所示：</p>
<center><br><img src="/img/base/base001_20.png" alt=""><br></center>

<p>　　一个类可以有多个对象，一个对象中包含属性和方法，方法按照是否线程安全，则又可以分为普通方法和同步方法：</p>
<pre><code>一个对象内的所有同步方法组成一个小组，这组中的方法，同一时间只能有一个方法被线程访问，其他的同步方法此时会禁止其他线程访问，类似于咱们常见的单选按钮，在多个选项中，同一时刻，只能选择一个选项。
</code></pre><p>　　之所以说线程是凌驾于对象之上的，是因为一个线程可以得到多个对象的锁，但是在同一时间点上 一个线程只能拥有一个对象的“锁”，一个对象只有“一把锁”。</p>
<pre><code>所谓的得到对象的“锁” 说白就是：当一个线程进入到对象的某一个同步方法内时，这个线程就得到了这个对象的锁，当此线程从同步方法中出来的时候，就自动释放了锁。
其实就和咱们去厕所一样。当咱们进入到厕所里面的时候，咱们可以将门反锁上，当我们从厕所出来时，总不会把锁也带出来吧？ 因此当一个线程进入到一个对象的某一个同步方法中后，这个对象的其他同步方法将拒绝接受其他线程的访问请求，其他线程只能等待这个线程从同步方法中出来。
</code></pre><p>　　如果一个对象在同步方法中调用sleep方法进行睡眠，则它会带着锁一起睡眠，即便它睡眠的时候放弃了CPU，别的线程也因此而得到了CPU，但是别的线程因为没有锁，所以还是进不来。因此不要在同步方法中调用sleep()方法。同理，咱们在厕所里睡着了，门会一直被反锁着，别人根本就进不来，虽然他也买到了一张门票，总不可能在咱们睡着的时候，厕所上的锁自动打开吧。</p>
<p><br>　　范例1：同步代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> token = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 每一个对象都有一把“锁”，这把“锁”就是在线程同步时用到。</span></span><br><span class="line">            <span class="comment">// 只有抢到这把“锁”的线程才有资格进入到此对象的synchronized块或方法中。</span></span><br><span class="line">            <span class="comment">// 没有抢到这把“锁”的线程只能等待里面的线程释放锁后才可以继续抢夺“锁”。</span></span><br><span class="line">            <span class="comment">// 下面在同步块中调用了sleep方法，因此当前线程会带着“锁”一起睡眠。</span></span><br><span class="line">            <span class="comment">// synchronized(this)代表 线程只有抢到当前对象的“锁”后才可以进入到同步块中来。</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(token&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;               </span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" 卖出一张票,还剩:"</span> + (--token));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：同步方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> token = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            sal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 虽然使用线程同步可以保证数据的正确性，但是同样也降低了程序执行的效率。</span></span><br><span class="line">    <span class="comment">// 说白了假设此时有一个任务，如果不使用线程同步需要6秒就能完成。</span></span><br><span class="line">    <span class="comment">// 使用线程同步则可能需要8秒才完成，但是相应的安全性也提高了。</span></span><br><span class="line">    <span class="comment">// 同步的时候，static方法使用的是当前类的Class类对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(token&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"卖出一张票,还剩:"</span>+(--token));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p><br>　　关于死锁：说白了就是：You first,You first问题。<br>　　双方各自持有一个资源，再不想释放已有资源的情况下，还想要对方的资源，谁都不愿意先放手，导致最终相互等待。</p>
<pre><code>比如说：
抢劫犯要求： 你们先给我钱，我放人。
受害者家属要求： 你先放人，我们给你钱。
最终结果就是，相互僵持着。
</code></pre><p>　　注：在线程中，过多的同步就很容易导致死锁。</p>
<p><br>　　范例1：模拟死锁 —— 警察与绑匪。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑匪类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kidnapper</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trade t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Kidnapper</span><span class="params">(Trade t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"匪徒"</span>);</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() </span><br><span class="line">            + <span class="string">" 说：你们先拿钱来,然后我就放人!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.t.policeGiveMoney(); <span class="comment">// 向警察要钱。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 说：好吧,我放人!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//警察类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Police</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trade t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Police</span><span class="params">(Trade t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"警察"</span>);</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() </span><br><span class="line">            + <span class="string">" 说：你先放人,然后我们给你钱!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.t.kidnapperGiveMan(); <span class="comment">// 向匪徒要人。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 说：好吧,你被捕了!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交易类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> giveMoney = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> giveMan = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：用来描述匪徒向警察要钱的过程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">policeGiveMoney</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 警察先判断,当前线程(匪徒)是否已经放人。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.giveMan) &#123;</span><br><span class="line">            <span class="comment">// 若匪徒没有放人,则要求匪徒等待,等待其放人后,再给他钱。</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当匪徒放人后,警察给他钱。</span></span><br><span class="line">        <span class="keyword">this</span>.giveMoney = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 匪徒唤醒警察, 警察去领人。</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：用来描述警察向匪徒要人的过程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">kidnapperGiveMan</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 匪徒先判断,当前线程(警察)是否已经给钱。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.giveMoney) &#123;</span><br><span class="line">            <span class="comment">// 若警察没有给钱,则要求警察等待,等待其交钱后,再给他人。</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当警察交钱后,匪徒给他人。</span></span><br><span class="line">        <span class="keyword">this</span>.giveMan = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 警察唤醒匪徒,匪徒去取钱。</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trade t = <span class="keyword">new</span> Trade();</span><br><span class="line">        <span class="keyword">new</span> Kidnapper(t).start();</span><br><span class="line">        <span class="keyword">new</span> Police(t).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　为了方便的实现线程同步，才引入第三个类（用于的交易类Trade）。</p>
<h2 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h2><p><br>　　题目：现在有一个桌子，桌子上面最多能放5份菜。</p>
<pre><code>有一个厨师不断的向桌子里添加菜，当桌子满的时候就停止添加。
有一个食客不断的从桌子上拿菜吃，当桌子空的时候就歇会再吃。
</code></pre><p><br>　　范例1：生产者与消费者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 餐桌类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Desk</span><span class="params">(<span class="keyword">int</span> maxCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCount = maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 厨师线程会调用此方法，往餐桌上添加菜。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 如果桌子上菜满了，则厨师暂时等待</span></span><br><span class="line">        <span class="keyword">while</span>(count == maxCount) &#123;  </span><br><span class="line">            <span class="comment">// 每一个对象除了有一把锁以外 还具有一个等待区。</span></span><br><span class="line">            <span class="comment">// 所有在此对象上调用wait()方法的线程都会被放到这个等待区中去。</span></span><br><span class="line">            <span class="comment">// 进入到等待区的线程不会带着锁去等待。</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">             + <span class="string">" 添加了一盘菜  桌上此时还有:"</span>+<span class="keyword">this</span>.count+<span class="string">"盘菜"</span>);</span><br><span class="line">        <span class="comment">// 唤醒食客线程，开始拿菜</span></span><br><span class="line">        <span class="comment">// notify、notifyAll、wait方法是Object类的3个方法。</span></span><br><span class="line">        <span class="comment">// 它们只能在同步方法或同步块中使用。</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 食客线程会调用此方法，从桌子上拿菜。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 如果桌子上没有菜，则食客暂时等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;   </span><br><span class="line">            <span class="comment">// 若调用wait()方法的线程不拥有该对象的锁，则抛出异常。 </span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">            + <span class="string">" 吃了一盘菜  桌上此时还有:"</span>+<span class="keyword">this</span>.count+<span class="string">"盘菜"</span>);</span><br><span class="line">        <span class="comment">// 唤醒厨师线程，开始做菜</span></span><br><span class="line">        <span class="comment">// 当调用notifyAll时并不意味着当前线程这时会放弃其锁，在其离开同步块之前，不会放弃锁。</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 厨师类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Desk desk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Desk desk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desk = desk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 最多往桌子上添加20次菜。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                desk.put();</span><br><span class="line">                <span class="keyword">int</span> time = (<span class="keyword">int</span>)(Math.random()*<span class="number">1000</span>);</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 食客类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Desk desk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Desk desk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desk = desk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 最多从桌子上拿20次菜。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">                <span class="keyword">int</span> time = (<span class="keyword">int</span>)(Math.random()*<span class="number">1000</span>);</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Desk desk = <span class="keyword">new</span> Desk(<span class="number">5</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(desk),<span class="string">"厨师"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(desk),<span class="string">"食客"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　关于线程还有如下几个知识点：</p>
<pre><code>1、如果是普通对象直接使用new关键字建立对象，而不把这个对象赋值给一个引用变量，则垃圾回收器就会将其回收，然而每个线程对象总是将其登记到OS中，在其run()方法执行完毕之前，它不会被gc回收。同时，若是在某个对象的某个实例方法中开启了线程，则在线程执行完毕之前，该对象也不会被回收。
2、后台线程是在后台为别人提供服务的线程，但当所有非后台线程结束时，即使后台线程还没有结束，程序也将终止，Main线程是非后台线程，gc是一个后台线程。
3、后台线程的子线程自动为后台线程，所谓的子线程就是在当前线程执行时创建的线程，子线程会继承父线程的优先级，而Main线程的优先级是5，因此Java中所有在main方法开始之后建立的线程，默认都是5级优先级。
4、如果线程获得一个对象的锁，之后试图调用同一个对象上的其他同步方法，则完全没有问题。
5、如果一个对象的等待区中有多个线程在等待，则调用notify()方法只会唤醒一个线程，但是不保证以何种顺序选择，如果等待区中没有线程，则不执行任何特殊操作。
</code></pre><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p><br>　　Timer是一个定时器，使用它可以将某个任务设置在指定的时间上执行。</p>
<p>　　范例1：定时任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定时器对象。</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();  </span><br><span class="line">        <span class="comment">// 向定时器对象中安排一个定时器任务。</span></span><br><span class="line">        <span class="comment">// 在Timer类内部有一个任务队列(TaskQueue)，定时器会按照先进先出的原则，从队列中依次取出每个任务来执行。</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;  </span><br><span class="line">            <span class="comment">// 定时器中待执行的任务，使用TimerTask类来描述。</span></span><br><span class="line">            <span class="comment">// 当定时器执行某个TimerTask时，会调用其run()方法。</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Task Execute!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>); <span class="comment">//定时器会一秒后执行该定时器任务。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  TimerTask对象有四个状态：</span></span><br><span class="line">    <span class="comment">//  TimerTask.VIRGIN：新建状态。</span></span><br><span class="line">    <span class="comment">//  TimerTask.SCHEDULED：已安排(等待执行)状态。</span></span><br><span class="line">    <span class="comment">//  TimerTask.EXECUTED：已被执行状态。</span></span><br><span class="line">    <span class="comment">//  TimerTask.CANCELLED：已被撤销状态。</span></span><br><span class="line">    <span class="comment">//  TimerTask对象一旦被安排到某个Timer中后，它的状态将被置为SCHEDULED，</span></span><br><span class="line">    <span class="comment">//  不论其最终是否被成功执行，该TimerTask对象都将不能再次被安排到任何Timer对象中，</span></span><br><span class="line">    <span class="comment">//  因为它已经被识为死亡了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimerTask类有一个cancel()方法</span></span><br><span class="line"><span class="comment">// 假设现在有一个TimerTask对象A调用了cancel方法，那么之后的情况，如下所述：</span></span><br><span class="line"><span class="comment">// -  若A当前未被安排到任何Timer中，则其将无法被安排，因为Timer对象只接受状态为TimerTask.VIRGIN的TimerTask对象。</span></span><br><span class="line"><span class="comment">// -  若A已经被安排到某个Timer中，但未执行，则其将永远不会被执行，因为当Timer从任务队列将A取出时，会将A直接抛弃，然后继续执行下一个任务。</span></span><br><span class="line"><span class="comment">// -  若A正在被执行，则任务将会运行完，但永远不会再运行。</span></span><br></pre></td></tr></table></figure></p>
<p>　　另外，在Timer对象中除了包含一个任务队列外，还包含了一个线程对象(TimerThread)，该线程对象在Timer被实例化的同时被创建，它的工作就是不断的从任务队列中取出TimerTask，然后执行。当任务队列中暂时没有TimerTask时，则该线程对象将会调用wait()方法进入等待。当程序向Timer中安排新任务时，会同时唤醒该线程对象。</p>
<p>　　同时，在Timer类中也包含一个cancel()方法，用来终止当前计时器，丢弃所有当前已安排的任务，若当前Timer中存在正在执行的任务，则该任务会继续执行完毕。当Timer对象被终止时，TimerThread对象也会停止运行。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><br>　　假设现有一个功能模块，需要依次调用四个类：A、B、C、D，即调用完A类之后要接着调用B类，B后是C，C后是D。同时还有个变量n，在ABCD4个类中都会用到它，若是将变量n随着程序的执行流程从A类开始依次传递，最后转给D，则代码会很乱。若是这类变量有很多，则这种传递数据的方式就很繁琐。</p>
<p>　　比较好的解决的方案有如下两种：</p>
<pre><code>使用单例设计模式，将变量n封装起来，并处理线程同步。
使用ThreadLocal类来完成数据的传递。
</code></pre><p>　　通过ThreadLocal类，可以将一些变量存放到某个线程对象中，那么只要是这个线程能走到的地方(代码)，都可以从线程对象中获取变量的值。</p>
<p><br>　　范例1：保存数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设现在有2个Thread对象t1和t2，2个ThreadLocal对象l1和l2</span></span><br><span class="line">    <span class="comment">// t1可以往l1、l2中分别存储一个数据</span></span><br><span class="line">    <span class="comment">// l1可以为t1、t2各自存储一个数据</span></span><br><span class="line">    <span class="comment">// 也就是说，Thread和ThreadLocal是多对多的关系。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个线程。</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"张三"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 当前线程往threadLocal变量中设置自己的数据</span></span><br><span class="line">                threadLocal.set(<span class="string">"年龄：10"</span>);</span><br><span class="line">                A.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 第二个线程。</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"李四"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                threadLocal.set(<span class="string">"年龄：20"</span>);</span><br><span class="line">                A.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 程序输出：</span></span><br><span class="line">        <span class="comment">// 张三，年龄：10</span></span><br><span class="line">        <span class="comment">// 李四，年龄：20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> B b;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            b.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> C c;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            c.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() </span><br><span class="line">                + <span class="string">"，"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h2><p><br>　　由于应用程序中总是可能存在隐藏的bug，因而抛出的异常没被捕获也就是再所难免的了。当异常产生后，为了良好的用户体验、及时回收系统资源(如关闭数据库连接等) 以及程序bug的搜集，可以将异常信息上传到服务器端。但是通常情况下，未捕获的异常会被虚拟机接到，且其会第一时间终止程序，并打印出异常的堆栈轨迹。</p>
<p>　　UncaughtExceptionHandler是Thread类的内部接口，当任意线程中突然发生一个未捕获的异常时，会回调此接口内的方法，在JDK中默认就有一个该接口的实例，咱们可以替换掉该实例，然后当未捕获的异常产生时，咱们的实例中的方法就会被调用。</p>
<p><br>　　范例1：异常处理器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 自定义一个异常处理器。</span></span><br><span class="line">        Thread.UncaughtExceptionHandler excHandler </span><br><span class="line">                = <span class="keyword">new</span> UncaughtExceptionHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程发生异常："</span>+e.getMessage());</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 替换掉Thread类默认提供的实例。</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(excHandler);</span><br><span class="line">        <span class="comment">// 除数为0异常。</span></span><br><span class="line">        System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="JavaIO基础"><a href="#JavaIO基础" class="headerlink" title="JavaIO基础"></a>JavaIO基础</h1><p><br>　　Java中的IO操作可以分为：</p>
<pre><code>-  对文件本身的操作：使用File类完成。
-  对文件内容的操作：
    -  使用字节流、字符流、RandomAccessFile类完成。
    -  字节（0、1 组成的二进制码，8个二进制码组成一个字节）流：
        -  InputStream ： 字节输入流顶层抽象类
        -  OutputStream ：字节输出流顶层抽象类
    -  字符（字符数据，如字母、汉字）流：
        -  Reader ： 字符输入流顶层抽象类
        -  Writer ： 字符输出流顶层抽象类
    -  RandomAccessFile类：
        -  独立于字节流和字符流，自成一派，可以进行随机读写，此类中有一个文件指针的概念。
</code></pre><h2 id="IO常用类"><a href="#IO常用类" class="headerlink" title="IO常用类"></a>IO常用类</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p><br>　　File类是Object类的直接子类，在java.io包中。</p>
<p><br>　　范例1：初探File类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个文件对象，指向D:\a.txt。</span></span><br><span class="line">        <span class="comment">// 文件的分隔符应该使用File.separator它自动获取您当前操作系统的文件分隔符。</span></span><br><span class="line">        <span class="comment">// 在Linux和Unix中文件分隔符为”/”，而在windows中文件分隔符为”\”。</span></span><br><span class="line">        <span class="comment">// 但是Windows的分隔符在java中有语法含义，因此在windows内也支持使用”/”或者”\\”。</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面file对象只是指向了a.txt文件，但并不去检查这个文件是否存在，更别说创建了。</span></span><br><span class="line">        <span class="comment">// 只有在使用file对象调用方法时，才会去判断它所指向的文件是否存在。</span></span><br><span class="line">        <span class="comment">// File对象既可以指向一个文件也可以指向一个文件夹。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　关于文件的扩展名：</p>
<pre><code>在Windows中文件的后缀名只是为了打开文件更方便，除此之外别无其他作用。使用了后缀可以为该文件指定一个默认打开它的一个程序，如果一个文件没有后缀名或者使用的是操作系统未知的后缀名，则双击该文件的时候，Windows会要求你选择一个打开此文件的应用程序。说白了你可以将一个mp3格式的文件的后缀改成txt格式，只要你不在记事本中改变其中的内容，那么你把它再改回.mp3格式的文件，照听不误。
因此文件的后缀名可以任意修改，且文件的内容不会随着后缀名的改变而改变，也就是说不能通过改变文件的后缀来改变文件的类型。即一个.pdf的文件只能用pdf电子书阅读器来打开，即使你改变它的后缀为txt，然后试图使用记事本来打开他，看到的一定是乱码。
</code></pre><p><br>　　范例2：File类常用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="comment">// 判断当前文件对象所指向的文件或文件夹是否在硬盘上实际存在。</span></span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">            <span class="comment">// 删除文件</span></span><br><span class="line">            <span class="comment">// 若file指向的文件不存在，则不执行任何操作，删除成功则返回true。</span></span><br><span class="line">            <span class="comment">// 若使用此方法删除一个文件夹，则文件夹必须为空，否则无法删除。</span></span><br><span class="line">            file.delete();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取file对象的上一级File对象，即“D:/test”。</span></span><br><span class="line">            File parent = file.getParentFile();</span><br><span class="line">            <span class="comment">// 依据file对象的路径，创建沿途的各个文件夹，若已经存在则不创建。</span></span><br><span class="line">            parent.mkdirs();</span><br><span class="line">            <span class="comment">// 创建当前文件对象指向的文件，若文件存在，则不执行任何操作。</span></span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下方法，当且仅当当前文件对象指向的文件存在且满足特定条件时才返回true，否则返回false。</span></span><br><span class="line"><span class="comment">// canExecute()     ：是否可执行。</span></span><br><span class="line"><span class="comment">// canRead()        ：是否能读。</span></span><br><span class="line"><span class="comment">// canWrite()       ：是否能写。</span></span><br><span class="line"><span class="comment">// delete()         ：是否能删除。</span></span><br><span class="line"><span class="comment">// isDirectory()    ：是否是文件夹。</span></span><br><span class="line"><span class="comment">// isFile()         ：是否是文件。</span></span><br><span class="line"><span class="comment">// isHidden()       ：是否是隐藏文件。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：筛选文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator);</span><br><span class="line">        <span class="comment">// 以文件数组的形式返回当前文件夹内所有内容，列出File对象。</span></span><br><span class="line">        <span class="comment">// 只能对文件夹调用listFiles方法，若对文件调用，则会返回null。</span></span><br><span class="line">        File[] array = file.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// JVM负责为file下的所有文件调用一次accept方法。</span></span><br><span class="line">            <span class="comment">// 如果accept方法返回true则选中此文件并放到最终返回值数组中，否则则放弃此文件。</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(f.getName().endsWith(<span class="string">".txt"</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(File str : array)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p><br>　　RandomAccessFile可以对文件进行随机读写，一般用于文件断点续传（上传/下载）的场景下。</p>
<p><br>　　范例1：进行随机读写数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 当前Java项目的根目录下创建此文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="comment">// 打开文件的模式：</span></span><br><span class="line">        <span class="comment">// “r”   以只读方式打开。随后调用任何write方法都将导致抛出IOException。</span></span><br><span class="line">        <span class="comment">// “rw”  以读写的方式打开。如果该文件尚不存在，则尝试创建该文件。</span></span><br><span class="line">        <span class="comment">// “rws” 以读写的方式打开。如果该文件尚不存在，则尝试创建该文件。</span></span><br><span class="line">        <span class="comment">//       写入到此流内的数据或对文件的元数据进行的修改不会被放入缓冲区中，而会立刻被写入磁盘文件中。 </span></span><br><span class="line">        <span class="comment">// “rwd” 以读写的方式打开。如果该文件尚不存在，则尝试创建该文件。</span></span><br><span class="line">        <span class="comment">//       写入到此流内的数据不会被放入缓冲区中，而会立刻被写入磁盘文件中。 </span></span><br><span class="line">        RandomAccessFile r = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">// 使用writeXxx()可以写八种基本类型</span></span><br><span class="line">        <span class="comment">// 使用readXxx()可以读八种基本类型</span></span><br><span class="line">        r.writeChars(<span class="string">"张三"</span>);</span><br><span class="line">        r.writeInt(<span class="number">30</span>);</span><br><span class="line">        r.writeFloat(<span class="number">8000</span>);</span><br><span class="line">        r.writeChars(<span class="string">"李四"</span>);</span><br><span class="line">        r.writeInt(<span class="number">33</span>);</span><br><span class="line">        r.writeFloat(<span class="number">5200</span>);</span><br><span class="line">        r.writeChars(<span class="string">"王五"</span>);</span><br><span class="line">        r.writeInt(<span class="number">43</span>);</span><br><span class="line">        r.writeFloat(<span class="number">6200</span>);</span><br><span class="line">        <span class="comment">// 将文件指针移动到文件开头</span></span><br><span class="line">        r.seek(<span class="number">0</span>); </span><br><span class="line">        <span class="comment">// 从当前的文件指针所在文职，读取数据</span></span><br><span class="line">        System.out.println(<span class="string">"姓名: "</span> + readString(r, <span class="number">2</span>) + <span class="string">"; 年龄："</span> + r.readInt() + <span class="string">"; 工资："</span> + r.readFloat());</span><br><span class="line">        <span class="comment">// 跳过李四的信息。</span></span><br><span class="line">        r.skipBytes(<span class="number">12</span>); </span><br><span class="line">        System.out.println(<span class="string">"姓名: "</span> + readString(r, <span class="number">2</span>) + <span class="string">"; 年龄："</span> + r.readInt() + <span class="string">"; 工资："</span> + r.readFloat());</span><br><span class="line">        <span class="comment">// 用完后要关闭流</span></span><br><span class="line">        r.close(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RandomAccessFile类写字符串有三种方式：</span></span><br><span class="line">    <span class="comment">// 1、使用writeBytes()按字节序列将该字符串写入该文件。</span></span><br><span class="line">    <span class="comment">// -  该字符串中的每个字符均按顺序写出，并丢弃其高八位。</span></span><br><span class="line">    <span class="comment">// -  即写的字符串不能包含汉字，只能写(0-255的字符)。</span></span><br><span class="line">    <span class="comment">// -  如果写了汉字，则读取时，一定不能原样读回。 </span></span><br><span class="line">    <span class="comment">// 2、使用writeChars()按字符的形式将该字符串写入该文件，不会丢其字符的高八位。</span></span><br><span class="line">    <span class="comment">// -  它写的所有的字符(包括英文字母)都占2个字节，跳字节时要注意跳的是字符数*2。</span></span><br><span class="line">    <span class="comment">// -  所以使用此方式写字符串，最好不要写英文，浪费空间。</span></span><br><span class="line">    <span class="comment">// 3、使用writerUTF()按UTF-8编码方式写字符串，要和readUTF()方法配合使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总之使用RandomAccessFile类要坚持怎么写入，就怎么读取的方式。比如：</span></span><br><span class="line">    <span class="comment">// 使用writeBytes()写一个字符串，应该循环使用readByte();</span></span><br><span class="line">    <span class="comment">// 使用writeChars()写一个字符串，应该循环使用readChar();</span></span><br><span class="line">    <span class="comment">// 使用writeUTF()写一个字符串，应该使用readUTF()读入这个字符串。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">(RandomAccessFile r, <span class="keyword">int</span> count)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            array[i] = r.readChar();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　关于文件读写，有几个需要知道的事情：</p>
<pre><code>java.io.EOFException文件读到结尾异常，说白了就是当前所剩字节不够读的。
seek()方法访问底层的运行时系统因此往往是消耗巨大的。
RandomAccessFile类可以通过seek(file.length())跳到文件的最后，达到追加效果。
使用其他字节流输出流指向某个文件，即使没有写任何东西，也会清空文件的内容，使用RandomAccessFile类并不是将原内容清空，而是覆盖，写多少就覆盖多少，未覆盖的则保持不变，因此可以使用seek(file.length())进行追加。
RandomAccessFile类仅能操作文件，不能访问其他IO设备，如网络，内存映像等。
</code></pre><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p><br>　　关流的概念：</p>
<pre><code>程序中所有的数据传输都不是一次性的将所有数据送出去的，而是一点一点的传输，而计算机的速度又很快，所以读写数据的时候感觉上像是水一样流动一样，因此使用’流’来描述数据的传输。
数据从程序向磁盘写数据时，叫输出流.
数据从磁盘向程序读数据时，叫输入流.
</code></pre><p>　　流的分类：</p>
<pre><code>按数据方向分：输入流和输出流
-  输入流：InputStream / Reader
-  输出流：OutputStream / Writer
按数据类型分：字节流和字符流
-  字节流：InputStream / OutputStream
-  字符流：Reader / Writer
按流的功能分：节点流和装饰流(处理流)
-  节点流用来操作数据的来源。它是最基本的操作流。
-  装饰流用来封装节点流,从而给节点流增加一个功能,不能独立存在,在关闭流时如果使用了装饰流,只需关闭最外层的流就可以了。
</code></pre><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p><br>　　字节流的两个顶层抽象类InputStream和OutputStream，其下的流有：</p>
<pre><code>-  文件节点流：FileInputStream和FileOutpuStream。它们是最基本操作文件内容的流类，一般会在节点流外面加上一些装饰流，以增强节点流的功能。
装饰流：
-  字节缓冲流： BufferredInputStream 和 BufferedOutputStream
-  字节数据流： DataInputStream 和 DataOutputStream
</code></pre><p><br>　　范例1：从文件中读写数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件流打开文件时：</span></span><br><span class="line">        <span class="comment">// 若文件不存在，则建立这个文件.</span></span><br><span class="line">        <span class="comment">// 若文件存在，则删除其内的内容后，再写上新内容。</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">        FileOutputStream out  = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        <span class="comment">// 字符串的getBytes()方法，可以将字符串转成一个字节数组。</span></span><br><span class="line">        out.write(<span class="string">"张三"</span>.getBytes());</span><br><span class="line">        out.write(<span class="number">30</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果InputStream指向的文件不存在，则会抛FileNotFoundException异常。</span></span><br><span class="line">    <span class="comment">// windows中使用\r\n换行，java中使用\n换行，因此向记事本中写数据的时候，如果想在记事本中换行，则需要写一个“\r\n”字符串。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">        FileInputStream in  = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 每次读取一个字节</span></span><br><span class="line">            array[i]=(<span class="keyword">byte</span>)in.read();            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(array));</span><br><span class="line">        System.out.println(in.read());</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：文件复制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">// 缓冲流是一个装饰流，在节点流的基础上添加了一个缓冲区，缓冲区的作用就是 提高流读写的速度。 </span></span><br><span class="line"><span class="comment">// 直接用文件流读写文件时，程序每读写一次都需要和外存交互一次，这样触发了大量的底层运行时系统调用是很耗时间的。 </span></span><br><span class="line"><span class="comment">// 加入缓冲区后，数据先被读写入缓冲区，缓冲区满了之后，才将进行一次内外存交互，交互的次数减少了，文件读写的速度自然也就快了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedInputStream in = </span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"jdk-6u6-windows-i586-p.exe"</span>)));</span><br><span class="line">        BufferedOutputStream out = </span><br><span class="line">            <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"F:"</span> + File.separator + <span class="string">"jdk-6u6-windows-i586-p.exe"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>((temp = in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"耗时："</span> +(end-start)+<span class="string">"毫秒  大约 "</span></span><br><span class="line">            +(end-start)/<span class="number">1000</span>+<span class="string">" 秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：数据流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件流只提供了最简单的读写数据的方法，当我们需要结构化的读写数据时，就比较麻烦。</span></span><br><span class="line"><span class="comment">// 于是JDK提供了一对结构化读写数据的接口，DataInput和DataOutput，并提供了若干子类。</span></span><br><span class="line"><span class="comment">// 所有实现这俩接口的类，都要遵守一个原则：按什么顺序写，就按什么顺序读。</span></span><br><span class="line"><span class="comment">// 这两个接口的实现类：</span></span><br><span class="line"><span class="comment">// -  DataInputSream和DataOutputStream</span></span><br><span class="line"><span class="comment">// -  ObjectInputStream和ObjectOutputStream</span></span><br><span class="line"><span class="comment">// -  RandomAccessFile</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    </span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">            <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:/a.txt"</span>)));</span><br><span class="line">        out.writeUTF(<span class="string">"Hello World\r\n大家好 我是程序员."</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:/a.txt"</span>)));</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：打印流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrintStream是一个字节流，既可以作为装饰流也可以作为节点流。</span></span><br><span class="line"><span class="comment">// 其有两个非常著名的实现对象：</span></span><br><span class="line"><span class="comment">// -  System.out 标准输出流，向屏幕输出数据。</span></span><br><span class="line"><span class="comment">// -  System.err 标准错误流，也会向屏幕输出数据</span></span><br><span class="line"><span class="comment">// 一般来说我们不直接实例化PrintStream类对象，而是直接使用System.out、System.err。</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        PrintStream p=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>));</span><br><span class="line">        p.print(<span class="string">'C'</span>);</span><br><span class="line">        p.print(<span class="number">123</span>);</span><br><span class="line">        p.println(<span class="string">"\r\nHello world"</span>);</span><br><span class="line">        p.printf(<span class="string">"\r\n%c,%d,%s"</span>, <span class="string">'A'</span>,<span class="number">97</span>,<span class="string">"Hello A!"</span>);</span><br><span class="line">        p.printf(<span class="string">"\r\n%s,%s,%s"</span>, <span class="string">'A'</span>,<span class="number">97</span>,<span class="string">"Hello A!"</span>); </span><br><span class="line">        p.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向标准输出流。</span></span><br><span class="line">    <span class="comment">// 此时"Hello World"将被输出到文件中。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PrintStream out=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>)));</span><br><span class="line">                System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">                System.setOut(out);</span><br><span class="line">                System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><br>　　字符流的两个顶层抽象类Reader和Writer，其下的流有：</p>
<pre><code>-  文件节点流：FileReader和FileWriter。它们是最基本操作文件内容的流类，一般会在节点流外面加上一些装饰流，以增强节点流的功能。
装饰流：
-  字节缓冲流： BufferedReader 和 BufferedWriter
</code></pre><p><br>　　范例1：从文件中读写数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// FileWriter 支持追加写。</span></span><br><span class="line">        FileWriter out = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>));</span><br><span class="line">        out.write(<span class="string">"世界,你好。\r\nHello World"</span>);</span><br><span class="line">        <span class="comment">// 虽然代码写的是97，但输出到文件中字符’a’。</span></span><br><span class="line">        <span class="comment">// 1个int数据占32位，本方法只能写入的低16位中，高16位被忽略。</span></span><br><span class="line">        out.write(<span class="number">97</span>);  </span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不论是字符流还是字节流，想直接使用节点流读入一个字符串，都稍显麻烦。</span></span><br><span class="line">        FileReader in = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>));</span><br><span class="line">        <span class="keyword">int</span>  temp;</span><br><span class="line">        <span class="keyword">while</span>((temp = in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)temp);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：缓冲流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(</span><br><span class="line">            <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>)));</span><br><span class="line">        <span class="comment">// 写一个字符串</span></span><br><span class="line">        out.write(<span class="string">"世界，你好！"</span>);</span><br><span class="line">        <span class="comment">// 写一个换行符</span></span><br><span class="line">        out.newLine();</span><br><span class="line">        <span class="comment">// 写一个字符串</span></span><br><span class="line">        out.write(<span class="string">"Hello World"</span>);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(</span><br><span class="line">            <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>)));</span><br><span class="line">        <span class="comment">// 读一行数据，遇到换行符或者到了文件末尾就停止。</span></span><br><span class="line">        System.out.println(in.readLine());</span><br><span class="line">        System.out.println(in.readLine());</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：转换流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">// 转换流也属于字符流。</span></span><br><span class="line"><span class="comment">// 它可以将字节流转换成字符流，然后以字符流的方式去操作文件。</span></span><br><span class="line"><span class="comment">// 转换流它包括OutputStreamWriter、InputStreamReader两个类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Writer out = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>)));</span><br><span class="line">        out.write(<span class="string">"世界你好\r\nHello World\r\n ☆☆☆cxy☆☆☆"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        Reader in = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>)));</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>((temp = in.read())!=-<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)temp);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从键盘读取一行数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String info = in.readLine();</span><br><span class="line">        System.out.println(<span class="string">"输入的信息为："</span>+info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><br>　　计算机中所有文件都是以字节方式存储的，字符是在内存中形成的。</p>
<pre><code>计算机只认识0、1组成的二进制码，硬盘上存贮的任何文件，也都是用0、1码表示。
所有看到的字符、图片、视频和听到的声音都是经过应用程序转化后的（在内存中形成的）。
比如当使用Windows记事本程序打开一个文件之后，您看到的绝对不是010101码，而是字符。
因为记事本本身也是一个程序，字节被读到内存后经过了记事本的转换。
</code></pre><p>　　查看FileReader和FileWriter类的源码，可以发现它们的父类是转换流。</p>
<pre><code>和异常、线程一样，如果父类是一个异常或者线程类，那么子类也同样是一个异常或线程类。
这个概念在流中也同样存在，FileReader和FileWriter的父类是转换流，那么意味着它们两个也同样是转换流。
其实在FileReader和FileWriter的内部就是使用的FileInputStream和FileOutputStream类。
</code></pre><p>　　说到这里就可以得到一个结论了：</p>
<pre><code>文件由字节组成，咱们无法直接查看。
字符是在内存中形成的，如果咱们想看字符，则就需要在内存中对字节转换。
但是我们使用FileWriter和FileReader时，并没有去使用转换流，难道是它们自己转换了？
的确是这样的，在我们使用FileWriter和FileReader时这一转换是自动进行的，因为它们是转换流的子类，它们完全有能力去将字节转换成字符。
</code></pre><p>　　但是转换操作在什么地方进行？ 内存？说的太广泛了吧？</p>
<pre><code>转换在缓冲区进行。
这里说的缓冲区不是指的BufferedReader流，而是另一个用于暂存数据的区域。
也就是说字符流可以使用2个缓冲区，一个是BufferedReader，另一个是字符流自带的一个缓冲区。
</code></pre><center><br><img src="/img/base/base001_21.png" alt=""><br></center>

<p>　　为什么有人说“字符流必须得关闭流”？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法用于关闭流，但是关闭流之前，会将缓冲区的数据送出去。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p>
<p>　　也就是说：</p>
<pre><code>对于字节流来说，关闭流就是为了安全、程序效率(若不关闭流则系统资源会一直被占用)而做的操作。
对于字符流来说，关闭流除了为了安全外、程序效率，还有一个操作就是，刷新缓冲区。
如果使用字符流时忘了关闭流，那么程序结束时字符流缓冲区的数据都会丢失。
</code></pre><p>　　此时就涉及到另一个方法了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 此方法来自于Flushable接口，用于刷新缓冲区。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 其中OutputStream、Writer中实现了此接口，并提供了空实现，而输入流则没有实现此接口。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 其中：</span></span></span><br><span class="line"><span class="function"><span class="comment">// FileOutputStream类并没有重写此方法，即其不需要刷新刷冲区。</span></span></span><br><span class="line"><span class="function"><span class="comment">// BufferedOutputStream类则实现了此方法。</span></span></span><br><span class="line"><span class="function"><span class="comment">// FileWriter的父类OutputStreamWriter则重写了此方法。</span></span></span><br></pre></td></tr></table></figure></p>
<p><br>　　最后说一下：</p>
<pre><code>字节流为了处理字节而生，读取图片、视频、音乐等数据时使用，也可以读取各种数据类型。
字符流为了处理字符，读取文字、符号等文本时使用。
在实际开发中，还是字节流我们使用的比较多，同时为了安全、正确、高效等因素，请关闭所有的流。
</code></pre><h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p><br>　　所谓的对象序列化，将对象转成字节并保存在硬盘的操作。对象序列化的要求：</p>
<pre><code>-  只有实现了java.io.Serializable接口的类的对象才可以序列化。
-  此接口与Clonezble接口是一样的，接口中并没有任何方法，它只是标识其实现类具备了某种能力。
</code></pre><p>　　对象序列化的操作类：</p>
<pre><code>-  ObjectOutputStream ：进行序列化，将对象转成字节形式写入硬盘。
-  ObjectInputStream ：进行反序列化，将对象读入内存。
</code></pre><p><br>　　范例1：序列化对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用transient修饰的属性不会被序列化，如将name属性修改为：</span></span><br><span class="line">    <span class="comment">// private transient String name;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age =age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span>+<span class="keyword">this</span>.name+<span class="string">"; 年龄: "</span>+<span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>)));</span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">40</span>));</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>)));</span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        Person p = (Person) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回想一下Object类型的引用变量，是可以接受任意引用类型的对象的。如：</span></span><br><span class="line">Object obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">22</span>] </span><br><span class="line"><span class="comment">// 因此可以利用此特点来序列化一组对象。</span></span><br><span class="line"><span class="comment">// out.writeObject(</span></span><br><span class="line"><span class="comment">//     new Person[]&#123;</span></span><br><span class="line"><span class="comment">//     new Person("张三",40),</span></span><br><span class="line"><span class="comment">//     new Person("李四",42),</span></span><br><span class="line"><span class="comment">//     new Person("王五",20)</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// 但是反序列化时需要向下转型成数组类型。</span></span><br><span class="line">Person[] p = (Person[]) in.readObject();</span><br></pre></td></tr></table></figure></p>
<p>　　查看”D:\a.txt”文件内容显示为：</p>
<pre><code> sr cxy.zy.io.Personv­-邇n I ageL 
namet Ljava/lang/String;xp   (t 寮犱笁
</code></pre><p>　　从文件中大体可以看到，所谓的对象序列化其实序列化的内容是：</p>
<pre><code>包名、类名
类中的属性、属性所在的类，以及属性的取值。
</code></pre><p>　　需要注意的是，里面并没有序列化方法：</p>
<pre><code>因为方法都是已经存在的，或者说是固定不变的，而对象间的区别实际上就在于属性上。
对象的属性会被递归序列化的，但是如果某个字段所在类没实现Serializable接口，则该对象将不可以序列化，上例中int和String都实现了Serializable接口。
静态属性不会被序列化。
</code></pre><p><br>　　在序列化对象时要一次性写入完毕：</p>
<pre><code>对象序列化时，会先写入一个头部，然后写入数据，最后加上结束符号。
如果使用追加方式写入的话，那新数据就会在文件末尾继续向下写入。
但是在读取时只会读到第一个结束符就停止，后来再次写入的数据就根本都不到了，若仍然继续读，就会抛StreamCorruptedException异常了，这个异常和EOFException颇为相似，因此以后别用追加的方式序列化对象，要一次性序列化完所有的对象后，再关闭ObjectOutputStream 。
</code></pre><p><br>　　版本控制：</p>
<pre><code>-  在进行对象序列化和反序列化的时候，对于不同JDK版本，会出现版本兼容问题。如在JDK1.5序列化的对象，在JDK1.0上面可能就不能使用了。
-  为了解决对象的序列化和反序列化间的版本不统一问题，引入了一个类常量。
   -  static final long serialVersionUID
   -  在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应的类的class文件中的SerialVersionUID比较
      -  如果相同则就认为版本一致，因此可以进行反序列化。
      -  如果不相同则就认为版本不一致，然后就抛“序列化版本不一致”异常。
   -  在序列化对象的时候，应该为该类创建一个serialVersionUID属性，做为字节码的ID，若是不定义此变量则系统会依据该类内的属性名、属性的标识符等自动生成的一个serialVersionUID，因此若是以后该类的某个字段的名字被修改了，则自动生成的serialVersionUID就不一样了。
</code></pre><h2 id="其他流类"><a href="#其他流类" class="headerlink" title="其他流类"></a>其他流类</h2><p><br>　　范例1：内存流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面介绍的各种IO流知识，主要是针对文件的输入输出。</span></span><br><span class="line"><span class="comment">// 但在实际开发中，输入的数据可能来源于网络，输出的数据目的地也不一定是文件。</span></span><br><span class="line"><span class="comment">// 在这种情况下，我们就可能会使用到内存流。</span></span><br><span class="line"><span class="comment">// 所谓的内存流就是ByteArrayInputStream和ByteArrayOutputStream。</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">        <span class="comment">// 将对象序列化到ByteArrayOutputStream中。</span></span><br><span class="line">        objOut.writeObject(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">30</span>));</span><br><span class="line">        objOut.close();</span><br><span class="line">        <span class="comment">// toByteArray()方法将ByteArrayOutputStream对象中的内容转成一个byte[]。</span></span><br><span class="line">        <span class="comment">// 进行反序列化。 </span></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray()));</span><br><span class="line">        Person temp = (Person)in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中ByteArrayOutputStream类在Java网络编程时用的比较多，具体后述。</span></span><br></pre></td></tr></table></figure></p>
<p>　　<br><br>　　范例2：合并流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并流可以将2个数据源中的内容合并在一起，如将2个记事本的内容合成1个记事本文件。</span></span><br><span class="line"><span class="comment">// 下面2首歌共12MB，如果不使用缓冲区则花费了65秒，使用缓冲区后1328毫秒。</span></span><br><span class="line"><span class="comment">// 操作类SequenceInputStream，它是InputStream的直接子类。</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedInputStream buf = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> SequenceInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:/周杰伦 - 你怎么连话都说不清楚 - 演唱会 the one.mp3"</span>)),<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:/周杰伦-回到过去.mp3"</span>))));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"total1.mp3"</span>)));</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>( (temp = buf.read())!=-<span class="number">1</span>)</span><br><span class="line">            out.write(temp);</span><br><span class="line">        System.out.println(<span class="string">"耗时: "</span>+(System.currentTimeMillis()-start));</span><br><span class="line">        buf.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<br><br>　　<strong>文件压缩</strong></p>
<p>　　将大文件压缩成小文件，在文件传输的时候可以减少传输时间，常见的文件压缩格式：jar、rar、zip、gz(Unix系统中的)等。</p>
<p>　　Java中主要支持3种文件的压缩： jar、zip、gzip。</p>
<pre><code>压缩Jar文件涉及到的API：
-  JarInputStream和JarOutputStream，分布负责解压缩文件和压缩文件。
-  JarFile和JarEntry，分布表示压缩文件和压缩实体。

压缩Zip文件涉及到的API：
-  ZipInputStream和ZipOutputStream，与压缩Jar文件作用一样。
-  ZipFile和ZipEntry与压缩Jar文件作用一样。

压缩Gzip文件涉及到的API：
-  GZIPOutputStream
-  GZIPInputStream
</code></pre><p>　　各类压缩API的操作方法大同小异，只是使用的压缩流不同而已。<br>　　<br>　　范例1：压缩文件夹。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 待压缩的文件夹</span></span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"demo"</span>);</span><br><span class="line">        <span class="comment">// 输出的压缩文件</span></span><br><span class="line">        ZipOutputStream zipFile=<span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(file.getParent()+<span class="string">"demo.zip"</span>));</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            File[] array = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span>(File temp : array)&#123;</span><br><span class="line">                <span class="comment">// ZipEntry表示压缩文件内部的一个压缩项</span></span><br><span class="line">                zipFile.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()+File.separator+ temp.getName()));</span><br><span class="line">                FileInputStream sourceFile = <span class="keyword">new</span> FileInputStream(temp);</span><br><span class="line">                <span class="keyword">int</span> data ;</span><br><span class="line">                <span class="keyword">while</span>( (data=sourceFile.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    zipFile.write(data);</span><br><span class="line">                &#125;</span><br><span class="line">                sourceFile.close();</span><br><span class="line">            &#125;</span><br><span class="line">            zipFile.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<br>　　范例2：解压缩文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File waitUnZipFile=<span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"demo.zip"</span>);</span><br><span class="line">        ZipFile zipFile=<span class="keyword">new</span> ZipFile(waitUnZipFile);</span><br><span class="line">        ZipInputStream zipInputStream=<span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(waitUnZipFile));</span><br><span class="line">        FileOutputStream out=<span class="keyword">null</span>;</span><br><span class="line">        InputStream in=<span class="keyword">null</span>;</span><br><span class="line">        ZipEntry entry=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((entry=zipInputStream.getNextEntry())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            in=zipFile.getInputStream(entry);</span><br><span class="line">            File outFile=<span class="keyword">new</span> File(<span class="string">"D:"</span>+entry.getName());</span><br><span class="line">            <span class="keyword">if</span>(!outFile.getParentFile().exists())&#123;</span><br><span class="line">                outFile.getParentFile().mkdir();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!outFile.exists())</span><br><span class="line">                outFile.createNewFile();</span><br><span class="line">            out=<span class="keyword">new</span> FileOutputStream(outFile);</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">while</span>((temp=in.read())!=-<span class="number">1</span>)</span><br><span class="line">                out.write(temp);</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        zipInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><br>　　泛型顾名思义，它代表一个广泛的类型，即它可以代表任意类型，而Object类也可以接受任意类型的对象，也可以代表任意类型。</p>
<p>　　泛型和Object的区别：</p>
<pre><code>-  泛型代表一个可变的类型，一旦为其指定了一个具体的类型，则泛型就固定了，不能再更改了。
-  Object类型代表一个可变的类型，在任何时间、地点都可以接受任何数据类型。
</code></pre><h2 id="泛型引出"><a href="#泛型引出" class="headerlink" title="泛型引出"></a>泛型引出</h2><p><br>　　题目：设计一个坐标类。<br>　　要求：这个类可以表示Integer、Float、String类型的坐标。<br>　　分析： </p>
<pre><code>如果按照以前学习的知识，只能使用Object类来完成此题目，因为只有Object类可以同时接受这三种数据类型。
</code></pre><p>　　<br>　　范例1：有问题的范例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object x;</span><br><span class="line">    <span class="keyword">private</span> Object y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(Object x,Object y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 传递的是String类型参数</span></span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point(<span class="string">"120E"</span>,<span class="string">"40N"</span>); </span><br><span class="line">        <span class="comment">// 向下转型为Integer</span></span><br><span class="line">        <span class="comment">// 程序运行抛出异常：java.lang.ClassCastException</span></span><br><span class="line">        <span class="comment">// 原因是向下转型时出现了错误。</span></span><br><span class="line">        <span class="keyword">int</span> ix = (Integer) p1.getX();  </span><br><span class="line">        <span class="keyword">int</span> iy = (Integer) p1.getY();</span><br><span class="line">        System.out.println(<span class="string">"x= "</span>+ix+<span class="string">",y= "</span>+iy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面的错误我们一般情况下是不会犯的，但有时候由于程序的代码量十分庞大，同时团队开发的情况下，若A写的代码由B来维护，这样B就很容易不知道某一个对象在此时的具体类型是什么，因此很容易出现类转换错误。<br>　　<br>　　范例2：使用泛型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类的定义格式：class 类名&lt;泛型类型&gt;&#123;&#125;</span></span><br><span class="line"><span class="comment">// 下面的泛型类型写的是T，我们可以将T改成A、B、abc、Type等任意名称。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">private</span> T y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 泛型是在“实例化对象的时候”才为类中的属性、方法，指定具体的数据类型。</span></span><br><span class="line">        <span class="comment">// 这样p1中的所有T都会被替换成String。</span></span><br><span class="line">        Point&lt;String&gt; p1 = <span class="keyword">new</span> Point&lt;String&gt;(<span class="string">"120E"</span>,<span class="string">"40N"</span>);</span><br><span class="line">        String ix =  p1.getX();  </span><br><span class="line">        String iy =  p1.getY();</span><br><span class="line">        System.out.println(<span class="string">"x= "</span>+ix+<span class="string">",y= "</span>+iy);</span><br><span class="line">        <span class="comment">// p2中的所有T都会被替换成Integer。</span></span><br><span class="line">        <span class="comment">// p1和p2互不干扰。</span></span><br><span class="line">        Point&lt;Integer&gt; p2 = <span class="keyword">new</span> Point&lt;Integer&gt;(<span class="number">33</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">int</span> x = p2.getX();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果使用如下代码，则就是编译错误而不是运行错误。</span></span><br><span class="line">        p1.setX(<span class="number">12</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<br>　　范例3：不指定泛型（了解）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立对象的时候不指定泛型也不会有编译错误，但是会有警告信息。</span></span><br><span class="line">        <span class="comment">// 因为没指定泛型，所以Java按照任意类型来处理泛型，那么此时就又回到了原点。</span></span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point(<span class="string">"120E"</span>, <span class="string">"40N"</span>);</span><br><span class="line">        String x = (String) p1.getX();</span><br><span class="line">        String y = (String) p1.getY();</span><br><span class="line">        <span class="comment">// 如果想消除警告，可以这么写：</span></span><br><span class="line">        Point&lt;Object&gt; p2 = <span class="keyword">new</span> Point&lt;Object&gt;(<span class="string">"120E"</span>, <span class="string">"40N"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p><br>　　范例1：在泛型中没有向上转型这一概念。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在Java中可以将一个Integer对象赋值给一个Object类：</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Integer(<span class="number">23</span>);</span><br><span class="line">        Point&lt;Object&gt; p1 = <span class="keyword">new</span> Point&lt;Object&gt;(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">        Point&lt;Integer&gt; p2 = <span class="keyword">new</span> Point&lt;Integer&gt;(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 但是在泛型中下面的代码就是错误的。</span></span><br><span class="line">        p1 = p2;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原因很简单：</span></span><br><span class="line"><span class="comment">// p2是Point&lt;Integer&gt;类型的引用变量，而不是Integer类型的变量。</span></span><br><span class="line"><span class="comment">// p1是Point&lt;Object&gt;类型的引用变量，而不是Object类型的变量。</span></span><br><span class="line"><span class="comment">// 简单的说p1和p2不再是简单的Integer、Object类型了，而变成一个复杂的类型了。</span></span><br><span class="line"><span class="comment">// 因此将一个Point&lt;Integer&gt;类型的对象赋值给Ponit&lt;Object&gt;类型的变量是错误的。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：使用通配符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面使用的“?”就称为通配符。</span></span><br><span class="line">        <span class="comment">// 它表示可以接受任意“Ponit&lt;T&gt;”类型的对象。</span></span><br><span class="line">        <span class="comment">// 需要注意的是Point&lt;?&gt;和Point&lt;Object&gt;是不同的，后者只能接受Point&lt;Object&gt;类型。</span></span><br><span class="line">        Point&lt;?&gt; p1 = <span class="keyword">new</span> Point&lt;Object&gt;(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">        Point&lt;?&gt; p2 = <span class="keyword">new</span> Point&lt;Integer&gt;(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line">        p1 = p2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 但是通配符是有缺陷的：只能引用不能修改。</span></span><br><span class="line">        Point&lt;?&gt; p3 = <span class="keyword">new</span> Point&lt;Integer&gt;(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 此语句没有问题</span></span><br><span class="line">        System.out.println(p3.getX());   </span><br><span class="line">        <span class="comment">// 编译错误。</span></span><br><span class="line">        p3.setX(<span class="number">2</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：泛型上限。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所谓的泛型上限就是限制泛型的取值范围，最高不能超过一个指定的类型。</span></span><br><span class="line"><span class="comment">// 下面限制了T只能是Number和Number子类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">private</span> T y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(T x, T y)</span> </span>&#123;    <span class="keyword">this</span>.x = x; <span class="keyword">this</span>.y = y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getY</span><span class="params">()</span> </span>&#123;   <span class="keyword">return</span> y;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没问题。</span></span><br><span class="line">        Point&lt;Integer&gt; p1 = <span class="keyword">new</span> Point&lt;Integer&gt;(<span class="number">12</span>,<span class="number">23</span>);  </span><br><span class="line">        <span class="comment">// 编译错误。</span></span><br><span class="line">        Point&lt;String&gt; p2 = <span class="keyword">new</span> Point&lt;String&gt;(<span class="string">"120E"</span>,<span class="string">"40N"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以不修改类，直接在实例化的时候设置上限。</span></span><br><span class="line">        Point&lt; ? extends Number&gt; p3 = <span class="keyword">new</span> Point&lt;Integer&gt;(<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相应的也可以在方法上设置上限。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Point&lt; ? extends Number&gt; p2)</span></span>&#123;</span><br><span class="line">        System.out.println(p2.getX());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：泛型下限。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顾名思义，泛型最低不能低过一个指定的类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面限制了T只能是String或String的父类。</span></span><br><span class="line">        Point&lt;? <span class="keyword">super</span> String&gt; p = <span class="keyword">new</span> Point&lt;String&gt;(<span class="string">"123E"</span>,<span class="string">"40N"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p><br>　　所谓的泛型方法，就是在一个非泛型类中定义一个方法，这个方法有点特殊它使用了泛型。</p>
<p>　　范例1：错误的范例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此类为非泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 定义一个泛型T。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的代码会有编译错误，原因很简单：</span></span><br><span class="line"><span class="comment">// 编译器并没有把“T”当成一个泛型，而是做成一个普通的类了。</span></span><br><span class="line"><span class="comment">// 对编译器来说“T”和“String”、“Student”没什么区别，而它找了一圈之后并没有找到T。</span></span><br></pre></td></tr></table></figure></p>
<p>　　范例2：修改代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在方法的返回值之前加一个&lt;T&gt;这就算是对T进行定义了。</span></span><br><span class="line">    <span class="comment">// 这样一来编译器就知道T是一个泛型了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"say :   "</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        say(<span class="string">"Hello World"</span>)  ;  <span class="comment">// 指定方法的泛型为String</span></span><br><span class="line">        say(<span class="number">123</span>);  <span class="comment">// 指定方法的泛型为Integer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法的具体类型同样是由外部来指定的，在调用方法的时候指定的。</span></span><br></pre></td></tr></table></figure></p>
<p>　　范例3：方法的返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回值是泛型的写法，和普通方法的返回值一致。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">T <span class="title">say</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">T <span class="title">print</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String message = say(<span class="string">"Hello World"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = say(<span class="number">123</span>);</span><br><span class="line">        System.out.println(message+<span class="string">"   "</span>+i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递一个double和一个int给方法，编译器会有“类型推测”，自动推测出T的类型为Number。</span></span><br><span class="line">        Number n = print(<span class="number">5.2</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然也可以返回泛型数组。</span></span><br><span class="line"><span class="comment">// public static &lt;T&gt;T[] say(T a)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p><br>　　范例1：定义与使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Java中实现泛型接口有两种方式：</span></span><br><span class="line"><span class="comment">// 1、类本身也是一个泛型类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoOper</span>&lt;<span class="title">A</span>&gt; <span class="keyword">implements</span> <span class="title">Demo</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 实现接口，但类本身也是泛型类。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义类的同时为接口指定泛型的类型。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此范例是在实现泛型接口的同时为接口指定一个具体的类型。</span></span><br><span class="line">    <span class="comment">// 相应的在接口中的方法中出现的泛型也要跟着改写。</span></span><br><span class="line">    <span class="comment">// 如：</span></span><br><span class="line">    <span class="comment">// Comparable接口中的方法原来为：public int compareTo(T o)</span></span><br><span class="line">    <span class="comment">// 在此例中被改写为：public int compareTo(Person temp)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; temp.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; temp.age)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.name.compareTo(temp.name) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.name.compareTo(temp.name) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><br>　　数组：在Java中数组的长度一旦确定就不能更改。<br>　　集合：集合就是指一个长度可以变化的类似于(或等于)数组的东西。</p>
<pre><code>-  作用：数组是干什么用的集合就是干什么用的，说白了就是存储数据用的。
-  为什么要用集合？
-  首先，数组长度固定，在实际应用中数组大小不好估计。
-  其次，集合可以提供一些附加的功能，十分利于实际中的开发。如：排序、高速存取、消除重复等。
</code></pre><p>　　Java提供的各种集合，主要派生自如下两个接口：</p>
<pre><code>-  Collection接口 ：特点是数据直接被存在于集合中。
-  Map接口 ：特点是使用key/value的方式保存数据，通过key来读取value。
</code></pre><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>　　<code>Collection</code>接口表示集合，其定义了所有子类共有的一些操作（增删查改等），它是抽象的没办法直接使用，实际开发中我们一般都是用其子接口<code>List</code>和<code>Set</code>的实现类。</p>
<pre><code>List接口的子类存储元素时，允许元素重复。
Set接口则不允许有重复元素。
</code></pre><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>　　List接口的子类按照其内部元素的存储方式分为两大类：</p>
<pre><code>-  数组实现：代表有ArrayList等。当数组容量不足时，会建立一个更大的数组，然后将之前的元素全部copy到新数组中。
-  链表实现：代表有LinkedList等。
</code></pre><p><br>　　范例1：ArrayList。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">         <span class="comment">// 在最后增加元素</span></span><br><span class="line">        array.add(<span class="string">"Hello World"</span>); </span><br><span class="line">        array.add(<span class="string">"世界,你好!"</span>);</span><br><span class="line">        <span class="comment">// 在指定位置增加元素，下标从0开始</span></span><br><span class="line">        array.add(<span class="number">0</span>,<span class="string">"cxy"</span>);   </span><br><span class="line">        <span class="comment">// 指定位置删除元素，下标从0开始</span></span><br><span class="line">        array.remove(<span class="number">1</span>);  </span><br><span class="line">        <span class="comment">// 指定元素删除 </span></span><br><span class="line">        <span class="comment">// 删除时会拿参数对象依次和列表里的每个元素比较，即调用equals()方法比较。</span></span><br><span class="line">        <span class="comment">// 因为在String类中重写了equals()方法，所以可以找到并成功删除。 </span></span><br><span class="line">        <span class="comment">// 若是删除自定义类的对象，在该类没有重写equals()方法的前提下，可能就无法删除。</span></span><br><span class="line">        <span class="comment">// 因为会调用Object类的equals()方法，其默认实现是引用变量的值的简单比较。</span></span><br><span class="line">        <span class="comment">// 如果不是一个对象的话，就无法删除了。</span></span><br><span class="line">        array.remove(<span class="string">"世界,你好!"</span>);  </span><br><span class="line">        <span class="comment">// 删除所有元素</span></span><br><span class="line">        array.clear();  </span><br><span class="line">        <span class="comment">// ArrayList类已经重写了toString方法</span></span><br><span class="line">        System.out.println(array);  </span><br><span class="line">        就会使用Object的equals()方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age =age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person temp = (Person) obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(temp.name) &amp;&amp; <span class="keyword">this</span>.age == temp.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span>+<span class="keyword">this</span>.name+<span class="string">","</span>+<span class="keyword">this</span>.age+<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList还有如下几个方法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得指定位置上的元素</span></span><br><span class="line">array.get(i);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在，contains方法也会调用equals()进行比较。</span></span><br><span class="line">System.out.println(array.contains(<span class="string">"Hello World"</span>));</span><br><span class="line"><span class="comment">// 截取元素，从0开始到1结束，不包括1。</span></span><br><span class="line">System.out.println(array.subList(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 元素替换，若下标越界，同样会抛异常。</span></span><br><span class="line">array.set(<span class="number">1</span>, <span class="string">"踏莎寻"</span>);</span><br></pre></td></tr></table></figure></p>
<p><br>　　还有一个名为Vector的类，它的用法与ArrayList一样，不同的是其是线程安全的。</p>
<pre><code>所谓的线程安全就是指，所有的方法都是用synchronized修饰。
前面也说了，使用此关键字修饰的方法同一时间只能被一个线程访问，其他线程必须等待，因此就造成程序执行时间较长的缺点，只有在一些对安全性要求高的场合下才考虑使用Vector类。
</code></pre><p><br>　　范例2：Stack。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack类表示一个栈，其是Vector类的子类，所有的方法也是线程同步的。</span></span><br><span class="line"><span class="comment">// 栈是一种后进先出的数据结构。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        stack.push(<span class="string">"No.1"</span>);</span><br><span class="line">        stack.push(<span class="string">"No.2"</span>);</span><br><span class="line">        stack.push(<span class="string">"No.3"</span>);</span><br><span class="line">        stack.push(<span class="string">"No.4"</span>);</span><br><span class="line">        stack.push(<span class="string">"No.5"</span>);</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        System.out.println(<span class="string">"当前栈顶元素为： "</span>+stack.peek());</span><br><span class="line">        System.out.println(<span class="string">"弹出栈顶元素： "</span>+stack.pop());</span><br><span class="line">        System.out.println(<span class="string">"当前栈顶元素为： "</span>+stack.peek());</span><br><span class="line">        System.out.println(<span class="string">"栈是否为空： "</span>+stack.empty());</span><br><span class="line">        System.out.println(<span class="string">"No.5的位置是： "</span>+stack.search(<span class="string">"No.5"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：LinkedList。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedList类表示一个链表，它实现了Queue接口，因而也是一个队列。</span></span><br><span class="line"><span class="comment">// 队是一种先进先出的数据结构。</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; line = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        line.add(<span class="string">"No.1"</span>);   <span class="comment">//在表尾增加元素</span></span><br><span class="line">        line.add(<span class="number">0</span>,<span class="string">"No.2"</span>); <span class="comment">//在指定位置增加元素</span></span><br><span class="line">        line.push(<span class="string">"No.5"</span>);     <span class="comment">//在表头增加元素</span></span><br><span class="line">        line.addFirst(<span class="string">"No.3"</span>); <span class="comment">//在表头增加元素</span></span><br><span class="line">        line.addLast(<span class="string">"No.4"</span>);  <span class="comment">//在表尾增加元素</span></span><br><span class="line">        System.out.println(line);</span><br><span class="line">        System.out.println(<span class="string">"只查看表头："</span>+line.getFirst());</span><br><span class="line">        System.out.println(<span class="string">"查看并删除表头："</span>+line.pop());</span><br><span class="line">        System.out.println(<span class="string">"只查看表头："</span>+line.peek());</span><br><span class="line">        System.out.println(<span class="string">"只查看表尾："</span>+line.getLast());</span><br><span class="line">        System.out.println(<span class="string">"查看并删除表尾："</span></span><br><span class="line">+line.remove(line.size()-<span class="number">1</span>));</span><br><span class="line">        String[] array = line.toArray(<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(String str : array)</span><br><span class="line">            System.out.print(str+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　<strong>CopyOnWriteArrayList</strong></p>
<p>　　很多时候，会有多个线程同时操作一个ArrayList，如一个线程执行遍历，一个线程执行添加，但ArrayList的缺点不足以满足我们的需求：</p>
<pre><code>首先，ArrayList提供的方法都是非线程安全的。
然后，ArrayList在通过Iterator接口(后述)遍历其内元素时，不能同时对其进行写操作，所为的“写”指的就是“add、remove”操作，否则就会抛异常。
</code></pre><p><br>　　范例1：ArrayList源码阅读。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用List提供的iterator()方法可以获取一个Iterator接口的实例。</span></span><br><span class="line"><span class="comment">// 这个实例其实是ArrayList内部类Itr的一个实例，该内部类实现了Iterator接口，用于列表遍历。</span></span><br><span class="line"><span class="comment">// 然后在这个Itr的实例上调用next()方法时，就会执行类似于下面的代码。</span></span><br><span class="line"><span class="comment">// 为什么说类似下面的代码? 因为不同版本的jdk中ArrayList的源码是不同的。</span></span><br><span class="line"><span class="comment">// 有的jdk版本中的ArrayList并没有定义iterator方法，而是由其父类AbstractList来定义。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性modCount代表ArrayList中当前元素的个数。</span></span><br><span class="line">    <span class="comment">// 属性expectedModCount代表Iterator对象创建时，ArrayList中元素的个数。</span></span><br><span class="line">    <span class="keyword">if</span> (modCount!= expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vector类虽然是线程同步的，但同样无法遍历的同时执行写操作。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　CopyOnWriteArrayList类对ArrayList类的功能进行了扩充，就是解决了上面的问题，接下来笔者简单的介绍一下这个类的实现原理。</p>
<p>　　首先CopyOnWriteArrayList与ArrayList一样其内使用一个Object[] array保存元素。</p>
<center><br><img src="/img/base/base001_22.png" alt=""><br></center>

<p>　　然后用户调用CopyOnWriteArrayList的iterator方法时，该类会创建并返回一个其内部类COWIterator的实例，该实例会使用一个新的引用变量elements来指向外部类的array，用户获取Iterator并调用next()方法获取数据时，都是在上elements(也就是array)调用的。</p>
<center><br><img src="/img/base/base001_23.png" alt=""><br></center>

<p>　　接着CopyOnWriteArrayList在执行所有与“写”操作有关的方法时，都会使用<code>System.arraycopy()</code>或<code>Arrays.copyOf()</code>(依据jdk版本而不同)来创建array的一个副本数组temp，然后在这个副本上执行“写”操作。 执行完毕后，会使array指向temp 。</p>
<center><br><img src="/img/base/base001_24.png" alt=""><br></center>

<p>　　若当一个线程正在迭代集合中的数据时，另一个线程同时对List执行了“写”操作，这个“写”操作执行完毕后，最终更新的是的仅仅是array指向，而迭代线程所迭代的elements仍然指向最初的那个数组。同时CopyOnWriteArrayList类的“写”方法都是线程同步的。</p>
<p>　　因此CopyOnWriteArrayList顾名思义，当向ArrayList执行“写”操作时会先建立一个副本。</p>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p><br>　　若希望集合中不存在相同的元素则可以使用Set接口，Set接口最常见的两个子类：</p>
<pre><code>-  HashSet&lt;E&gt; ：在没有相同元素的基础上，还可以高速存取。
-  TreeSet&lt;E&gt; ：在没有相同元素的基础上，还可以自动排序。
</code></pre><p><br>　　范例1：HashSet。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面插入了2个"No.1"但是执行的结果却发现只有1个，这就是Set的特点，不允许有重复元素。</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; hash = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        hash.add(<span class="string">"No.1"</span>);</span><br><span class="line">        hash.add(<span class="string">"No.1"</span>);</span><br><span class="line">        hash.add(<span class="string">"No.2"</span>);</span><br><span class="line">        hash.add(<span class="string">"No.3"</span>);</span><br><span class="line">        hash.add(<span class="string">"No.4"</span>);</span><br><span class="line">        hash.add(<span class="string">"No.5"</span>);</span><br><span class="line">        System.out.println(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用HashSet的add()方法插入元素的时候：</span></span><br><span class="line"><span class="comment">// HashSe会自动调用元素的hashCode()方法。</span></span><br><span class="line"><span class="comment">// 然后根据hashCode()方法的返回值，来决定元素要插入的位置。</span></span><br><span class="line"><span class="comment">// 如果该位置上已经存在元素了，则会调用该元素equals()方法进行比较。</span></span><br><span class="line"><span class="comment">// 如果两个元素相等，则丢掉欲插入的元素。</span></span><br><span class="line"><span class="comment">// 如果两个元素不相等，则新元素会被加入到另一个位置(通过冲突检测来决定哪一个位置)。</span></span><br><span class="line"><span class="comment">// 本范例中使用的是String类，在String类已经重写完了Object类的equals()和hashCode()方法。</span></span><br><span class="line"><span class="comment">// 如果是自定义的类，却并没有重写这2个方法，则就无法消除重复。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 说白了，对于自定义的类来说：</span></span><br><span class="line"><span class="comment">// 如果想完整的使用HashSet类，那么最少要重写equals()和hashCode()方法。</span></span><br><span class="line"><span class="comment">// 重写hashCode()用于获得元素的存储位置，只要能尽量使对象间的hash码互不相同即可。</span></span><br><span class="line"><span class="comment">// 重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet的一个特性：</span></span><br><span class="line"><span class="comment">// 将元素A、B依次插入到HashSet中，A并不一定排在B的前面，因为元素存储位置是由hash码来确定的。</span></span><br><span class="line"><span class="comment">// 因此说HashSet是无序存放元素的。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例1：TreeSet。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeSet&lt;String&gt; tree = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        tree.add(<span class="string">"No.45"</span>);</span><br><span class="line">        tree.add(<span class="string">"No.1"</span>);</span><br><span class="line">        tree.add(<span class="string">"No.1"</span>);</span><br><span class="line">        tree.add(<span class="string">"No.52"</span>);</span><br><span class="line">        tree.add(<span class="string">"No.12"</span>);</span><br><span class="line">        tree.add(<span class="string">"No.4"</span>);</span><br><span class="line">        tree.add(<span class="string">"No.11"</span>);</span><br><span class="line">        System.out.println(tree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行程序后发现，TreeSet不允许元素重复同时会自动给元素进行排序。</span></span><br><span class="line"><span class="comment">// 但是自动排序功能是有条件的：</span></span><br><span class="line"><span class="comment">// TreeSet&lt;T&gt;中的T必须是实现了Comparable&lt;T&gt;接口，否则程序运行时抛异常。</span></span><br><span class="line"><span class="comment">// String类已经实现了Comparable接口，因此没有抛异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 说白了，如果想完整的使用TreeSet&lt;E&gt;类，那么最少要实现Comparable接口。</span></span><br><span class="line"><span class="comment">// 重写compareTo()可以同时完成两份工作：排序和消除重复。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="集合输出"><a href="#集合输出" class="headerlink" title="集合输出"></a>集合输出</h3><p><br>　　在Java中有四种集合输出的方法：Iterator、ListIterator、foreach、Enumeration。</p>
<p>　　范例1：Iterator遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Collection&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.45"</span>);</span><br><span class="line">        array.add(<span class="string">"No.15"</span>);</span><br><span class="line">        array.add(<span class="string">"No.23"</span>);</span><br><span class="line">        array.add(<span class="string">"No.14"</span>);</span><br><span class="line">        array.add(<span class="string">"No.65"</span>);</span><br><span class="line">        array.add(<span class="string">"No.12"</span>);</span><br><span class="line">        <span class="comment">// Iterator就是迭代器的意思，使用它可以从第一个元素开始，一直遍历到最后一个元素。</span></span><br><span class="line">        <span class="comment">// Iterator中有一个位置指针的概念，用来代表当前正在遍历的位置，</span></span><br><span class="line">        <span class="comment">// 最初的时候这个指针指在第一个元素之前的位置。</span></span><br><span class="line">        <span class="comment">// Collection接口的子类都有一个iterator()方法用来获取当前集合的迭代器。</span></span><br><span class="line">        Iterator&lt;String&gt; iter = array.iterator();</span><br><span class="line">        <span class="comment">// 判断是否还有下一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 移动指针到下一个元素，并返回该元素</span></span><br><span class="line">            String str = iter.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"No.14"</span>.equals(str))</span><br><span class="line">                <span class="comment">// 使用迭代器删除当前元素，这个操作不会有并发修改的问题。</span></span><br><span class="line">                <span class="comment">// 每调用一次iter.next()方法只可以执行一次iter.remove()。</span></span><br><span class="line">                iter.remove();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　范例2：ListIterator遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListIterator接口是专为List接口及其子类准备的，可以进行向前遍历和向后遍历。</span></span><br><span class="line"><span class="comment">// 向前遍历和向后遍历使用同一个位置指针，因此最初的时候，指针指向的第一个元素之前，</span></span><br><span class="line"><span class="comment">// 这时是无法进行向前遍历的。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.45"</span>);</span><br><span class="line">        array.add(<span class="string">"No.15"</span>);</span><br><span class="line">        array.add(<span class="string">"No.23"</span>);</span><br><span class="line">        array.add(<span class="string">"No.14"</span>);</span><br><span class="line">        array.add(<span class="string">"No.65"</span>);</span><br><span class="line">        array.add(<span class="string">"No.12"</span>);</span><br><span class="line">        ListIterator&lt;String&gt; iter = array.listIterator();</span><br><span class="line">        System.out.println(<span class="string">"从头开始遍历："</span>);</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            System.out.print(iter.next()+<span class="string">" -- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n从尾开始遍历："</span>);</span><br><span class="line">        <span class="keyword">while</span>(iter.hasPrevious())&#123;</span><br><span class="line">            System.out.print(iter.previous()+<span class="string">" -- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　范例3：Foreach遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.45"</span>);</span><br><span class="line">        array.add(<span class="string">"No.15"</span>);</span><br><span class="line">        array.add(<span class="string">"No.65"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : array) &#123;</span><br><span class="line">            System.out.println(<span class="string">"☆"</span>+str+<span class="string">"☆"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　范例4：Enumeration遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enumeration类用于遍历Vector类 和Vector是同一时代的产物。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Vector&lt;String&gt; array = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.45"</span>);</span><br><span class="line">        array.add(<span class="string">"No.15"</span>);</span><br><span class="line">        array.add(<span class="string">"No.65"</span>);</span><br><span class="line">        Enumeration e = array.elements();</span><br><span class="line">        <span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(e.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p><br>　　Map接口可以操作两个值，比如说：</p>
<pre><code>Key(姓名)   value(电话号码)
张三        123123
李四        456456
王五        789789
</code></pre><p>　　这样的数据就可以使用Map存储，使用的时候根据key值去map中查找与其对应的value值。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><br>　　范例1：添加元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">        map.put(<span class="string">"张三"</span>, <span class="number">123123</span>);</span><br><span class="line">        map.put(<span class="string">"李四"</span>, <span class="number">456456</span>);</span><br><span class="line">        map.put(<span class="string">"王五"</span>, <span class="number">789789</span>);</span><br><span class="line">        map.put(<span class="string">"张三"</span>, <span class="number">100000</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 通过map.get("张三")可以读取到“100000”。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序运行的结果： </span></span><br><span class="line"><span class="comment">// 插入4条数据，输出的却只有3条。 </span></span><br><span class="line"><span class="comment">// 这是因为Map中key值不可以重复，如果重复了则新value会覆盖旧value。</span></span><br><span class="line"><span class="comment">// 由于此处是使用String类作为key，所以可以保证key值不重复。</span></span><br><span class="line"><span class="comment">// 但是如果使用用户自定义类做key，则同样需要同时重写hashCode()和equals()方法，少一个都不行。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：Iterator遍历元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;Person,String&gt; map = <span class="keyword">new</span> HashMap&lt;Person,String&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>),<span class="string">"No.1"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">21</span>),<span class="string">"No.2"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">64</span>),<span class="string">"No.3"</span>);</span><br><span class="line">        <span class="comment">// 获取一个包含所有key的Set对象。</span></span><br><span class="line">        Set&lt;Person&gt; p = map.keySet();</span><br><span class="line">        Iterator&lt;Person&gt; iter = p.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            Person temp =iter.next();</span><br><span class="line">            System.out.println(temp+<span class="string">"  ; value --&gt; "</span>+map.get(temp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序执行结果：</span></span><br><span class="line"><span class="comment">// [李四,21]  ; value --&gt; No.2</span></span><br><span class="line"><span class="comment">// [王五,64]  ; value --&gt; No.3</span></span><br><span class="line"><span class="comment">// [张三,20]  ; value --&gt; No.1</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：Foreach遍历元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Map中为每个Item可以保存两个值，但是实际上在Map接口内部却不是直接保存这两个值。</span></span><br><span class="line"><span class="comment">// 在Map接口中真正保存的是一个个Map.Entry对象。</span></span><br><span class="line"><span class="comment">// 在一个Map.Entry对象中，保存的才是map中定义的K和V。</span></span><br><span class="line"><span class="comment">// 因此在Map中不可以直接使用Iterator接口遍历。 </span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;Person,String&gt; map = <span class="keyword">new</span> TreeMap&lt;Person,String&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>),<span class="string">"No.1"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">21</span>),<span class="string">"No.2"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">21</span>),<span class="string">"No.3"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">64</span>),<span class="string">"No.4"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Person, String&gt; temp : map.entrySet())</span><br><span class="line">            System.out.println(temp.getKey()+<span class="string">"   "</span>+temp.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：其它常用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将其内部所有value放到一起，以Collection形式返回。</span></span><br><span class="line">Collection&lt;String&gt; p = map.values();</span><br><span class="line"><span class="comment">// 按key移除元素，同样要求key的类同时重写hashCode()和equals()方法。</span></span><br><span class="line">map.remove(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">64</span>));</span><br><span class="line"><span class="comment">// 是否存在某个Key</span></span><br><span class="line">map.containsKey(<span class="string">"No.1"</span>);</span><br><span class="line"><span class="comment">// 是否存在某个Value</span></span><br><span class="line">map.containsValue(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p><br>　　还有一个名为Hashtable的类，它的用法与HashMap一样，不同的是其是线程安全的。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><br>　　范例1：添加元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeMap类同样不允许key重复，并且会自动排序。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> TreeMap&lt;String,String&gt;();</span><br><span class="line">        map.put(<span class="string">"No.3"</span>, <span class="string">"赵六"</span>);</span><br><span class="line">        map.put(<span class="string">"No.1"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        map.put(<span class="string">"No.2"</span>, <span class="string">"王五"</span>);</span><br><span class="line">        map.put(<span class="string">"No.4"</span>, <span class="string">"秦七"</span>);</span><br><span class="line">        map.put(<span class="string">"No.1"</span>, <span class="string">"李四"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序运行的结果： </span></span><br><span class="line"><span class="comment">// &#123;No.1=李四, No.2=王五, No.3=赵六, No.4=秦七&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：自定义类作为key。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想完整的使用TreeMap&lt;K,V&gt;类，那么最少要实现Comparable接口。</span></span><br><span class="line"><span class="comment">// 重写compareTo()可以同时完成两份工作：排序和消除重复key。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;Person,String&gt; map = <span class="keyword">new</span> TreeMap&lt;Person,String&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>),<span class="string">"No.1"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">21</span>),<span class="string">"No.2"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">21</span>),<span class="string">"No.3"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">64</span>),<span class="string">"No.4"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在Map接口中，插入、删除等需要重写(compareTo、equals、hashCode)等方法，</span></span><br><span class="line"><span class="comment">// 都是针对于key来说的，value仅仅用来保存数据，value并不参与匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Set接口(TreeSet和HashSet)中，若出现了重复元素，则会将待插入元素删掉。</span></span><br><span class="line"><span class="comment">// 在Map接口(TreeMap和HashMap)中，若出现了重复key，则会用新value覆盖旧value。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p><br>　　在Map中是不允许key值重复的，但是在此类中可以允许key值重复。</p>
<p>　　范例1：Identity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;Person,String&gt; map = <span class="keyword">new</span>  IdentityHashMap&lt;Person,String&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>),<span class="string">"No.1"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>),<span class="string">"No.2"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要在两个对象的key使用“==”进行比较时不相等，就可以允许这2个key同时存在。</span></span><br><span class="line"><span class="comment">// 我在Person类中重写了hashCode()方法，如果“==”比较的是对象的hashCode码的话，</span></span><br><span class="line"><span class="comment">// 那么上面的范例中就只会有一个元素，但事实上却出现2个元素。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><br>　　Properties类通常操作软件的配置文件，配置文件用来保存用户对软件进行的一些个性化配置。如：软件使用的主题、皮肤等设置。</p>
<p><br>　　范例1：属性文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Properties类是的Hashtable的子类。</span></span><br><span class="line"><span class="comment">// 配置文件是由一个个的属性组成的，每个属性都是采用key/value的形式来表示。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个Properties对象。</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 创建属性。</span></span><br><span class="line">        p.setProperty(<span class="string">"cxy"</span>, <span class="string">"tsx"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"ch.cxf"</span>, <span class="string">"china"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"en"</span>, <span class="string">"english"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"world"</span>, <span class="string">"世界"</span>);</span><br><span class="line">        <span class="comment">// 将属性文件持久化到外存中。</span></span><br><span class="line">        File exportFile = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"config.properties"</span>); </span><br><span class="line">        p.store(<span class="keyword">new</span> FileOutputStream(exportFile), <span class="string">"Hello World"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属性文件是纯文本格式的，属性文件的名称和后缀名可以任意设定。</span></span><br><span class="line"><span class="comment">// 但是通常是“.properties”做为文件的后缀名。</span></span><br><span class="line"><span class="comment">// 使用setProperty()方法创建属性，然后将属性保存到Properties对象中。</span></span><br><span class="line"><span class="comment">// 使用store()方法将当前Properties对象中的数据写到外存中保存，此方法的第二个参数是当前属性文件的注释文字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的文件内容：</span></span><br><span class="line"><span class="comment">// #Hello World</span></span><br><span class="line"><span class="comment">// #Thu Sep 06 22:19:10 CST 2012</span></span><br><span class="line"><span class="comment">// en=english</span></span><br><span class="line"><span class="comment">// world=\u4E16\u754C</span></span><br><span class="line"><span class="comment">// cxy=tsx</span></span><br><span class="line"><span class="comment">// ch.cxf=china</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：XML格式文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个Properties对象。</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 创建属性。</span></span><br><span class="line">        p.setProperty(<span class="string">"cxy"</span>, <span class="string">"tsx"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"ch.cxf"</span>, <span class="string">"china"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"en"</span>, <span class="string">"english"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"world"</span>, <span class="string">"世界"</span>);</span><br><span class="line">        <span class="comment">// 将属性文件持久化到外存中。</span></span><br><span class="line">        File exportFile = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"config.xml"</span>);</span><br><span class="line">        p.storeToXML(<span class="keyword">new</span> FileOutputStream(exportFile), <span class="string">"Hello World"</span>,<span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的文件内容：</span></span><br><span class="line"><span class="comment">// &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="comment">// &lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&gt;</span></span><br><span class="line"><span class="comment">// &lt;properties&gt;</span></span><br><span class="line"><span class="comment">// &lt;comment&gt;Hello World&lt;/comment&gt;</span></span><br><span class="line"><span class="comment">// &lt;entry key="en"&gt;english&lt;/entry&gt;</span></span><br><span class="line"><span class="comment">// &lt;entry key="world"&gt;世界&lt;/entry&gt;</span></span><br><span class="line"><span class="comment">// &lt;entry key="cxy"&gt;tsx&lt;/entry&gt;</span></span><br><span class="line"><span class="comment">// &lt;entry key="ch.cxf"&gt;china&lt;/entry&gt;</span></span><br><span class="line"><span class="comment">// &lt;/properties&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：载入文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个Properties对象。</span></span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 将一个xml风格的配置文件导入进内存。</span></span><br><span class="line">        File importFile = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"config.xml"</span>);</span><br><span class="line">        <span class="comment">// 使用loadFromXML()方法导入XML风格的配置文件，将数据保存到当前Properties对象中。</span></span><br><span class="line">        <span class="comment">// 还有一个load()方法导入普通风格的配置文件。</span></span><br><span class="line">        p.loadFromXML(<span class="keyword">new</span> FileInputStream(importFile));</span><br><span class="line">        <span class="comment">// 若world属性不存在，则返回null。</span></span><br><span class="line">        System.out.println(p.get(<span class="string">"world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p><br>　　Collections类和Arrays类的性质是一样的，都是工具类。</p>
<pre><code>-  Arrays类提供了一些对数组进行操作的方法。
-  Collections类提供了一些对集合进行操作的方法，其内全部都是静态方法。
</code></pre><p>　　范例1：排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.7"</span>);</span><br><span class="line">        array.add(<span class="string">"No.6"</span>);</span><br><span class="line">        array.add(<span class="string">"No.5"</span>);</span><br><span class="line">        array.add(<span class="string">"No.4"</span>);</span><br><span class="line">        array.add(<span class="string">"No.3"</span>);</span><br><span class="line">        Collections.sort(array);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　范例2：填充元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.7"</span>);</span><br><span class="line">        array.add(<span class="string">"No.6"</span>);</span><br><span class="line">        array.add(<span class="string">"No.5"</span>);</span><br><span class="line">        array.add(<span class="string">"No.4"</span>);</span><br><span class="line">        array.add(<span class="string">"No.3"</span>);</span><br><span class="line">        Collections.fill(array,<span class="string">"Hello World"</span>);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　范例3：增加元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.7"</span>);</span><br><span class="line">        array.add(<span class="string">"No.6"</span>);</span><br><span class="line">        array.add(<span class="string">"No.5"</span>);</span><br><span class="line">        Collections.addAll(array,<span class="string">"Hello World"</span>,<span class="string">"Tomcat"</span>,<span class="string">"JimDog"</span>);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　范例4：折半查找。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        array.add(<span class="string">"No.7"</span>);</span><br><span class="line">        array.add(<span class="string">"No.6"</span>);</span><br><span class="line">        array.add(<span class="string">"No.5"</span>);</span><br><span class="line">        array.add(<span class="string">"Tomcat"</span>);</span><br><span class="line">        array.add(<span class="string">"JimDog"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Tomcat的下标为："</span></span><br><span class="line">             + Collections.binarySearch(array, <span class="string">"Tomcat"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　范例5：逆序排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">        array.add(<span class="number">3</span>);       array.add(<span class="number">1</span>);</span><br><span class="line">        array.add(<span class="number">9</span>);       array.add(<span class="number">33</span>);</span><br><span class="line">        Collections.sort(array);      <span class="comment">// 升序排序。</span></span><br><span class="line">        System.out.println(<span class="string">"升序排序："</span>+array);</span><br><span class="line">        Collections.reverse(array);  <span class="comment">// 反转集合,即首尾元素依次交换位置。</span></span><br><span class="line">        System.out.println(<span class="string">"降序排序："</span>+array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="进阶特性"><a href="#进阶特性" class="headerlink" title="进阶特性"></a>进阶特性</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>　　在Java世界中，万物皆对象，比如“人类”可以使用Person类来表示，Person类中有age、name、sex等属性。如果继续深入一下的话，也许您会提出另一个问题，“你不是说万物皆对象吗？那好，我问你，人类可以用Person来表示，那Person类生成的字节码，用什么表示？别给我说木有”，这个…确实有东西可以表示，它就是咱们所说的“Class”类。</p>
<pre><code>简单的说，Class类的对象就是代表经过编译后生成字节码文件，仔细观察一下API就知道，Class描述的是类的结构，比如：构造方法、成员方法、成员变量等等。
也就是说，接下来通过反射机制所要研究的，是“类的结构”，而不是“类的内容”。
</code></pre><p>　　提示：反射是十分重要的，它在Java的很多技术中被广泛的使用，如EL表达式、标签编程、JavaBean等，所以研究并深刻理解反射机制是十分必要的。</p>
<p><br>　　范例1：获取Class对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种方式，通过forName方法获取Class对象。</span></span><br><span class="line">        <span class="comment">// 加载指定的类到内存中（若已再内存则不会重复加载），然后实例化对应的Class类。</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"cxy.zy.reflect.Person"</span>);  </span><br><span class="line">        <span class="comment">// getName方法返回该Class对象所表示的类的类名。</span></span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种方式，直接通过“类名.class”来获取Class对象。</span></span><br><span class="line">        cls = Person.class;  </span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种方式，通过“对象.getClass()”实例化Class类。</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">50</span>);</span><br><span class="line">        Class&lt;?&gt; cls = p.getClass();</span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：字节码比较。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls1 = <span class="string">"abc"</span>.getClass();</span><br><span class="line">        Class&lt;String&gt; cls2 = String.class;</span><br><span class="line">        Class cls3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        <span class="comment">// 每个类的字节码，在内存中只会存在一份。</span></span><br><span class="line">        <span class="comment">// 执行结果：true、true、true</span></span><br><span class="line">        System.out.println(cls1 == cls2);</span><br><span class="line">        System.out.println(cls1 == cls3);</span><br><span class="line">        System.out.println(cls2 == cls3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java中内置了9种Class对象：8中基本数据类型与void类型。</span></span><br><span class="line">        <span class="comment">// isPrimitive判定指定的Class对象是否表示内置的9种Class字节码。</span></span><br><span class="line">        System.out.println(<span class="keyword">int</span>.class.isPrimitive());     <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="keyword">int</span>[].class.isPrimitive());   <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="keyword">int</span>[].class.isArray());       <span class="comment">// true</span></span><br><span class="line">        System.out.println(Integer.class.isPrimitive()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="keyword">void</span>.class.isPrimitive());    <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 判断int和Integer是否具有相同的字节码。</span></span><br><span class="line">        System.out.println(<span class="keyword">int</span>.class == Integer.class);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="keyword">int</span>.class == Integer.TYPE);   <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：实例化Person类对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"cxy.zy.reflect.Person"</span>);  </span><br><span class="line">        <span class="comment">// 调用Person类的无参构造方法，实例化对象。</span></span><br><span class="line">        <span class="comment">// 若Person类中没有无参的构造方法，则运行的时候会抛异常。</span></span><br><span class="line">        Person p = (Person)cls.newInstance();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：获取父类和接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);  </span><br><span class="line">        <span class="comment">// 获取String的父类</span></span><br><span class="line">        Class&lt;?&gt; sup = cls.getSuperclass(); </span><br><span class="line">        <span class="comment">// 输出：java.lang.Object</span></span><br><span class="line">        System.out.println(sup.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取String所实现的接口</span></span><br><span class="line">        Class&lt;?&gt; inter[] = cls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; temp : inter)&#123;</span><br><span class="line">            System.out.println(temp.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// java.io.Serializable</span></span><br><span class="line">        <span class="comment">// java.lang.Comparable</span></span><br><span class="line">        <span class="comment">// java.lang.CharSequence</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p><br>　　引言：每个类都有一个或多个构造方法，每个构造方法，都可以使用Constructor类来表示。</p>
<p>　　范例1：获取所有构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = String.class;  </span><br><span class="line">        <span class="comment">// 获取该类的所有构造方法。</span></span><br><span class="line">        Constructor&lt;?&gt;[] con = cls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c:con)&#123;</span><br><span class="line">            System.out.print(c.getName()+<span class="string">"("</span>);</span><br><span class="line">            <span class="comment">// 获得该构造方法的，所有参数的类型。</span></span><br><span class="line">            <span class="keyword">for</span>(Class temp : c.getParameterTypes())&#123;</span><br><span class="line">                System.out.print(temp.getName()+<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：调用指定的构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;String&gt; cls = String.class;</span><br><span class="line">        <span class="comment">// 获得String类中，具有一个String参数的构造方法。</span></span><br><span class="line">        <span class="comment">// 若要调用无参的构造方法，则不需传递参数或传递null。</span></span><br><span class="line">        Constructor&lt;String&gt; con = cls.getConstructor(String.class);</span><br><span class="line">        <span class="comment">// 调用这个构造方法，并给这个构造方法传递一个String参数。</span></span><br><span class="line">        String str = con.newInstance(<span class="string">"黑马"</span>);</span><br><span class="line">        <span class="comment">// 输出结果。</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：拆分构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);  </span><br><span class="line">        Constructor&lt;?&gt; con[] = cls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor&lt;?&gt; temp : con)&#123;</span><br><span class="line">            <span class="comment">// 获得方法的修饰符</span></span><br><span class="line">            String mod = Modifier.toString(temp.getModifiers());</span><br><span class="line">            String name = temp.getName();  <span class="comment">//获得方法名称</span></span><br><span class="line">            Class&lt;?&gt; param[] = temp.getParameterTypes(); <span class="comment">//获得参数列表</span></span><br><span class="line">            System.out.print(mod+<span class="string">" "</span>+name+<span class="string">"("</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;param.length;i++)&#123;</span><br><span class="line">                System.out.print(param[i].getName()+<span class="string">" p"</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i&lt;param.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p><br>　　引言：每个类一般都有若干个属性，每个属性都可以使用Field类来表示。</p>
<p>　　范例1：获取所有属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 使用getFields()或getField()方法，仅能访问到，该类的public属性。</span></span><br><span class="line">        Field[] arr = Point.class.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f:arr)&#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回包括公共、保护、默认（包）访问和私有字段，但不包括继承的字段。</span></span><br><span class="line">        <span class="comment">// 此方法只可以访问private的属性，不可以修改其值。</span></span><br><span class="line">        arr = Point.class.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f:arr)&#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：访问与修改属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Field field = Person.class.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 使用setAccessible方法，就可以修改private类型的属性。</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(p, <span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(field.get(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：替换字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        <span class="comment">// 列出所有的属性。</span></span><br><span class="line">        Field[] array = Point.class.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 遍历每个属性。</span></span><br><span class="line">        <span class="keyword">for</span>(Field temp : array)&#123;</span><br><span class="line">            <span class="comment">// 扩大当前属性的访问权限。</span></span><br><span class="line">            temp.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 若属性是String类型的。</span></span><br><span class="line">            <span class="keyword">if</span>(temp.getType() == String.class)&#123;</span><br><span class="line">                <span class="comment">// 进行替换操作</span></span><br><span class="line">                temp.set(p,((String)temp.get(p)).replace(<span class="string">'a'</span>,<span class="string">'C'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不论是否替换,都将结果输出。</span></span><br><span class="line">            System.out.println(temp.get(p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">"aaaaaabbbbbabab"</span>;</span><br><span class="line">    <span class="keyword">private</span> String b = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">private</span> String c = <span class="string">"bb"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><br>　　引言：每个类一般都有若干个方法，每个方法都可以使用Method类来表示。</p>
<p>　　范例1：获取指定的函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// getMethods()方法可以获得当前类中的所有的方法。</span></span><br><span class="line">    <span class="comment">// getMethod()方法可以获得某个具体的方法。</span></span><br><span class="line">    <span class="comment">// 找到String类中的matches方法，由于可能存在方法重载，因此需要指出该方法参数列表。</span></span><br><span class="line">    Method m = String.class.getMethod(<span class="string">"matches"</span>, String.class);</span><br><span class="line">    <span class="comment">// 使用invoke方法，执行方法的调用，第一个参数是表示在哪个对象身上调用此方法。</span></span><br><span class="line">    <span class="comment">// 调用对象“12345”的matches方法，进行正则表达式验证，\\d+是传递给方法的参数。</span></span><br><span class="line">    System.out.println(m.invoke(<span class="string">"12345"</span>,<span class="string">"\\d+"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法不依附与某个对象，所以第一个参数可以传递null。</span></span><br><span class="line">    Method m = Math.class.getMethod(<span class="string">"pow"</span>,<span class="keyword">double</span>.class,<span class="keyword">double</span>.class);</span><br><span class="line">    System.out.println(m.invoke(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：泛型不是万能的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Method m = ArrayList.class.getMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">        m.invoke(list,<span class="string">"cxy"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先，“泛型是专门给编译器看的，编译结束后，ArrayList&lt;Integer&gt;中的&lt;Integer&gt;会被删除”。</span></span><br><span class="line"><span class="comment">// 然后，利用反射，就可以将String对象，插入到ArrayList&lt;Integer&gt;中。</span></span><br><span class="line"><span class="comment">// 最后，调用add方法时，参数的类型为“Object.class”。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：拆分方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);  </span><br><span class="line">        Method[] method = cls.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : method)&#123;</span><br><span class="line">            <span class="comment">// 方法的修饰符</span></span><br><span class="line">            String mod = Modifier.toString(m.getModifiers());                 </span><br><span class="line">            String name = m.getName(); <span class="comment">// 方法的名称</span></span><br><span class="line">            Class&lt;?&gt; reType = m.getReturnType(); <span class="comment">// 方法返回值类型</span></span><br><span class="line">            Class&lt;?&gt; excep[] = m.getExceptionTypes();<span class="comment">//方法可能抛出的异常</span></span><br><span class="line">            Class&lt;?&gt; param[] = m.getParameterTypes(); <span class="comment">//方法的参数列表</span></span><br><span class="line">            System.out.print(mod+<span class="string">" "</span>+reType.getName()+<span class="string">" "</span>+name+<span class="string">"("</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;param.length;i++)&#123;</span><br><span class="line">                System.out.print(param[i].getName()+<span class="string">" args-"</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i&lt;param.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">if</span>(excep.length&gt;<span class="number">0</span>)&#123;   <span class="comment">//如果抛出了异常</span></span><br><span class="line">                System.out.print(<span class="string">" throws "</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;excep.length;j++)&#123;</span><br><span class="line">                    System.out.print(excep[j].getName());</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;excep.length-<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(<span class="string">","</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：反射私有方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.cxy.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0-------0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; cls = </span><br><span class="line">            (Class&lt;Person&gt;) Class.forName(<span class="string">"org.cxy.reflect.Person"</span>);</span><br><span class="line">        Person p =  cls.newInstance();</span><br><span class="line">        Method m = cls.getDeclaredMethod(<span class="string">"print"</span>, <span class="keyword">null</span>);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：反射带有数组参数的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;MethodDemo&gt; cls = MethodDemo.class;</span><br><span class="line">        <span class="comment">// 获得方法对象。</span></span><br><span class="line">        Method m = cls.getMethod(<span class="string">"aaa"</span>, String[].class);</span><br><span class="line">        <span class="comment">// 错误!</span></span><br><span class="line">        <span class="comment">// m.invoke(null, new String[]&#123;"123","456"&#125;);</span></span><br><span class="line">        <span class="comment">// 正确!</span></span><br><span class="line">        m.invoke(<span class="keyword">null</span>, (Object)<span class="keyword">new</span> String[]&#123;<span class="string">"123"</span>,<span class="string">"456"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aaa</span><span class="params">(String[] array)</span></span>&#123;</span><br><span class="line">        System.out.println(Arrays.asList(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// invoke的方法原型为：</span></span><br><span class="line"><span class="comment">// public Object invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">// 第二个参数是可变参数，若直接传递new String[]&#123;"123","456"&#125;给invoke方法，则会去调用aaa(String a1,String a2)，结果自然是找不到。</span></span><br><span class="line"><span class="comment">// 因此需要将String[]转换成Object，以此来告诉JVM 调用具有一个String[]类型参数的aaa方法。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><br>　　枚举可以限制一个内容的取值范围。如： </p>
<pre><code>-  限制性别的取值只能是：男、女。
-  限制一周只能有7天。
-  限制三基色只能为：红、绿、蓝。
</code></pre><p><br>　　范例1：定义枚举类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用enum关键字来定义一个枚举类Color，该类的引用变量取值只能为RED、GREEN、BLUE三者之一。</span></span><br><span class="line"><span class="comment">// 其中RED、GREEN、BLUE被称为枚举常量，每个枚举常量都是一个“static”的。 </span></span><br><span class="line"><span class="comment">// 使用enum关键字定义的枚举类，同样会产生一个.class文件。 </span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Color c = Color.RED;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="comment">// values()方法可以获取所有枚举常量</span></span><br><span class="line">        <span class="keyword">for</span> (Color item : Color.values()) &#123;</span><br><span class="line">            <span class="comment">// 枚举常量的名称和下标</span></span><br><span class="line">            System.out.println(item.name() + <span class="string">" --&gt; "</span> + item.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序输出：</span></span><br><span class="line">        <span class="comment">// RED</span></span><br><span class="line">        <span class="comment">// RED --&gt; 0</span></span><br><span class="line">        <span class="comment">// GREEN --&gt; 1</span></span><br><span class="line">        <span class="comment">// BLUE --&gt; 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：枚举常量与switch。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Color c1 = Color.BLUE;</span><br><span class="line">        <span class="keyword">switch</span> (c1) &#123;</span><br><span class="line">            <span class="comment">// 在case后面的枚举常量，不能写成“Color.RED”，只能写成“RED”。</span></span><br><span class="line">            <span class="keyword">case</span> RED: &#123;</span><br><span class="line">                System.out.println(<span class="string">"红色"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> GREEN: &#123;</span><br><span class="line">                System.out.println(<span class="string">"绿色"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BLUE: &#123;</span><br><span class="line">                System.out.println(<span class="string">"蓝色"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在枚举类中可以定义构造方法，每个枚举常量都会默认调用无参的构造方法，</span></span><br><span class="line"><span class="comment">// 如果没有无参的构造方法，则需要为每一个枚举常量指明要调用哪一个构造方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color&#123;</span><br><span class="line">    RED(<span class="string">"红色"</span>),GREEN(<span class="string">"绿色"</span>),BLUE; <span class="comment">//若枚举常量后还有其他，则这个分号必须加上。</span></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 属性的定义位置必须要在枚举常量之后。</span></span><br><span class="line">    Color()&#123;&#125;  <span class="comment">//构造方法不可以是public的，因为构造器只需要被枚举常量调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// name()方法是Enum类自有的，用于返回枚举常量的字面名称。</span></span><br><span class="line">        <span class="comment">// name字段是咱们自定义的。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name == <span class="keyword">null</span>? <span class="keyword">this</span>.name():<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例4：抽象方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在枚举中可以定义抽象方法，但是每一个枚举对象都必须分别重写此抽象方法。</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED(<span class="string">"红"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 可以在方法中引用字段，但字段不能用private修饰。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我的名字是："</span> + title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    GREEN(<span class="string">"绿"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我的名字是："</span> + title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    BLUE(<span class="string">"蓝"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我的名字是："</span> + title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    String title;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Color.RED.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类也可以实现某个接口，实现的方式和普通类一样。</span></span><br><span class="line"><span class="comment">// 既可以在枚举类中直接重写接口中的抽象方法，也可以像本范例这样让每个枚举常量分别重写。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例5：集合的支持。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在枚举中可以定义抽象方法，但是每一个枚举对象都必须分别重写此抽象方法。</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 枚举Set集合</span></span><br><span class="line">        EnumSet&lt;Color&gt; set = EnumSet.allOf(Color.class);</span><br><span class="line">        Iterator&lt;Color&gt; iter = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举Map集合</span></span><br><span class="line">        EnumMap&lt;Color, String&gt; em = <span class="keyword">new</span> EnumMap&lt;Color, String&gt;(Color.class);</span><br><span class="line">        em.put(Color.BLUE, <span class="string">"蓝色1"</span>);</span><br><span class="line">        em.put(Color.BLUE, <span class="string">"蓝色2"</span>);</span><br><span class="line">        em.put(Color.GREEN, <span class="string">"绿色"</span>);</span><br><span class="line">        em.put(Color.RED, <span class="string">"红色"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Color, String&gt; map : em.entrySet()) &#123;</span><br><span class="line">            System.out.println(map.getKey() + <span class="string">" "</span> + map.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提示：也可以通过枚举类来实现单例设计模式。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><br>　　Java中每个对象都存在引用，外界可以通过对象的引用来操作存在于堆中的对象。<br>　　为了更好的管理JVM内存，防止出现内存泄漏甚至是程序抛出OOM的错误，从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<pre><code>内存泄漏：通俗的说，堆中存在很多已经无用的空间(对象)，这些空间(对象)在被使用过后，其引用并没有释放，而是还被外界的某个变量所持有，这导致垃圾回收器无法回收该对象，这种系统中明明存在可用的内存空间，却偏偏不能使用的情况称为内存泄漏。

内存溢出(OOM, Out of Memory)：当JVM中的内存不够使用的时候，会抛出java.lang.OutOfMemoryError错误。若内存泄漏严重或者加载过大的数据(如从磁盘加载图片到程序中)，最终就会导致OOM的发生。
</code></pre><p><br>　　范例1：之前一直都是强引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> StringBuilder sub;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 变量sub与StringBuilder对象关系就是强引用关系。</span></span><br><span class="line">        <span class="comment">// GC试图回收某个对象时，会检查外界是否有变量持有该对象的强引用，若无才会回收。</span></span><br><span class="line">        <span class="comment">// 当内存空间不足，JVM宁愿抛出OutOfMemoryError错误使程序异常终止，</span></span><br><span class="line">        <span class="comment">// 也不会靠随意回收具有强引用的对象来解决内存不足问题。</span></span><br><span class="line">        <span class="comment">// 因此若sub不被置null则StringBuilder对象将永远不会被GC当作垃圾给回收掉。</span></span><br><span class="line">        sub = <span class="keyword">new</span> StringBuilder(<span class="string">"str"</span>);</span><br><span class="line">        System.out.println(sub);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　在Java中软引用、弱引用、虚引用每种引用对象类型都是通过抽象的基本 Reference 类的一个子类实现的，三种引用的区别仅仅是在何种场合下去回收指示对象。</p>
<pre><code>-  强引用：是Java程序中最普遍的，只要强引用还存在，GC宁愿抛OOM也不会回收掉被引用的对象。
-  软引用：若对象存在强引用，则对象不会被GC回收，同时它的软引用也不会返回空，否则GC会在系统内存不够用时回收该对象，当该对象被回收后，它的软引用将返回空。需要注意的是，软引用返回空有两个条件：系统内存不足和对象没有强引用；只满足某一条是不行的，比如若对象只是没有强引用时你主动调用gc后，你立刻访问软引用所引用的对象，是可以获取到该对象的。
-  弱引用：它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。若对象存在强引用则不会回收弱引用。
-  虚引用：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。
</code></pre><p><br>　　范例2：测试软引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行本代码之前，请将虚拟机堆内存的最大容量设置为20M，使用下面的参数即可：</span></span><br><span class="line">    <span class="comment">// -Xmx20M</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 申请一个占据10M内存的字节数组，并赋值给一个强引用</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 再使用一个软引用包裹住字节数组</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; soft = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(data);</span><br><span class="line">        <span class="comment">// 由于此时的字节数组身上有两个引用：一个强引用、一个软引用，且虚拟机当前内存足够。</span></span><br><span class="line">        <span class="comment">// 所以下面代码可以获取到字节数组的引用。</span></span><br><span class="line">        System.out.println(soft.get());</span><br><span class="line">        <span class="comment">// 此代码用来断开强引用。</span></span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 再次申请10M内存，由于上面强引用被断开了，所以那片空间就可以被回收了。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 下面会输出null</span></span><br><span class="line">        System.out.println(soft.get());</span><br><span class="line">        <span class="comment">// 如果把第13行代码删掉，不去断开强引用，那么虚拟机宁愿抛出OOM，也不会回收软引用。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相应的还有：</span></span><br><span class="line"><span class="comment">// 弱引用：WeakReference</span></span><br><span class="line"><span class="comment">// 虚引用：PhantomReference</span></span><br></pre></td></tr></table></figure></p>
<p><br><br></p>

      
    </div>

    <footer class="post-footer">
      

      
      
    </footer>
  </article>


  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="language-002/"
           data-title="第二章 Java语言" data-url="http://yoursite.com/language-002/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="键盘" />
          <p class="site-author-name" itemprop="name">键盘</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://weishu.me/" title="weishu" target="_blank">weishu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ryanhoo.github.io/" title="ryanhoo" target="_blank">ryanhoo</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础入门"><span class="nav-number">1.</span> <span class="nav-text">基础入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语言概述"><span class="nav-number">1.1.</span> <span class="nav-text">语言概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级语言"><span class="nav-number">1.2.</span> <span class="nav-text">高级语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程基础"><span class="nav-number">1.3.</span> <span class="nav-text">编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量"><span class="nav-number">1.3.1.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用常识"><span class="nav-number">1.3.2.</span> <span class="nav-text">通用常识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">1.3.3.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.3.4.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程控制"><span class="nav-number">1.3.5.</span> <span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">1.3.6.</span> <span class="nav-text">数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象基础"><span class="nav-number">2.</span> <span class="nav-text">面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象和面向过程"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象和面向过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">2.2.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类与对象"><span class="nav-number">2.2.1.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">2.2.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">2.2.3.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义一个类"><span class="nav-number">2.2.4.</span> <span class="nav-text">定义一个类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存简述"><span class="nav-number">2.2.5.</span> <span class="nav-text">内存简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码块"><span class="nav-number">2.2.6.</span> <span class="nav-text">代码块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承"><span class="nav-number">2.3.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法重写与属性隐藏"><span class="nav-number">2.4.</span> <span class="nav-text">方法重写与属性隐藏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字final"><span class="nav-number">2.5.</span> <span class="nav-text">关键字final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类"><span class="nav-number">2.6.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">2.7.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">2.8.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象实例化与类加载"><span class="nav-number">2.9.</span> <span class="nav-text">对象实例化与类加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">2.10.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包机制"><span class="nav-number">2.11.</span> <span class="nav-text">包机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jar命令"><span class="nav-number">2.12.</span> <span class="nav-text">Jar命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类库基础"><span class="nav-number">3.</span> <span class="nav-text">类库基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础类"><span class="nav-number">3.1.</span> <span class="nav-text">基础类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">3.1.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-number">3.1.2.</span> <span class="nav-text">Object</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统类"><span class="nav-number">3.2.</span> <span class="nav-text">系统类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime"><span class="nav-number">3.2.1.</span> <span class="nav-text">Runtime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System"><span class="nav-number">3.2.2.</span> <span class="nav-text">System</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工具类"><span class="nav-number">3.3.</span> <span class="nav-text">工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用工具"><span class="nav-number">3.3.1.</span> <span class="nav-text">常用工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期处理"><span class="nav-number">3.3.2.</span> <span class="nav-text">日期处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它工具"><span class="nav-number">3.3.3.</span> <span class="nav-text">其它工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#国际化类"><span class="nav-number">3.4.</span> <span class="nav-text">国际化类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Locale"><span class="nav-number">3.4.1.</span> <span class="nav-text">Locale</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定文本元素"><span class="nav-number">3.4.2.</span> <span class="nav-text">固定文本元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态文本元素"><span class="nav-number">3.4.3.</span> <span class="nav-text">动态文本元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-number">3.5.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#是什么？"><span class="nav-number">3.5.1.</span> <span class="nav-text">是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法"><span class="nav-number">3.5.2.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组"><span class="nav-number">3.5.3.</span> <span class="nav-text">组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#零宽断言"><span class="nav-number">3.5.4.</span> <span class="nav-text">零宽断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪婪和懒惰"><span class="nav-number">3.5.5.</span> <span class="nav-text">贪婪和懒惰</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程基础"><span class="nav-number">4.</span> <span class="nav-text">多线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">4.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的实现"><span class="nav-number">4.2.</span> <span class="nav-text">线程的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步"><span class="nav-number">4.3.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程死锁"><span class="nav-number">4.4.</span> <span class="nav-text">线程死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者与消费者"><span class="nav-number">4.5.</span> <span class="nav-text">生产者与消费者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timer"><span class="nav-number">4.6.</span> <span class="nav-text">Timer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">4.7.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UncaughtExceptionHandler"><span class="nav-number">4.8.</span> <span class="nav-text">UncaughtExceptionHandler</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaIO基础"><span class="nav-number">5.</span> <span class="nav-text">JavaIO基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IO常用类"><span class="nav-number">5.1.</span> <span class="nav-text">IO常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File"><span class="nav-number">5.1.1.</span> <span class="nav-text">File</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile"><span class="nav-number">5.1.2.</span> <span class="nav-text">RandomAccessFile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流"><span class="nav-number">5.2.</span> <span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流"><span class="nav-number">5.2.1.</span> <span class="nav-text">字节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符流"><span class="nav-number">5.2.2.</span> <span class="nav-text">字符流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">5.2.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象序列化"><span class="nav-number">5.3.</span> <span class="nav-text">对象序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他流类"><span class="nav-number">5.4.</span> <span class="nav-text">其他流类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#泛型"><span class="nav-number">6.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型引出"><span class="nav-number">6.1.</span> <span class="nav-text">泛型引出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通配符"><span class="nav-number">6.2.</span> <span class="nav-text">通配符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型方法"><span class="nav-number">6.3.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型接口"><span class="nav-number">6.4.</span> <span class="nav-text">泛型接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合"><span class="nav-number">7.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection接口"><span class="nav-number">7.1.</span> <span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List接口"><span class="nav-number">7.1.1.</span> <span class="nav-text">List接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set接口"><span class="nav-number">7.1.2.</span> <span class="nav-text">Set接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合输出"><span class="nav-number">7.1.3.</span> <span class="nav-text">集合输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map接口"><span class="nav-number">7.2.</span> <span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">7.2.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">7.2.2.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IdentityHashMap"><span class="nav-number">7.2.3.</span> <span class="nav-text">IdentityHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties"><span class="nav-number">7.2.4.</span> <span class="nav-text">Properties</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections"><span class="nav-number">7.3.</span> <span class="nav-text">Collections</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进阶特性"><span class="nav-number">8.</span> <span class="nav-text">进阶特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-number">8.1.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">8.1.1.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor"><span class="nav-number">8.1.2.</span> <span class="nav-text">Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Field"><span class="nav-number">8.1.3.</span> <span class="nav-text">Field</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method"><span class="nav-number">8.1.4.</span> <span class="nav-text">Method</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">8.2.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">8.3.</span> <span class="nav-text">引用</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">键盘</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
