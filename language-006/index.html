<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="http://www.gov.cn/" title="不只是看客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="第一节 起源概述面向JVM的语言　　我们知道在Java语言中，会将源代码编译成字节码，再依赖各种不同平台上的虚拟机（JVM）来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。同时，官方从很早以前就将JVM规范和Java规范分离开了，这意味着只要其他语言在编译过程中生成了字节码，那么照样可以通过JVM在不同平台上运行，这样一来这个语言就借着JVM拥有了跨平台能力。 由于是运行在JVM上的">
<meta property="og:type" content="article">
<meta property="og:title" content="第六章 Kotlin">
<meta property="og:url" content="http://yoursite.com/language-006/index.html">
<meta property="og:site_name" content="不只是看客">
<meta property="og:description" content="第一节 起源概述面向JVM的语言　　我们知道在Java语言中，会将源代码编译成字节码，再依赖各种不同平台上的虚拟机（JVM）来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。同时，官方从很早以前就将JVM规范和Java规范分离开了，这意味着只要其他语言在编译过程中生成了字节码，那么照样可以通过JVM在不同平台上运行，这样一来这个语言就借着JVM拥有了跨平台能力。 由于是运行在JVM上的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/language/language_kotlin_001.png">
<meta property="og:image" content="http://yoursite.com/img/language/language_kotlin_002.png">
<meta property="og:image" content="http://yoursite.com/img/language/language_kotlin_003.png">
<meta property="og:image" content="http://yoursite.com/img/language/language_kotlin_004.png">
<meta property="og:updated_time" content="2023-03-11T10:27:43.568Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第六章 Kotlin">
<meta name="twitter:description" content="第一节 起源概述面向JVM的语言　　我们知道在Java语言中，会将源代码编译成字节码，再依赖各种不同平台上的虚拟机（JVM）来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。同时，官方从很早以前就将JVM规范和Java规范分离开了，这意味着只要其他语言在编译过程中生成了字节码，那么照样可以通过JVM在不同平台上运行，这样一来这个语言就借着JVM拥有了跨平台能力。 由于是运行在JVM上的">
<meta name="twitter:image" content="http://yoursite.com/img/language/language_kotlin_001.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/language-006/"/>

  <title> 第六章 Kotlin | 不只是看客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">不只是看客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                第六章 Kotlin
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2023-01-11T11:38:15+08:00" content="2023-01-11">
              2023-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                    <span itemprop="name">编程语言</span>
                </span>

                
                

              
            </span>
          

          

          
          
             <span id="/language-006/" class="leancloud_visitors" data-flag-title="第六章 Kotlin">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一节-起源概述"><a href="#第一节-起源概述" class="headerlink" title="第一节 起源概述"></a>第一节 起源概述</h1><h2 id="面向JVM的语言"><a href="#面向JVM的语言" class="headerlink" title="面向JVM的语言"></a>面向JVM的语言</h2><p><br>　　我们知道在Java语言中，会将源代码编译成字节码，再依赖各种不同平台上的虚拟机（JVM）来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。同时，官方从很早以前就将JVM规范和Java规范分离开了，这意味着只要其他语言在编译过程中生成了字节码，那么照样可以通过JVM在不同平台上运行，这样一来这个语言就借着JVM拥有了跨平台能力。</p>
<pre><code>由于是运行在JVM上的，因此也可以使用Java语言开发的各类API
</code></pre><p>　　也就是说虽然Java语言已经足够强大、应用的场景足够广泛，但其还是会在某些特殊场景下力有不逮，于是一些有能力的组织、公司就专门针对那些场景开发了一套基于JVM的新语言，以此来解决各自的需求，同时可以借助JVM来实现跨平台。</p>
<p>　　目前除了Java外，运行在JVM之上的语言主要还有如下几种：</p>
<p>　　<strong>1、Kotlin</strong></p>
<pre><code>目前已正式成为Android官方支持开发语言。
</code></pre><p>　　<strong>2、Groovy</strong></p>
<pre><code>Apache组织的Groovy 1.0于2007年1月2日发布。
这门动态语言拥有类似Python、Ruby和Smalltalk中的一些特性，可以作为Java平台的脚本语言使用。
由于其运行在JVM上的特性，Groovy可以使用其他Java语言编写的库。
Groovy的语法与Java非常相似，大多数Java代码也符合Groovy的语法规则，尽管可能语义不同。
</code></pre><p>　　<strong>3、其它</strong></p>
<pre><code>Jython：是一种完整的语言，它是一个Python语言在Java中的完全实现，Jython不仅给你提供了Python的库，同时也提供了所有的Java类，这使其有一个巨大的资源库。
JRuby：是一个纯Java实现的Ruby解释器。通过JRuby你可以在JVM上直接运行Ruby程序，调用Java的类库。

除此之外还有：Scala、Fantom、Clojure、Rhino、Ceylon。
</code></pre><p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/20003582" target="_blank" rel="noopener">知乎 - 为什么很多语言选择在JVM上实现？</a></li>
<li><a href="https://segmentfault.com/a/1190000021901060" target="_blank" rel="noopener">不来了解下JVM支持的语言有哪些？</a></li>
</ul>
<h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><p><br>　　Kotlin（科特林）是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。</p>
<pre><code>JetBrains成立于2000年，是一家捷克的软件开发公司，该公司最为人所熟知的产品是Java编程语言开发撰写时所用的集成开发环境：IntelliJ IDEA。
2011年7月，JetBrains推出Kotlin项目，这是一个面向JVM的新语言，它已被开发一年之久。
2012年2月，JetBrains以Apache 2许可证开源此项目。
2016年2月15日，Kotlin v1.0发布，这被认为是第一个官方稳定版本。
2017年在Google I/O大会上，Google宣布在Android上为Kotlin提供一等支持。
2019年在Google I/O大会上，Google宣布今后将优先采用 Kotlin 进行 Android 开发。
</code></pre><p><br>　　谷歌为什么要选择Kotlin？主要是两个原因：</p>
<pre><code>1、谷歌和Oracle的诉讼官司。
2、Kotlin本身做的越来越好。
</code></pre><p><br>　　谷歌与Oracle的官司简述：</p>
<pre><code>1995年5月23日，Sun公司发布了Java，Java语言正式诞生。
1996年1月，第一个JDK1.0诞生。
2009年4月15日，Sun公司被收购前夕，正式发布OpenJDK(OracleJDK的开源版本，完全自由，开放源码)。
2009年4月20日，Oracle以74亿美元的价格收购了Sun。
由于此时期OpenJDK并不是很成熟，因此Google的Android系统是基于OracleJDK来开发的。

2010年9月，Oracle就Google侵权一事向法院提起了诉讼，要求谷歌赔偿88亿美元。

理由很简单，虽然根据协议Android使用的OracleJDK后自身也开源了，但它违反了Java“一次编译，到处运行”的核心理念，在Android修改了很多地方之后，除了源码兼容以外，编译之后的产物APK，是不能在其它的java环境下执行的，而此时Android还称自己的api是java，但其实这已经不符合java的规范了。

另外，安卓上的GUI部分是自己做的，跟java默认的api（也就是swing那些）完全不同，那其实这个就彻底分裂了java，java其实有两个部分，一个是安卓上的java，还有一个是其它的java，那这个就是oracle所不能容忍的，于是就希望Google不要继续只用java的api，或者干脆重新做一个语言，不要再用java了。

2018年3月，美国联邦巡回上诉法院裁决，Google侵犯了Oracle的版权。
2018年8月，Google提出上诉，但美国联邦上诉法院宣布拒绝重新审理此案。
</code></pre><p><br>　　谷歌官方介绍为什么要优先支持Kotlin：</p>
<pre><code>富有表现力且简洁：您可以使用更少的代码实现更多的功能。表达自己的想法，少编写样板代码。在使用Kotlin的专业开发者中，有67%的人反映其工作效率有所提高。

更安全的代码：Kotlin有许多语言功能，可帮助您避免null指针异常等常见编程错误，包含Kotlin代码的Android应用发生崩溃的可能性降低了20%。

可互操作：您可以在Kotlin代码中调用Java代码，或者在Java代码中调用Kotlin代码，Kotlin可完全与Java编程语言互操作，因此您可以根据需要在项目中添加任意数量的Kotlin代码。

结构化并发：Kotlin协程让异步代码像阻塞代码一样易于使用，协程可大幅简化后台任务管理，例如网络调用、本地数据访问等任务的管理。
</code></pre><p><br>　　正如上面介绍的，Kotlin确实存在很多语法糖与高级特性，好是真的好，但笔者认为对于刚入门的新手来说，记忆和理解这些语法糖和特性也是一个不小的挑战，请大家做好心理准备。</p>
<p>　　另外，我们需要了解的是，Kotlin能用于哪些开发？</p>
<pre><code>用于服务器开发，Kotlin非常适合开发服务器端应用程序，它可以让你编写简明且表现力强的代码，同时保持与现有基于Java的技术栈的完全兼容性以及平滑的学习曲线。

用于Android开发。

用于JavaScript开发，Kotlin/JS提供了转换Kotlin代码、Kotlin标准库的能力，并且兼容JavaScript的任何依赖项，Kotlin/JS的当前实现以ES5为目标。

用于原生开发，Kotlin/Native是一种将Kotlin代码编译为无需虚拟机就可运行的原生二进制文件的技术，Kotlin/Native 支持以下平台：iOS、tvOS、watchOS、Windows（MinGW）、安卓NDK。

用于数据科学、竞技程序设计。
</code></pre><center><br><img src="/img/language/language_kotlin_001.png" alt=""><br></center>

<p><br>　　最后，在百度百科上有这么一句“Jetbrains希望这个新语言能够推动IntelliJ IDEA的销售。”</p>
<pre><code>结合笔者学习完Kotlin语言后，得出一个猜测：
1、由于Kotlin是面向虚拟机的语言，且已经迭代多年，所以其和Java语言的相比，在性能上不会差太多。
2、Kotlin提供了非常多的语法糖和新特性，且其完全支持现有的Java类库，旨在讨好程序员。
3、Kotlin可以直接在IntelliJ上通过插件使用，程序员爱上了Kotlin，自然就有可能购买IntelliJ。
</code></pre><p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin" target="_blank" rel="noopener">百度百科 - Kotlin</a></li>
<li><a href="https://www.zhihu.com/question/453123507" target="_blank" rel="noopener">怎么看待谷歌（Google）赢得了跟甲骨文（Oracle）关于安卓使用 Java api 的官司？</a></li>
<li><a href="https://developer.android.google.cn/kotlin/first" target="_blank" rel="noopener">Android 的 Kotlin 优先方法</a></li>
<li><a href="https://book.kotlincn.net/" target="_blank" rel="noopener">Kotlin 官方文档 中文版</a></li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><br>　　从上文可知Kotlin不止可以用来开发Android，显然Kotlin开发的方式也不会只有一种：</p>
<pre><code>使用IntelliJ IDEA

使用Android Studio，开发Android应用程序的官方IDE，它是基于Intellij IDEA开发的IDE，因而其UI和功能都与后者高度相似。

使用Eclipse，需要手动安装Kotlin插件。

使用命令行（就像我们刚学Java时使用的“java”和“javac”来编译源代码一样，Kotlin也提供了两个类似的工具“kotlin”和“kotlinc”）。
</code></pre><p><br>　　由于我们是做Android开发，本文就以Android Studio为开发工具，介绍Kotlin的各类语法。<br>　　首当其冲的任务就是，让现有的老Android项目支持Kotlin语言：</p>
<pre><code>1、确保自己手上的AS是比较新的版本。
2、依次点击AS的菜单“Tool -&gt; Kotlin -&gt; Configure Kotlin in Project”。
3、然后按照弹出的对话框一步一步选择就可以了。
</code></pre><p>　　上面的操作，本质上就做了三件事：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在项目根build.gradle里添加kotlin插件 </span></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">'1.5.30'</span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在app的build.gradle最上方apply插件</span></span><br><span class="line">apply plugin: <span class="string">'kotlin-android'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在app的build.gradle里引入kotlin的标准库</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　接着随便找一个包，右键创建一个Kotlin文件（注意不是Kotlin类），写入如下代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用fun关键字定义一个名为main的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 控制台输出字符串</span></span><br><span class="line">    <span class="comment">// kotlin中语句的末尾不需要加“;”号</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<center><br><img src="/img/language/language_kotlin_002.png" alt=""><br></center>

<pre><code>语句解释：
-  如果你的函数名字叫“main”，那么在其左侧就会出现一个绿色三角号，点击可以直接执行该函数。
-  Kotlin的源文件以“kt”为后缀名。
</code></pre><h1 id="第二节-Kotlin入门"><a href="#第二节-Kotlin入门" class="headerlink" title="第二节 Kotlin入门"></a>第二节 Kotlin入门</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p><br>　　范例1：你叫什么啊。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输出字符串，并换行。</span></span><br><span class="line">    println(<span class="string">"你好，你叫什么？"</span>)</span><br><span class="line">    <span class="comment">// 从标准输入流System.in中读取一行用户输入。</span></span><br><span class="line">    println(<span class="string">"啊，你叫"</span> + readLine() + <span class="string">"啊"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面用到的print、println、readLine都是kotlin内置的函数，它们被放到“kotlin.io”包中。</span></span><br><span class="line"><span class="comment">以下多个包会默认导入到每个Kotlin文件中：</span></span><br><span class="line"><span class="comment">kotlin.*</span></span><br><span class="line"><span class="comment">kotlin.annotation.*</span></span><br><span class="line"><span class="comment">kotlin.collections.*</span></span><br><span class="line"><span class="comment">kotlin.comparisons.*</span></span><br><span class="line"><span class="comment">kotlin.io.*</span></span><br><span class="line"><span class="comment">kotlin.ranges.*</span></span><br><span class="line"><span class="comment">kotlin.sequences.*</span></span><br><span class="line"><span class="comment">kotlin.text.*</span></span><br><span class="line"><span class="comment">根据目标平台还会导入额外的包：</span></span><br><span class="line"><span class="comment">JVM：</span></span><br><span class="line"><span class="comment">    java.lang.*</span></span><br><span class="line"><span class="comment">    kotlin.jvm.*</span></span><br><span class="line"><span class="comment">JS：</span></span><br><span class="line"><span class="comment">    kotlin.js.*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><br>　　Kotlin中提供如下几种基本数据类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数字：</span></span><br><span class="line"><span class="comment">    整数类型：Byte、Short、Int、Long</span></span><br><span class="line"><span class="comment">    浮点类型：Float、Double</span></span><br><span class="line"><span class="comment">    无符号整型：UByte、UShort、UInt、ULong</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">布尔：使用Boolean类来表示，取值true、false。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符：使用Char类来表示，字符字面值用单引号括起来，特殊字符可以以转义反斜杠“\”开始，如“\n”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串：</span></span><br><span class="line"><span class="comment">使用String类来表示，字符串值用双引号括起来，字符串是不可变的，一旦初始化了一个字符串，</span></span><br><span class="line"><span class="comment">就不能改变它的值或者给它赋新值，所有转换字符串的操作都以一个新的String对象来返回结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数组：使用Array类来表示。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例1：定义变量。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Kotlin中有两种变量：可变变量和不可变变量</span></span><br><span class="line">    <span class="comment">// 前者使用var定义，此类变量可以任意修改其值</span></span><br><span class="line">    <span class="comment">// 后者使用val定义，此类变量只可以赋值1次，若赋值成功后再次尝试修改，则编译报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义变量的语法格式为：</span></span><br><span class="line">    <span class="comment">// var/val &lt;变量名&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a: <span class="built_in">Byte</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="built_in">Short</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="built_in">Int</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> d: <span class="built_in">Long</span> = <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> s: String = <span class="string">"Hello"</span></span><br><span class="line">    println(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> f: <span class="built_in">Byte</span> = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 下面语句会编译报错，因为f是不可变量</span></span><br><span class="line">    f = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var全称为：variable</span></span><br><span class="line"><span class="comment">// val全称为：value，使用val定义的局部变量相当于Java中的final关键词。</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：自动推算类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量的时候，通常编译器可以依据等号右侧的数据来推测出变量的类型。</span></span><br><span class="line">    <span class="comment">// 因此我们学到的第一个语法糖就是，定义变量时可以省写变量的类型。</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>              <span class="comment">// Int类型</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">"Hello"</span>        <span class="comment">// String类型</span></span><br><span class="line">    println(a)</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：整型数据。</p>
<center><br><img src="/img/language/language_kotlin_003.png" alt=""><br></center>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当初始化一个没有显式指定类型的变量时，编译器会自动推断为足以表示该值的最小类型。 </span></span><br><span class="line">    <span class="comment">// 如果不超过Int的表示范围，那么类型是Int。 </span></span><br><span class="line">    <span class="comment">// 如果超过了，那么类型是Long。 </span></span><br><span class="line">    <span class="comment">// 如需显式指定Long值，请给该值追加后缀L。</span></span><br><span class="line">    <span class="comment">// 显式指定类型会触发编译器检测该值是否超出指定类型的表示范围。</span></span><br><span class="line">    <span class="keyword">val</span> one = <span class="number">1</span>                     <span class="comment">// Int</span></span><br><span class="line">    <span class="keyword">val</span> threeBillion = <span class="number">3000000000</span>   <span class="comment">// Long</span></span><br><span class="line">    <span class="keyword">val</span> oneLong = <span class="number">1</span>L                <span class="comment">// Long</span></span><br><span class="line">    <span class="keyword">val</span> oneByte: <span class="built_in">Byte</span> = <span class="number">1</span>           <span class="comment">// 明确指出变量是Byte类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Int等类被放到了kotlin包下，因而我们可以直接使用到。</span></span><br><span class="line">    <span class="comment">// Int类内部定义了几个实用常量，MAX_VALUE见名知意了吧？</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">Int</span>.MAX_VALUE + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 输出：2147483647</span></span><br><span class="line">    println(a)</span><br><span class="line">    <span class="comment">// 输出：-2147483648，发生数据溢出，阴极必反。</span></span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想查看某个变量当前是什么类型，把鼠标划到变量名上方，稍等一会AS就会弹框告知你</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例4：浮点数据。</p>
<center><br><img src="/img/language/language_kotlin_004.png" alt=""><br></center>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> d1 = <span class="number">3.14</span>       <span class="comment">// Double</span></span><br><span class="line">    <span class="keyword">val</span> f1 = <span class="number">1.0</span>f       <span class="comment">// Float</span></span><br><span class="line">    <span class="keyword">val</span> n1 = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与一些其他语言不同，Kotlin中的数字没有隐式拓宽转换。</span></span><br><span class="line">    <span class="comment">// 例如，Double类型的变量只能接受Double值，而不能将Float、Int或者其他数字赋值。</span></span><br><span class="line">    <span class="comment">// 错误：类型不匹配，因为1.2默认为Double</span></span><br><span class="line">    <span class="keyword">val</span> f2: <span class="built_in">Float</span> = <span class="number">1.2</span></span><br><span class="line">    <span class="comment">// 错误：类型不匹配，因为1f是Float</span></span><br><span class="line">    <span class="keyword">val</span> d2: <span class="built_in">Double</span> = <span class="number">1</span>f</span><br><span class="line">    <span class="comment">// 错误：类型不匹配，因为1默认为Int</span></span><br><span class="line">    <span class="keyword">val</span> d3: <span class="built_in">Double</span> = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 错误：类型不匹配，因为n1为Int</span></span><br><span class="line">    <span class="keyword">val</span> n2: <span class="built_in">Long</span> = n1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面定义的变量（n1、f1、d1），分别各自对应着一个Int、Float、Double等类的对象。</span></span><br><span class="line">    <span class="comment">// 以整型为例，在Kotlin中整型不再分为int和Integer了，统一用Int表示。</span></span><br><span class="line">    <span class="comment">// 这些类不是java.lang包的，而是Kotlin自有的类，它们被放在kotlin包下。</span></span><br><span class="line">    <span class="comment">// 这些类有一个共同父类kotlin.Number类，其内提供了若干实用函数。</span></span><br><span class="line">    <span class="keyword">val</span> f3 = <span class="number">1.2</span>f</span><br><span class="line">    <span class="keyword">val</span> d4: <span class="built_in">Double</span> = f3.toDouble()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：数字字面常量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 二进制常量，以“0b”开头，下面会输出3</span></span><br><span class="line">    println(<span class="number">0</span>b11)</span><br><span class="line">    <span class="comment">// 十六进制常量，以“0x”开头，下面会输出10</span></span><br><span class="line">    println(<span class="number">0xA</span>)</span><br><span class="line">    <span class="comment">// kotlin目前不支持八进制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数默认为Double类型，“e2”表示10的2次方，下面会输出12330.0</span></span><br><span class="line">    println(<span class="number">123.3e2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000</span><br><span class="line">    <span class="keyword">val</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</span><br><span class="line">    <span class="keyword">val</span> socialSecurityNumber = <span class="number">999</span>_99_9999L</span><br><span class="line">    <span class="keyword">val</span> hexBytes = <span class="number">0xFF</span>_EC_DE_5E</span><br><span class="line">    <span class="keyword">val</span> bytes = <span class="number">0</span>b11010010_01101001_10010100_10010010</span><br><span class="line">    <span class="comment">// 数字可以使用“_”间隔，下面代码将输出1000000</span></span><br><span class="line">    println(oneMillion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例6：无符号整型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数字后面带u则表示为无符号常量</span></span><br><span class="line">    <span class="keyword">var</span> a: UByte = <span class="number">1</span>u</span><br><span class="line">    <span class="keyword">var</span> b: UInt = <span class="number">2</span>u</span><br><span class="line">    <span class="keyword">var</span> c: UShort = <span class="number">3</span>u</span><br><span class="line">    <span class="keyword">var</span> d: ULong = <span class="number">4</span>u</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出：1</span></span><br><span class="line">    println(a)</span><br><span class="line">    <span class="comment">// 输出：4294967295</span></span><br><span class="line">    println(UInt.MAX_VALUE)</span><br><span class="line">    <span class="comment">// 输出：0</span></span><br><span class="line">    println(UInt.MAX_VALUE + <span class="number">1</span>u)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不指定类型，默认为UInt</span></span><br><span class="line">    <span class="keyword">var</span> e = <span class="number">1</span>u;</span><br><span class="line">    <span class="comment">// 不指定类型，默认为UInt，若常量超过了UInt的范围，则变量升级为ULong</span></span><br><span class="line">    <span class="keyword">val</span> f = <span class="number">0xFFFF</span>_FFFF_FFFFu</span><br><span class="line">    <span class="comment">// UL表示ULong类型</span></span><br><span class="line">    <span class="keyword">val</span> g = <span class="number">1</span>UL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例7：自动类型晋升。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 与Java一样，进行数学运算时，运算结果的类型为参与运算的两个数中范围最大的类型</span></span><br><span class="line">    <span class="comment">// 若参与运算的两个数，最高为Int，则结果必定为Int</span></span><br><span class="line">    <span class="keyword">var</span> a: <span class="built_in">Byte</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="built_in">Short</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> d: <span class="built_in">Long</span> = <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> f: <span class="built_in">Float</span> = <span class="number">1</span>f</span><br><span class="line">    <span class="keyword">var</span> g: <span class="built_in">Double</span> = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a1为Int类型</span></span><br><span class="line">    <span class="keyword">var</span> a1 = a + a</span><br><span class="line">    <span class="comment">// c1为Int类型</span></span><br><span class="line">    <span class="keyword">var</span> c1 = c + c</span><br><span class="line">    <span class="comment">// d1为Long类型</span></span><br><span class="line">    <span class="keyword">var</span> d1 = a + d</span><br><span class="line">    <span class="comment">// g1为Double类型</span></span><br><span class="line">    <span class="keyword">var</span> g1 = a + c + f + g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例8：字符与布尔。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> b = !a  <span class="comment">// 取反</span></span><br><span class="line">    <span class="comment">// 可以直接调用Java的API进行打印</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(a)</span><br><span class="line">    <span class="comment">// 需要注意的是：</span></span><br><span class="line">    <span class="comment">// 若您写的Kotlin代码最终也会运行在JS环境下，则就需要适配了</span></span><br><span class="line">    <span class="comment">// 若您很确定你的Kotlin代码最终运行在JVM环境下，则就没什么问题了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你去看“println()”内部的源码就会发现，</span></span><br><span class="line">    <span class="comment">// 在JVM环境下，其内部就是调用System.out.println()方法来执行输出的</span></span><br><span class="line">    println(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 true</span></span><br><span class="line">    println(a || b)</span><br><span class="line">    <span class="comment">// 输出 false</span></span><br><span class="line">    println(a &amp;&amp; b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">'a'</span></span><br><span class="line">    println(c)</span><br><span class="line">    <span class="comment">// 按照之前的介绍，下面我们应该调用c.toInt()方法，但该方法已经被Deprecated了</span></span><br><span class="line">    <span class="comment">// 目前Kotlin推荐我们使用字符对象的code属性来将某个字符转为Int对象</span></span><br><span class="line">    <span class="keyword">var</span> d : <span class="built_in">Int</span> = c.code</span><br><span class="line">    <span class="comment">// 输出97，即字符a的ASCII码</span></span><br><span class="line">    println(d)</span><br><span class="line">    <span class="comment">// 输出2，即Char类型的变量占2个字节</span></span><br><span class="line">    println(<span class="built_in">Char</span>.SIZE_BYTES)</span><br><span class="line">    <span class="comment">// 与Java一样，下面的语句无法编译通过，因为这个汉字不在char数据类型的收藏范围内。</span></span><br><span class="line">    <span class="keyword">var</span> ch = <span class="string">'𠮷'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例9-1：字符串。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义两个String类型的变量</span></span><br><span class="line">    <span class="comment">// 需要注意的是，这里说的String类和Java中的String类不是一个东西</span></span><br><span class="line">    <span class="comment">// 它是Kotlin中特有的String类，被放在kotlin包下，该类内提供了很多实用函数</span></span><br><span class="line">    <span class="keyword">var</span> str1 = <span class="string">"aBcD"</span></span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="string">"aBcD"</span></span><br><span class="line">    <span class="comment">// 全部转成大写，返回的是一个新的字符串常量</span></span><br><span class="line">    println(str1.uppercase())</span><br><span class="line">    <span class="comment">// 全部转成小写，返回的是一个新的字符串常量</span></span><br><span class="line">    println(str1.lowercase())</span><br><span class="line">    <span class="comment">// 输出4</span></span><br><span class="line">    println(str1.length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个字符串变量的内容是否相等，输出true</span></span><br><span class="line">    println(str1 == str2)</span><br><span class="line">    <span class="comment">// 比较两个字符串变量所指向的引用，是否相等。</span></span><br><span class="line">    <span class="comment">// 与Java一样，相同的字符串常量会被放到字符串常量池中重用，因此下面输出true</span></span><br><span class="line">    println(str1 === str2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用字符串常量创建一个新的String对象，关于创建对象的知识后面会详细介绍</span></span><br><span class="line">    <span class="keyword">var</span> str3 = String(<span class="string">"aBcD"</span>.toCharArray())</span><br><span class="line">    <span class="comment">// 此时输出true</span></span><br><span class="line">    println(str1 == str3)</span><br><span class="line">    <span class="comment">// 此时输出false</span></span><br><span class="line">    println(str1 === str3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例9-2：字符串。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首尾分别被3个双引号包括的字符串，我们称之为“原始字符串”</span></span><br><span class="line">    <span class="comment">// 原始字符串可以包含换行以及任意文本。</span></span><br><span class="line">    <span class="keyword">var</span> html = <span class="string">"""</span></span><br><span class="line"><span class="string">        &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;</span></span><br><span class="line"><span class="string">                &lt;title&gt;页面标题(w3cschool.cn)&lt;/title&gt;</span></span><br><span class="line"><span class="string">            &lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;Hello  world &lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">    """</span>.trimIndent()</span><br><span class="line">    <span class="comment">// trimIndent方法用来去掉字符串中每行公用的前缀，在此范例中就是空格</span></span><br><span class="line">    println(html)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name1 = <span class="string">"张三"</span></span><br><span class="line">    <span class="keyword">val</span> name2 = <span class="string">"李四"</span></span><br><span class="line">    <span class="comment">// 下面这种字符串连接的方法可以执行，但不推荐</span></span><br><span class="line">    println(<span class="string">"我的名字叫："</span> + name1 + <span class="string">",你的名字叫："</span> + name2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin中，字符串连接可以使用模板(一些小段代码，以$符号开头)，运行时会执行字符串替换。</span></span><br><span class="line">    <span class="comment">// 输出“我的名字叫：张三,你的名字叫：李四”</span></span><br><span class="line">    println(<span class="string">"我的名字叫：<span class="variable">$name1</span>,你的名字叫：<span class="variable">$name2</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果模板是一个表达式，则需要用中括号将整个模板包围起来</span></span><br><span class="line">    <span class="comment">// 输出“我的名字叫：张三,长度是：2”</span></span><br><span class="line">    println(<span class="string">"我的名字叫：<span class="variable">$name1</span>,长度是：<span class="subst">$&#123;name1.length&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在普通字符串常量中，使用“\$”可以转义“$”</span></span><br><span class="line">    <span class="comment">// 下面会输出“我身上有：$1.99美元”</span></span><br><span class="line">    <span class="keyword">var</span> money = <span class="string">"1.99"</span></span><br><span class="line">    println(<span class="string">"我身上有：\$<span class="subst">$&#123;money&#125;</span>美元"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例10：原生数组。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建int类型的数组，“intArrayOf”来自于kotlin包中</span></span><br><span class="line">    <span class="comment">// 相应的还提供了byte、short、long、float、double、char、boolean的数组创建方法</span></span><br><span class="line">    <span class="comment">// 括号里面的是数组中的元素</span></span><br><span class="line">    <span class="keyword">var</span> intArray: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 将数组的内容转成格式化的字符串，方便阅读</span></span><br><span class="line">    <span class="comment">// 输出：[1, 2, 3, 4]</span></span><br><span class="line">    println(intArray.contentToString())</span><br><span class="line">    println(intArray[<span class="number">0</span>])</span><br><span class="line">    println(intArray[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用LongArray类创建一个新对象，4表示数组中有4个元素</span></span><br><span class="line">    <span class="comment">// 后面的大括号是一个lambda表达式，LongArray会依次为每个元素执行一次大括号里的表达式</span></span><br><span class="line">    <span class="comment">// 表达式的结果就是该元素的值，it是一个内置的变量，表示当前元素的下标，从0开始</span></span><br><span class="line">    <span class="keyword">var</span> longArray: LongArray = LongArray(<span class="number">4</span>) &#123;</span><br><span class="line">        it + <span class="number">3</span>L</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：[3, 4, 5, 6]</span></span><br><span class="line">    println(longArray.contentToString())</span><br><span class="line">    <span class="comment">// 获取数组的长度，下面会输出4</span></span><br><span class="line">    println(longArray.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过阅读源码可知，使用intArrayOf等方法创建数组时，其内部就是用的第二种方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> Array<span class="type">&lt;out Long&gt;</span>.<span class="title">toLongArray</span><span class="params">()</span></span>: LongArray &#123;</span><br><span class="line">    <span class="keyword">return</span> LongArray(size) &#123; index -&gt; <span class="keyword">this</span>[index] &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看源码：</span></span><br><span class="line"><span class="comment">// 若你直接在AS查看intArrayOf方法，则会打开Library.kt文件</span></span><br><span class="line"><span class="comment">// 但这个文件里只定义了方法的头部，并没有具体的实现，</span></span><br><span class="line"><span class="comment">// 此时可以顺便打开方法返回值IntArray类的代码，对着它的构造方法执行“Find Usages”</span></span><br><span class="line"><span class="comment">// 就可以发现具体的实现放到_Arrays.kt文件中了</span></span><br></pre></td></tr></table></figure>
<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p><br>　　范例1：If表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        println(<span class="string">"a大"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">"b大"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Kotlin中if-else是一个表达式，是可以将表达式的结果赋值给一个变量的</span></span><br><span class="line">    <span class="comment">// 表达式的结果就是代码块最后一行语句的结果</span></span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        println(<span class="string">"a大"</span>)</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">"b大"</span>)</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：c = 10</span></span><br><span class="line">    println(<span class="string">"c = <span class="variable">$c</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因此在Kotlin中是没有“?:”运算符的，直接用if-else就可以了</span></span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">    <span class="comment">// 输出：d = 10</span></span><br><span class="line">    println(<span class="string">"d = <span class="variable">$d</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：when表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// when语句就和Java中的switch一样</span></span><br><span class="line">    <span class="comment">// when语句括号里的表达式可以是数字、枚举、字符串等（可以是任意表达式，不一定是常量）</span></span><br><span class="line">    <span class="comment">// 每一个case使用“常量 -&gt;”的形式定义</span></span><br><span class="line">    <span class="keyword">when</span> (<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个分支只包含一条语句，可以不加大括号</span></span><br><span class="line">        <span class="string">"+"</span> -&gt; println(<span class="number">3</span> + <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 包含多个语句，则需要大括号</span></span><br><span class="line">        <span class="string">"-"</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">            <span class="keyword">var</span> b = <span class="number">5</span></span><br><span class="line">            println(a - b)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以多个case使用相同的代码，用逗号间隔</span></span><br><span class="line">        <span class="string">"*"</span>, <span class="string">"/"</span> -&gt;</span><br><span class="line">            println(<span class="string">"暂不支持此操作"</span>)</span><br><span class="line">        <span class="comment">// else分支必须写在最后，相当于switch中的default关键字</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">15</span></span><br><span class="line">            <span class="keyword">var</span> b = <span class="number">15</span></span><br><span class="line">            println(a + b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// when 既可以作为表达式使用也可以作为语句使用。</span></span><br><span class="line"><span class="comment">// 如果它被当做表达式，第一个符合条件的分支的值就是整个表达式的值。</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例3：for循环。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> array = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// for 循环可以对任何提供迭代器（iterator）的对象进行遍历</span></span><br><span class="line">    <span class="comment">// 变量array是IntArray类型的，该类内部就提供了iterator()方法</span></span><br><span class="line">    <span class="comment">// 运行时，会依次将数组里的每个元素赋值给item</span></span><br><span class="line">    <span class="keyword">for</span> (item:<span class="built_in">Int</span> <span class="keyword">in</span> array) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过数组对象的indices属性来获取一个下标数组</span></span><br><span class="line">    <span class="comment">// 很显然index的数据类型是可以省写的</span></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">        println(<span class="string">"下标为：<span class="variable">$index</span>，元素值为：<span class="subst">$&#123;array[index]&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：while循环。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// while和do……while的语法没有变</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        println(a++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：区间。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个区间，区间内包含10个数字，从1到10。</span></span><br><span class="line">    <span class="comment">// 变量的类型是IntRange，该类被放到androidx.annotation包中了。</span></span><br><span class="line">    <span class="keyword">var</span> intRange = <span class="number">1.</span><span class="number">.10</span></span><br><span class="line">    <span class="comment">// joinToString方法会将区间内的所有元素拼接一起，生成一个字符串返回</span></span><br><span class="line">    <span class="comment">// 输出：1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line">    println(intRange.joinToString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 很显然除了IntRange外，还有其它几种基本类型的区间，比如Char类型的</span></span><br><span class="line">    <span class="keyword">var</span> charRange = <span class="string">'a'</span>..<span class="string">'f'</span></span><br><span class="line">    <span class="comment">// 输出：a, b, c, d, e, f</span></span><br><span class="line">    println(charRange.joinToString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 半开半闭区间，从1开始到9结束，即不包含10</span></span><br><span class="line">    <span class="keyword">var</span> intOpenRange = <span class="number">1</span> until <span class="number">10</span></span><br><span class="line">    <span class="comment">// 输出：1, 2, 3, 4, 5, 6, 7, 8, 9</span></span><br><span class="line">    println(intOpenRange.joinToString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置步长</span></span><br><span class="line">    <span class="keyword">var</span> intStepRange = <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span></span><br><span class="line">    <span class="comment">// 输出：1, 3, 5, 7, 9</span></span><br><span class="line">    println(intStepRange.joinToString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序区间，downTo也是支持步长的</span></span><br><span class="line">    <span class="keyword">var</span> intDownRange = <span class="number">10</span> downTo <span class="number">1</span></span><br><span class="line">    <span class="comment">// 输出：10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span></span><br><span class="line">    println(intDownRange.joinToString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无符号类型也有相关的区间类，UIntRange、ULongRange等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另外float和double的区间比较特殊，无法通过joinToString方法输出其内容</span></span><br><span class="line">    <span class="comment">// 因为两个小数之间其实可以存在无数多个数字</span></span><br><span class="line">    <span class="comment">// 同时小数区间也无法使用step设置步长，无法进行遍历</span></span><br><span class="line">    <span class="keyword">var</span> floatRange = <span class="number">1</span>f.<span class="number">.2</span>f</span><br><span class="line">    <span class="keyword">var</span> doubleRange = <span class="number">3.0</span>.<span class="number">.4</span><span class="number">.0</span></span><br><span class="line">    println(floatRange.toString())</span><br><span class="line">    println(doubleRange.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：in关键字的其它用法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> array = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 当在if表达式中使用in关键字时，会判断指定元素是否在array中。</span></span><br><span class="line">    <span class="comment">// 相应的也可以使用“!in”来进行判断。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">5</span> <span class="keyword">in</span> array) &#123;</span><br><span class="line">        println(<span class="string">"找到了"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">"没找到了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当在for循环中使用in关键字时，就是循环。</span></span><br><span class="line">    <span class="comment">// 当我们手上没有数组，就单纯的想循环指定的次数时，可以用区间来实现。</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出：1 2 3 4 5 6 7 8 9 10 </span></span><br><span class="line">        print(<span class="string">"<span class="variable">$i</span> "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们通常用float和double区间来判断数字是否在某个范围内</span></span><br><span class="line">    <span class="keyword">if</span> (Math.PI <span class="keyword">in</span> <span class="number">1</span>f.<span class="number">.4</span>f) println(<span class="string">"在区间内"</span>) <span class="keyword">else</span> println(<span class="string">"不在区间内"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例6：break和continue。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// break和continue的作用和Java一样，只会对最内层的循环生效</span></span><br><span class="line">    <span class="comment">// 输出：1*1 1*3 2*1 2*3 3*1 3*3</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            print(<span class="string">"<span class="variable">$i</span>*<span class="variable">$j</span> "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 使用“标识符@”来定义一个标签，后续可以使用break或者continue来跳到这个标签</span></span><br><span class="line">    <span class="comment">// 输出：1*1 2*1 3*1</span></span><br><span class="line">    <span class="symbol">mark1@</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span><span class="symbol">@mark1</span></span><br><span class="line">            &#125;</span><br><span class="line">            print(<span class="string">"<span class="variable">$i</span>*<span class="variable">$j</span> "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 输出：1*1</span></span><br><span class="line">    <span class="symbol">mark2@</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span><span class="symbol">@mark2</span></span><br><span class="line">            &#125;</span><br><span class="line">            print(<span class="string">"<span class="variable">$i</span>*<span class="variable">$j</span> "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p><br>　　范例1：类和对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有定义任何构造方法，Kotlin会默认提供一个无参构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类的属性</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="comment">// 使用constructor关键词来定义构造方法</span></span><br><span class="line">    <span class="comment">// 此时就没有无参构造方法了，实例化对象必须调用此方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本类中定义了两个属性，定义属性的同时必须赋默认值，</span></span><br><span class="line">    <span class="comment">// 除非编译器推导出后续有代码会对该属性进行赋值，否则直接编译报错</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是只有一个参数的构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数的构造方法，后面的“: this(name)”表示调用一个参数的构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个Person对象，在Kotlin中没有new关键词</span></span><br><span class="line">    <span class="keyword">var</span> p1 = Person1()</span><br><span class="line">    <span class="keyword">var</span> p2 = Person2(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">var</span> p3 = Person3(<span class="string">"张三"</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：主构造方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以将类的某个构造方法写在类名后面，这样的构造方法我们称之为“主构造方法”。</span></span><br><span class="line"><span class="comment">// 相应的，那些写在类体里面的构造方法，被称为“次构造方法”。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span></span><br><span class="line">    <span class="comment">// 主构造方法后面那个括号里的参数，可以直接在类体中访问到</span></span><br><span class="line">    <span class="keyword">var</span> name: String = name</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="comment">// 类体中可以定义一个“init代码块”，用来对类的属性进行初始化</span></span><br><span class="line">        <span class="comment">// 若编译器检测到了这个代码块内，有对某个属性的初始化操作，</span></span><br><span class="line">        <span class="comment">// 那么在其定义的时候，就可以不马上赋值</span></span><br><span class="line">        <span class="comment">// init代码块和Java中的实例块一样，类中可以存在多个init代码块，</span></span><br><span class="line">        <span class="comment">// JVM按照扫描到的先后顺序执行init代码块，</span></span><br><span class="line">        <span class="comment">// 所有代码快都执行完毕后，才会调用构造方法</span></span><br><span class="line">        <span class="comment">// init块中可以访问到主构造方法的普通参数，即本范例中的“name”</span></span><br><span class="line">        age = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有次构造方法都必须直接或间接调用主构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// this的概念和Java一样，表示当前对象</span></span><br><span class="line">        println(<span class="string">"姓名：<span class="subst">$&#123;this.name&#125;</span>，年龄：<span class="subst">$&#123;this.age&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 姓名：李四，年龄：6</span></span><br><span class="line">    Person(<span class="string">"李四"</span>).sayHello()</span><br><span class="line">    <span class="comment">// 姓名：张三，年龄：18</span></span><br><span class="line">    Person(<span class="string">"张三"</span>, <span class="number">18</span>).sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果主构造函数没有任何注解或者可见性修饰符，可以省略这个constructor关键字。</span></span><br><span class="line"><span class="comment">// 本范例中的constructor是可以省写的，而下面的情况则不可以省写：</span></span><br><span class="line"><span class="comment">// class Customer public @Inject constructor(name: String) &#123; /*……*/ &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><br>　　范例1：Getter和Setter。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  属性创建的完整语法：</span></span><br><span class="line">    <span class="comment">//    var/val &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;initializer&gt;]</span></span><br><span class="line">    <span class="comment">//      [&lt;getter&gt;]</span></span><br><span class="line">    <span class="comment">//      [&lt;setter&gt;]</span></span><br><span class="line">    <span class="comment">//  其中初始器(initializer)、getter 和 setter 都是可选的。</span></span><br><span class="line">    <span class="comment">//  若属性类型可以从初始器，或其getter的返回值中推断出来，也可以省略。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于可变属性来说，其必须得有初始化值，否则编译报错，给其赋初始化值有三种方法：</span></span><br><span class="line">    <span class="comment">// 1、定义的同时直接赋值</span></span><br><span class="line">    <span class="comment">// 2、定义不赋值，但在构造函数中赋值</span></span><br><span class="line">    <span class="comment">// 3、定义不赋值，但在初始化块赋值</span></span><br><span class="line">    <span class="comment">// 4、延迟初始化（后述）</span></span><br><span class="line">    <span class="keyword">var</span> name1 = <span class="string">"张三"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只读属性。</span></span><br><span class="line">    <span class="keyword">val</span> name2: String</span><br><span class="line">        <span class="comment">// 由于name2提供了get()方法，外界需要取值时会直接调用get()方法，因此不用给它默认值</span></span><br><span class="line">        <span class="comment">// 只读属性不能提供set()方法</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"王五"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name3 = <span class="string">"李四"</span></span><br><span class="line">        <span class="comment">// 从上面的默认值中可以推导出name3是String类型的，所以不用指定类型</span></span><br><span class="line">        <span class="comment">// 需要注意的是，不要在get、set方法中出现“this.name3”的代码，否则会导致递归调用</span></span><br><span class="line">        <span class="comment">// 下面这个“field”关键词是Kotlin内置的，只能在get、set方法内部使用，它表示当前属性</span></span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            println(<span class="string">"有人请求将“李四”为“<span class="variable">$value</span>”"</span>)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    <span class="comment">// 当我们通过“对象.属性名”的方式访问属性时，Kotlin会判断该属性是否提供了get方法</span></span><br><span class="line">    <span class="comment">// 若提供了，则调用其get方法，并将get方法返回值交给调用者</span></span><br><span class="line">    <span class="comment">// 若没有提供，则直接获取该属性的值，并返回给调用者</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p.name1&#125;</span> , <span class="subst">$&#123;p.name2&#125;</span> , <span class="subst">$&#123;p.name3&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// 相应的，当我们通过“对象.属性名”修改某个属性时，会触发set方法的检测</span></span><br><span class="line">    <span class="comment">// 若提供了，则直接调用，若没提供则直接修改</span></span><br><span class="line">    p.name1 = <span class="string">"张三三"</span></span><br><span class="line">    p.name3 = <span class="string">"赵六"</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p.name1&#125;</span> , <span class="subst">$&#123;p.name2&#125;</span> , <span class="subst">$&#123;p.name3&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本范例的输出为：</span></span><br><span class="line">    <span class="comment">// 张三 , 王五 , 李四</span></span><br><span class="line">    <span class="comment">// 有人请求将“李四”为“赵六”</span></span><br><span class="line">    <span class="comment">// 张三三 , 王五 , 赵六</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：编译期常量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用const关键字修饰的val变量在Kotlin中被视为编译期常量</span></span><br><span class="line"><span class="comment">// 这种属性需要满足以下要求：</span></span><br><span class="line"><span class="comment">// 1、必须位于顶层（即不再某个类的内部）或者是object声明或伴生对象的一个成员</span></span><br><span class="line"><span class="comment">// 2、必须以 String 或原生类型值初始化</span></span><br><span class="line"><span class="comment">// 3、不能有自定义 getter</span></span><br><span class="line">const <span class="keyword">val</span> KEY_USER_ID = <span class="string">"key_user_id"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(KEY_USER_ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><br>　　范例1：函数的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不属于任何类的函数，最后面的“:Int”为函数的返回值类型</span></span><br><span class="line"><span class="comment">// “()”里的每个参数必须明确写出类型，不能省写</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类内的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “Unit”相当于Java中的“void”表示无法返回值，这个“Unit”是可以省写的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">(msg: <span class="type">String</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接调用</span></span><br><span class="line">    println(sum(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">// 需要对象才可以调用</span></span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    println(p.sayHello())</span><br><span class="line">    p.printMessage(<span class="string">"你好啊!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：可变参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用“vararg”关键词定义一个可变参数</span></span><br><span class="line"><span class="comment">// 在函数内部，可以将可变参数当做一个普通数组来使用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(<span class="keyword">vararg</span> numbers: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">        result += item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用可变参数函数时，直接传参数值即可，参数值数量是任意的</span></span><br><span class="line">    println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：单表达式函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当函数返回单个表达式时，可以省略花括号并且在“=”之后指定代码体即可。</span></span><br><span class="line"><span class="comment">// 注意看，这个函数有返回值，但却没有写返回值类型，这是因为编辑器可以推断出来返回类型</span></span><br><span class="line"><span class="comment">// 但Kotlin不推断具有块代码体的函数的返回类型，因为这样的函数在代码体中可能有复杂的控制流。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(sum(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：函数作为参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中，函数也可以作为参数传递</span></span><br><span class="line"><span class="comment">// 函数的类型写法为“(参数A的类型,参数B的类型，……) -&gt; 函数返回值的类型”</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(id: <span class="type">String</span>, password: <span class="type">String</span>, callback: (<span class="type">Boolean</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    callback(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onLoginFinished</span><span class="params">(isFinish: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"是否登录成功？<span class="variable">$isFinish</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用两个冒号“::”加上函数名称，就可以获取到这个函数的引用</span></span><br><span class="line">    <span class="comment">// 下面代码将函数的引用赋值给一个变量</span></span><br><span class="line">    <span class="keyword">var</span> callback1 = ::onLoginFinished</span><br><span class="line">    <span class="comment">// 将函数的引用传递过去</span></span><br><span class="line">    login(<span class="string">"123456"</span>, <span class="string">"654321"</span>, callback1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：类内函数作为参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Any相当于Java中的“Object”表示任意类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLoginFinished</span><span class="params">(isFinish: <span class="type">Boolean</span>)</span></span>: Any &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在函数的类型前面，加上“类名.”</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login1</span><span class="params">(p: <span class="type">Person</span>, callback: <span class="type">Person</span>.(<span class="type">Boolean</span>)</span></span> -&gt; Any) &#123;</span><br><span class="line">    <span class="comment">// 通过对象调用函数</span></span><br><span class="line">    p.callback(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者直接把类名写到参数列表中，当做函数的第一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login2</span><span class="params">(p: <span class="type">Person</span>, callback: (<span class="type">Person</span>, <span class="built_in">Boolean</span>)</span></span> -&gt; Any) &#123;</span><br><span class="line">    <span class="comment">// 注意此处调用函数时，也需要将对象当做参数进行传递</span></span><br><span class="line">    callback(p, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login3</span><span class="params">(callback: (<span class="type">Boolean</span>)</span></span> -&gt; Any) &#123;</span><br><span class="line">    callback(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    <span class="comment">// 通过“类名::函数名”来获取函数的引用</span></span><br><span class="line">    <span class="keyword">var</span> callback = Person::onLoginFinished</span><br><span class="line">    <span class="comment">// 调用函数时，需要同时传递一个对象过去</span></span><br><span class="line">    login1(p, callback)</span><br><span class="line">    login2(p, callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过“对象::函数名”来获取函数的引用</span></span><br><span class="line">    <span class="keyword">var</span> callback2 = p::onLoginFinished</span><br><span class="line">    <span class="comment">// 调用函数时，直接传函数引用即可</span></span><br><span class="line">    login3(callback2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例6：参数默认值与具名参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// “score: Long = 33”用来给参数score设置默认值</span></span><br><span class="line"><span class="comment">// 若函数的调用者只传递了两个参数，则score默认取值33</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello1</span><span class="params">(age: <span class="type">Int</span>, name: <span class="type">String</span>, score: <span class="type">Long</span> = <span class="number">33</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"我叫<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁，这次计算机考了<span class="subst">$&#123;score&#125;</span>分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有默认值的参数最好都放到参数列表后面</span></span><br><span class="line"><span class="comment">// 下面这个方法的age参数放到了前面，我们在调用就需要一些变化</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello2</span><span class="params">(age: <span class="type">Int</span> = <span class="number">20</span>, name: <span class="type">String</span>, score: <span class="type">Long</span> = <span class="number">33</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"我叫<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁，这次计算机考了<span class="subst">$&#123;score&#125;</span>分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 三个参数都传了</span></span><br><span class="line">    sayHello1(<span class="number">18</span>, <span class="string">"张三"</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="comment">// 第三参数使用默认值</span></span><br><span class="line">    sayHello1(<span class="number">18</span>, <span class="string">"李四"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行代码会有编译错误，因为编译器默认会认为你想将“王五”传递给参数age</span></span><br><span class="line">    <span class="comment">// sayHello2("王五")</span></span><br><span class="line">    <span class="comment">// 为了防止编译器误会，我们可以在传递参数时，为参数指定其接受者的名称（形参的名称）</span></span><br><span class="line">    sayHello2(name = <span class="string">"王五"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><br>　　范例1：定义父类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中所有类都有一个共同的父类Any，对于没有声明父类的类它是默认父类。</span></span><br><span class="line"><span class="comment">// Any有三个方法：equals()、hashCode()与toString()，因此所有Kotlin类都定义了这些方法。</span></span><br><span class="line"><span class="comment">// 默认情况下，Kotlin类是最终（final）的，即它们不能被继承。 </span></span><br><span class="line"><span class="comment">// 要使一个类可继承，请用open关键字标记它。</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当父类没有任何构造方法时，继承关系的写法为：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> : <span class="type">Person &#123;</span></span></span><br><span class="line">    <span class="comment">// 定义一个无参构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以简写为：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu = Student1()</span><br><span class="line">    println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：调用父类构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中，我们可以在主构造函数中使用“var”或者“val”定义属性</span></span><br><span class="line"><span class="comment">// 比如下面直接在Person类的主构造函数里定义两个属性。</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> : <span class="type">Person &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> score: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 次构造器的参数列表里是不可以使用“var”或者“val”关键词的。</span></span><br><span class="line">    <span class="comment">// 在子类的次构造函数后面需要使用“super”显式的调用父类的构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>, score: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子类的主构造函数中，可以这么调用父类构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">var</span> score: <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">    <span class="comment">// 如果Student2类只有新增属性，没有任何新增函数，则可以把类体（大括号）给删掉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu1 = Student1(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">90</span>)</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;stu1.name&#125;</span>,<span class="subst">$&#123;stu1.age&#125;</span>,<span class="subst">$&#123;stu1.score&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stu2 = Student2(<span class="string">"李四"</span>, <span class="number">10</span>, <span class="number">80</span>)</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;stu2.name&#125;</span>,<span class="subst">$&#123;stu2.age&#125;</span>,<span class="subst">$&#123;stu2.score&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：函数重写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若你想让某个函数可以被子类重写，则需要使用“open”关键字</span></span><br><span class="line">    <span class="comment">// 若你给一个非“open”类的某个函数加了“open”关键字，则不会其任何作用</span></span><br><span class="line">    <span class="comment">// 因为非“open”类连被别人继承都做不到，更别说让子类重写了</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"父类的draw方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当父类函数中没有加“open”，且子类中定义了一个和父类同名的函数时，</span></span><br><span class="line">    <span class="comment">// 不论子类的同名函数否使用override关键字，都会编译报错</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"父类的fill方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="type">Shape</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 如果你想重写父类的“open”方法，则需要使用“override”关键字，否则编译报错</span></span><br><span class="line">    <span class="comment">// 一个函数是否可以重写有三种情况：</span></span><br><span class="line">    <span class="comment">// 1、函数最初定义的时候，没有使用“open”关键字修饰，那么就永远不可以重写</span></span><br><span class="line">    <span class="comment">// 2、函数最初定义的时候，使用了“open”关键字修饰，则其所有儿子、孙子、重孙子类都可以重写</span></span><br><span class="line">    <span class="comment">// 3、基于第二条，若某一个子类重写后，不想让其儿子、孙子类继续重写，可以使用“final”关键词</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果你想调用父类的同名方法，可以使用“super”关键字</span></span><br><span class="line">        <span class="keyword">super</span>.draw()</span><br><span class="line">        println(<span class="string">"子类的draw方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小提示：final和open这俩关键字是互斥的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// 父类的fill方法</span></span><br><span class="line">    <span class="comment">// 父类的draw方法</span></span><br><span class="line">    <span class="comment">// 子类的draw方法</span></span><br><span class="line">    <span class="keyword">var</span> circle = Circle()</span><br><span class="line">    circle.fill()</span><br><span class="line">    circle.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：属性重写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同样使用“open”关键字</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> vertexCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="type">Shape</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 同样可以使用“override”、“final”关键字，且属性必须同名</span></span><br><span class="line">    <span class="comment">// 子类覆盖父类属性时，必须保证它们二者具有兼容的类型</span></span><br><span class="line">    <span class="comment">// 比如父类是Int，子类不可以是Long</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> vertexCount = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以用一个var属性覆盖一个val属性，但反之则不行。</span></span><br><span class="line">    <span class="comment">// 因为val属性本质上声明了一个get方法，而将其覆盖为var只是在子类中额外声明一个set方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，我们也可以这么写</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle2</span></span>(<span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> vertexCount: <span class="built_in">Int</span> = <span class="number">4</span>) : Shape() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：抽象类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类必须使用“abstract”关键词</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用“open”修饰的普通函数，能被子类重写</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"抽象类中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用“abstract”修饰的抽象函数，不能有函数体，且必须被子类重写</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若想此字段被子类覆盖，同样需要使用“open”关键字</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="type">AbsClass</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Person类中的sayHello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类实现</span></span><br><span class="line">        <span class="keyword">super</span>.test1()</span><br><span class="line">        println(<span class="string">"Person类中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> = <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    p.sayHello()</span><br><span class="line">    p.test1()</span><br><span class="line">    println(p.size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 程序输出：</span></span><br><span class="line">    <span class="comment">// Person类中的sayHello</span></span><br><span class="line">    <span class="comment">// 抽象类中的test1</span></span><br><span class="line">    <span class="comment">// Person类中的test1</span></span><br><span class="line">    <span class="comment">// 110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：接口。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口必须使用“interface”关键词</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口内的所有函数，不需要用“open”修饰，它一定可以被子类重写，因此也不能使用“final”</span></span><br><span class="line">    <span class="comment">// 接口内的所有函数，可以有函数体，也可以没有，当没有时，其默认被“abstract”修饰</span></span><br><span class="line">    <span class="comment">// 很显然，你不能先给函数加上“abstract”关键字，然后为其提供方法体，编译会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Inter1中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口的属性同样不需要使用“open”关键字，其实现类可以直接进行覆盖</span></span><br><span class="line">    <span class="comment">// 接口的属性不能在定义的同时，为其赋初始化值</span></span><br><span class="line">    <span class="comment">// 接口的属性可以使用“val”或“var”修饰，val只可以为其提供get方法</span></span><br><span class="line">    <span class="comment">// 若接口内的属性没有提供get函数，且实现类也没有覆盖此属性，则实现类需要为其提供get函数</span></span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span>) : Inter1 &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.test1()</span><br><span class="line">        println(<span class="string">"Person类中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person(<span class="number">666</span>)</span><br><span class="line">    p.test1()</span><br><span class="line">    println(p.size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序输出：</span></span><br><span class="line">    <span class="comment">// Inter1中的test1</span></span><br><span class="line">    <span class="comment">// Person类中的test1</span></span><br><span class="line">    <span class="comment">// 666</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小提示：接口也是可以继承接口的</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例6：接口和抽象类同时出现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"AbsClass中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Inter1中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Inter2中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与Java一样，一个类只能有一个直接父类，可以实现多个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>() : AbsClass(), Inter1, Inter2 &#123;</span><br><span class="line">    <span class="comment">// 这个test1函数在三个父类里都有定义，且都有各自的实现</span></span><br><span class="line">    <span class="comment">// 为了避免歧义，编译器要求实现类，必须重写test1函数，以消除歧义</span></span><br><span class="line">    <span class="comment">// 也就是说，只要你从多个父类继承了同名函数，就必须重写它以消除歧义，不论其是否是抽象函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 明确指出要调用哪个父类的test1函数</span></span><br><span class="line">        <span class="keyword">super</span>&lt;AbsClass&gt;.test1()</span><br><span class="line">        <span class="keyword">super</span>&lt;Inter1&gt;.test1()</span><br><span class="line">        <span class="keyword">super</span>&lt;Inter2&gt;.test1()</span><br><span class="line">        println(<span class="string">"Person类中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 很显然，属性也有一样的要求</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="number">666</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Person类中的test1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    p.test1()</span><br><span class="line">    println(p.size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序输出：</span></span><br><span class="line">    <span class="comment">// AbsClass中的test1</span></span><br><span class="line">    <span class="comment">// Inter1中的test1</span></span><br><span class="line">    <span class="comment">// Inter2中的test1</span></span><br><span class="line">    <span class="comment">// Person类中的test1</span></span><br><span class="line">    <span class="comment">// 666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空类型安全"><a href="#空类型安全" class="headerlink" title="空类型安全"></a>空类型安全</h3><p><br>　　范例1：不能赋值null。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 许多编程语言（包括 Java）中最常见的陷阱之一，就是访问空引用的成员会导致空引用异常。</span></span><br><span class="line"><span class="comment">// 在Java中，这等同于NullPointerException或简称NPE。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 很普通的一个变量定义代码</span></span><br><span class="line">    <span class="keyword">var</span> str1: String = <span class="string">"你好"</span></span><br><span class="line">    <span class="comment">// 下面几行代码会编译报错，因为默认情况下编译器是不允许变量值为null的</span></span><br><span class="line">    <span class="keyword">var</span> str2: String = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> int : <span class="built_in">Int</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> float : <span class="built_in">Float</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> boolean : <span class="built_in">Boolean</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> person : Person = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> obj : Any = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：“<code>?</code>”操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str1: String = <span class="string">"你好"</span></span><br><span class="line">    println(str1.length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以在类型的后面加一个“?”来告知编译器，允许这个变量的值为null</span></span><br><span class="line">    <span class="keyword">var</span> str2: String? = <span class="string">"世界"</span></span><br><span class="line">    <span class="comment">// 虽然上面我们明确给str2赋值了</span></span><br><span class="line">    <span class="comment">// 但下面这行代码依然会编译报错，因为str2的数据类型就是可能为null的，编译器只看数据的类型</span></span><br><span class="line">    <span class="comment">// println(str2.length)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了保证编译顺利通过，一般可以这么做:</span></span><br><span class="line">    <span class="keyword">if</span> (str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(str2.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：“<code>?.</code>”操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str1: String = <span class="string">"你好"</span></span><br><span class="line">    println(str1.length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “?.”被称为安全调用操作符</span></span><br><span class="line">    <span class="comment">// 若str2为null，则整个表达式就为null，否则则获取str2.length的值</span></span><br><span class="line">    <span class="keyword">var</span> str2: String? = <span class="string">"世界"</span></span><br><span class="line">    println(str2?.length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> str3: String? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 下面这行代码运行时不会抛空指针</span></span><br><span class="line">    <span class="comment">// 输出：null</span></span><br><span class="line">    println(str3?.length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全调用也可以出现在赋值的左侧。</span></span><br><span class="line">    <span class="comment">// 这样，如果调用链中的任何一个接收者为 null 都会跳过赋值，而右侧的表达式根本不会求值。</span></span><br><span class="line">    <span class="comment">// 比如：</span></span><br><span class="line">    <span class="comment">// person?.department?.head = managersPool.getManager()</span></span><br><span class="line">    <span class="comment">// 如果 `person` 或者 `person.department` 其中之一为空，都不会调用该函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：“<code>?:</code>”操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b: String? = <span class="string">"世界，你好"</span></span><br><span class="line">    <span class="comment">// 如果表达式“b?.length”的值是null，则整个表达式最终结果为-1，</span></span><br><span class="line">    <span class="comment">// 否则“b?.length”的值就是整个表达式的值</span></span><br><span class="line">    <span class="keyword">val</span> l: <span class="built_in">Int</span> = b?.length ?: <span class="number">-1</span></span><br><span class="line">    println(l)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “?:”操作符，也被称为“Elvis 操作符”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：“<code>!!</code>”操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str1: String? = <span class="string">"你好"</span></span><br><span class="line">    <span class="keyword">var</span> str2: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// “!!”是非空断言运算符，它可以将任何值转换为非空类型，若值为null，则直接抛空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于str1是非null，因此表达式的值为“String”类型的变量</span></span><br><span class="line">    println(str1!!)</span><br><span class="line">    <span class="comment">// 由于str1是非null，因此可以顺利输出2</span></span><br><span class="line">    println(str1!!.length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于str2是null，所以运行时直接抛出空指针</span></span><br><span class="line">    println(str2!!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例6：“<code>as</code>”和“<code>as?</code>”操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个Number类型的变量，并同时赋值一个Int型的常量过去</span></span><br><span class="line">    <span class="comment">// Number类是Int等基本数字类型的共有父类，因此是可以成功赋值的</span></span><br><span class="line">    <span class="keyword">var</span> number: Number = <span class="number">6</span></span><br><span class="line">    <span class="comment">// 使用“as”关键字，可以将number向下转型为Int</span></span><br><span class="line">    println(number <span class="keyword">as</span> <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行代码运行是会抛“java.lang.NullPointerException”异常</span></span><br><span class="line">    <span class="comment">// println(null as String)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码不会抛异常，能顺利输出“null”</span></span><br><span class="line">    println(<span class="literal">null</span> <span class="keyword">as</span> String?)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行代码运行是会抛“java.lang.ClassCastException”异常</span></span><br><span class="line">    <span class="comment">// println("你好" as Int)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// “as?”被称为安全转换操作符</span></span><br><span class="line">    <span class="comment">// 在进行转换操作中只要抛出异常，整个表达式的值就是null，而不会真的把异常抛出</span></span><br><span class="line">    println(<span class="string">"安全转换1：<span class="subst">$&#123;null as? Double&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"安全转换2：<span class="subst">$&#123;"你好" as? Double&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例7：“<code>is</code>”操作符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用“is”操作符或其否定形式“!is”，可以在运行时检测对象是否符合给定类型。</span></span><br><span class="line">    var obj = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">if</span> (obj is String) &#123;</span><br><span class="line">        <span class="comment">// 大多数场景都不需要在 Kotlin 中使用转换操作符（as操作符）。</span></span><br><span class="line">        <span class="comment">// 因为编译器会自动跟踪以及转换，比如下面可以直接调用String类的方法。</span></span><br><span class="line">        println(obj.lowercase())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `&amp;&amp;` 右侧的 obj 自动转换为 String</span></span><br><span class="line">    <span class="keyword">if</span> (obj is String &amp;&amp; obj.isNotEmpty()) &#123;</span><br><span class="line">        print(obj.uppercase())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请注意，当编译器能保证变量在检测和使用之间没变改变时，智能转换才有效。</span></span><br><span class="line"><span class="comment">// 比如val的局部变量，由于不可变，所以总是可以完成智能转换。</span></span><br><span class="line"><span class="comment">// 而var的局部变量，若在检测和使用之间，对其进行修改，则就无法智能转换了。</span></span><br><span class="line"><span class="comment">// 需要注意的，一些全局的var变量是无法进行智能转换的，</span></span><br><span class="line"><span class="comment">// 因为即便加了判断，其也可能因为多线程访问而被改变。</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><br>　　范例1：扩展函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin能够对一个类或接口扩展新功能而无需继承该类或者使用像装饰者这样的设计模式。</span></span><br><span class="line"><span class="comment">// 例如，你可以为一个你不能修改的、来自第三方库中的类或接口编写一个新的函数。 </span></span><br><span class="line"><span class="comment">// 这个新增的函数就像那个原始类本来就有的函数一样，可以用寻常方式调用。 </span></span><br><span class="line"><span class="comment">// 这种机制称为扩展函数。此外，也有扩展属性，允许你为一个已经存在的类添加新的属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 往String类中添加一个名为“wrapChar”的函数</span></span><br><span class="line"><span class="comment"> * 随后我们就可以直接使用字符串对象调用这个函数</span></span><br><span class="line"><span class="comment"> * 本函数用来往字符串的开头和结尾添加指定个数的char</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">wrapChar</span><span class="params">(char: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="comment">// 首先定义一个区间，取值从0~count，共count+1个数字</span></span><br><span class="line">    <span class="comment">// 区间对象的joinToString函数用来将区间转换成一个字符串，由于函数的参数是一个空串，</span></span><br><span class="line">    <span class="comment">// 所以输出的字符串中，所有元素紧挨着排列，不需要间隔，如果参数是“,”则就是“,”间隔</span></span><br><span class="line">    <span class="keyword">var</span> str = (<span class="number">0.</span>.count).joinToString(<span class="string">""</span>) &#123; char &#125;</span><br><span class="line">    <span class="comment">// 下面这个this就是表示调用此方法的当前字符串对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="variable">$str</span><span class="variable">$this</span><span class="variable">$str</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果上面没有“&#123; char &#125;”这个代码块，输出的字符串应该是“01234Hello World01234”</span></span><br><span class="line">    <span class="comment">// 如果有，则输出的字符串的每个字符都是表达式的值，即“*****Hello World*****”</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>.wrapChar(<span class="string">"*"</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展不能真正的修改他们所扩展的类。</span></span><br><span class="line"><span class="comment">// 通过定义一个扩展，并没有在一个类中插入新成员，</span></span><br><span class="line"><span class="comment">// 只不过是可以通过该类型的变量用点表达式去调用这个新函数。</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例2：扩展是静态解析的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="type">Shape</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Shape.<span class="title">getName</span><span class="params">()</span></span> = <span class="string">"Shape"</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Rectangle.<span class="title">getName</span><span class="params">()</span></span> = <span class="string">"Rectangle"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当父类和子类有重名的扩展函数时，最终调用谁的函数，</span></span><br><span class="line">    <span class="comment">// 是由函数调用所在的表达式的类型来决定的，而不是由表达式运行时求值结果决定的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式的类型是Rectangle，所以输出：Rectangle</span></span><br><span class="line">    <span class="keyword">var</span> s1 = Rectangle()</span><br><span class="line">    println(s1.getName())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式的类型是Shape，所以输出：Shape</span></span><br><span class="line">    <span class="keyword">var</span> s2: Shape = Rectangle()</span><br><span class="line">    println(s2.getName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：函数重名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printFunctionType</span><span class="params">()</span></span> &#123; println(<span class="string">"Class method"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Example.<span class="title">printFunctionType</span><span class="params">()</span></span> &#123; println(<span class="string">"Extension function"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果一个类定义有一个成员函数与一个扩展函数，</span></span><br><span class="line">    <span class="comment">// 而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，</span></span><br><span class="line">    <span class="comment">// 这种情况总是取成员函数。</span></span><br><span class="line">    <span class="comment">// 输出：Class method</span></span><br><span class="line">    Example().printFunctionType()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当然，扩展函数重载了，与其同样名字但不同签名成员函数，是不会有问题的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：扩展Any类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样一来，所有的类都具有了sayHello方法，包括“null”</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    p.sayHello()</span><br><span class="line">    <span class="literal">null</span>.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：中缀表示法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标有 infix 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。</span></span><br><span class="line"><span class="comment">// 中缀函数必须满足以下要求：</span></span><br><span class="line"><span class="comment">// 1、它们必须是成员函数或扩展函数。</span></span><br><span class="line"><span class="comment">// 2、它们必须只有一个参数。</span></span><br><span class="line"><span class="comment">// 3、其参数不得接受可变数量的参数且不能有默认值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个支持中缀表示法的扩展函数，用作字符串拼接</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">append</span><span class="params">(str: <span class="type">String</span>)</span></span> = <span class="string">"<span class="variable">$this</span><span class="variable">$str</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 可以向之前那样（通过.和圆括号）调用这个函数</span></span><br><span class="line">    println(<span class="string">"你好 "</span>.append(<span class="string">"张三"</span>))</span><br><span class="line">    <span class="comment">// 也可以直接使用方法名来调用</span></span><br><span class="line">    println(<span class="string">"Hello "</span> append <span class="string">"World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p><br>　　范例1：重载入门。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 众所周知Kotlin中内置了很多操作符，比如：+、-、*、/、++、--等等</span></span><br><span class="line">    <span class="comment">// 当我们对一个变量使用这些操作符时，其实就是调用了该变量所属类的某个特定函数。</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">3</span></span><br><span class="line">    <span class="comment">// 下面的代码其实就是调用了Int类的的inc()函数：</span></span><br><span class="line">    n++</span><br><span class="line">    println(n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这就意味着，我们完全可以自己定义一个Person类，让它也支持“++”运算符</span></span><br><span class="line">    <span class="keyword">var</span> p = Person(<span class="string">"张三"</span>, <span class="number">18</span>)</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p.name&#125;</span>,<span class="subst">$&#123;p.age&#125;</span>"</span>)</span><br><span class="line">    p++</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p.name&#125;</span>,<span class="subst">$&#123;p.age&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用“operator”关键字来定义一个操作符函数</span></span><br><span class="line">    <span class="comment">// 对于“++”操作符来说，编译器会自动调用名为inc的函数，若无则编译报错</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span>: Person &#123;</span><br><span class="line">        <span class="keyword">this</span>.age++</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：Int与Person的运算。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给Int类扩展一个操作符重载函数</span></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">plus</span><span class="params">(p: <span class="type">Person</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> p = Person(<span class="string">"张三"</span>, <span class="number">29</span>)</span><br><span class="line">    <span class="comment">// “+”对应的就是“plus”函数</span></span><br><span class="line">    <span class="comment">// 当执行下面的操作时，虚拟机就会调用“+”运算符左侧对象的plus(Person)函数</span></span><br><span class="line">    <span class="comment">// 程序输出：129</span></span><br><span class="line">    println(a + p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：equals方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 = Person(<span class="string">"张三"</span>, <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">var</span> p2 = Person(<span class="string">"张三"</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="comment">// equals函数被定义在Any类中，由于Any类是所有类的父类，所以所有类都继承了这个函数</span></span><br><span class="line">    <span class="comment">// 该函数的签名为：</span></span><br><span class="line">    <span class="comment">// public open operator fun equals(other: Any?): Boolean</span></span><br><span class="line">    <span class="comment">// 当我们对着两个对象使用“==”时，就会调用“==”左侧那个对象的equals方法</span></span><br><span class="line">    println(p1 == p2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        println(<span class="string">"Person equals 被调用"</span>)</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> Person) &#123;</span><br><span class="line">            <span class="comment">// 接着会触发String类的equals方法的调用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name == other.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：其它方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Kotlin中我们可以重载的操作符包括但不限于以下操作符：</span></span><br><span class="line"><span class="comment">// 具体详见：https://book.kotlincn.net/text/operator-overloading.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +a       a.unaryPlus()</span></span><br><span class="line"><span class="comment">// -a       a.unaryMinus()</span></span><br><span class="line"><span class="comment">// !a       a.not()</span></span><br><span class="line"><span class="comment">// a++      a.inc()</span></span><br><span class="line"><span class="comment">// a--      a.dec()</span></span><br><span class="line"><span class="comment">// a + b    a.plus(b)</span></span><br><span class="line"><span class="comment">// a - b    a.minus(b)</span></span><br><span class="line"><span class="comment">// a * b    a.times(b)</span></span><br><span class="line"><span class="comment">// a / b    a.div(b)</span></span><br><span class="line"><span class="comment">// a % b    a.rem(b)</span></span><br><span class="line"><span class="comment">// a..b     a.rangeTo(b)</span></span><br><span class="line"><span class="comment">// a in b   b.contains(a)</span></span><br><span class="line"><span class="comment">// a !in b  !b.contains(a)</span></span><br><span class="line"><span class="comment">// a += b   a.plusAssign(b)</span></span><br><span class="line"><span class="comment">// a -= b   a.minusAssign(b)</span></span><br><span class="line"><span class="comment">// a *= b   a.timesAssign(b)</span></span><br><span class="line"><span class="comment">// a /= b   a.divAssign(b)</span></span><br><span class="line"><span class="comment">// a %= b   a.remAssign(b)</span></span><br><span class="line"><span class="comment">// a &gt; b    a.compareTo(b) &gt; 0</span></span><br><span class="line"><span class="comment">// a &lt; b    a.compareTo(b) &lt; 0</span></span><br><span class="line"><span class="comment">// a &gt;= b   a.compareTo(b) &gt;= 0</span></span><br><span class="line"><span class="comment">// a &lt;= b   a.compareTo(b) &lt;= 0</span></span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p><br>　　范例1：匿名函数与lambda表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"张三，你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个匿名函数，它没有参数也没有返回值，并将它赋值给名为“test2”的变量</span></span><br><span class="line"><span class="comment">// 这个变量的类型为“() → Unit”</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"李四，你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以更进一步，将“fun()”也省写掉</span></span><br><span class="line"><span class="comment">// 这种写法其实就是Kotlin中的lambda表达式，因此所谓的lambda其实就是匿名函数的特殊写法</span></span><br><span class="line"><span class="keyword">var</span> test3 = &#123;</span><br><span class="line">    println(<span class="string">"王五，你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然如果你想让匿名函数有参数、有返回值可以这么写：</span></span><br><span class="line"><span class="keyword">var</span> test4 = &#123; number: <span class="built_in">Int</span> -&gt;   <span class="comment">// 此处的“number: Int”就是参数列表</span></span><br><span class="line">    println(<span class="string">"王五，你好 <span class="variable">$number</span>"</span>)</span><br><span class="line">    <span class="comment">// 不需要在lambda表达式里写return语句，lambda主体中的最后一个表达式会视为返回值</span></span><br><span class="line">    <span class="number">3</span>   <span class="comment">// 此处的“3”就是返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test5 = &#123; a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若编译器无法推断出匿名函数的类型时，则函数的类型需要直接在变量后面明确指出</span></span><br><span class="line"><span class="comment">// 下面的匿名函数：接收一个Int参数，返回值为Int类型</span></span><br><span class="line"><span class="keyword">var</span> test6: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;</span><br><span class="line">    <span class="comment">// it是内置的关键词，如果你的lambda只有1个参数，则可以直接使用it表示那个参数</span></span><br><span class="line">    it + <span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test1()</span><br><span class="line">    test2()</span><br><span class="line">    test3()</span><br><span class="line">    println(test4(<span class="number">666</span>))</span><br><span class="line">    println(test5(<span class="number">555</span>, <span class="number">111</span>))</span><br><span class="line">    println(test6(<span class="number">555</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：传递末尾的lambda表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们在创建数组的时候，其实就是用到了lambda表达式</span></span><br><span class="line">    <span class="keyword">var</span> array = IntArray(<span class="number">5</span>) &#123;</span><br><span class="line">        it + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实IntArray的构造函数的签名是这样的：</span></span><br><span class="line">    <span class="comment">// public inline constructor(size: Int, init: (Int) -&gt; Int)</span></span><br><span class="line">    <span class="comment">// 它接受两个参数，第二个参数是一个函数，</span></span><br><span class="line">    <span class="comment">// 按照 Kotlin 惯例，如果函数的最后一个参数是函数，</span></span><br><span class="line">    <span class="comment">// 那么作为相应参数传入的 lambda 表达式可以放在圆括号之外</span></span><br><span class="line"></span><br><span class="line">    println(array.contentToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：指定返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式默认是以最后一行为其返回值</span></span><br><span class="line"><span class="comment">// 但我们也可以像break、continue那样，事先定义一个标记</span></span><br><span class="line"><span class="comment">// 然后通过“return@标记名”的方式来明确指定返回值</span></span><br><span class="line"><span class="keyword">var</span> test1 = <span class="symbol">mark@</span>&#123; isFinish: <span class="built_in">Boolean</span> -&gt;</span><br><span class="line">    <span class="keyword">if</span> (isFinish) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@mark</span> <span class="number">666</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@mark</span> <span class="number">777</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输出：666</span></span><br><span class="line">    println(test1(<span class="literal">true</span>))</span><br><span class="line">    <span class="comment">// 输出：777</span></span><br><span class="line">    println(test1(<span class="literal">false</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：真正的匿名函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范例1中的代码，虽然我嘴上说定义的是匿名函数，但其实还是用变量持有了函数的引用</span></span><br><span class="line"><span class="comment">// 因此严格意义来说，那些函数不能算是匿名的</span></span><br><span class="line"><span class="comment">// 本函数用来创建一个真正的匿名函数，匿名函数的类型为“(Int, Int) -&gt; Int”</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createFunction</span><span class="params">()</span></span>: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt;</span><br><span class="line">    <span class="comment">// 直接用一对大括号就可以定义一个匿名函数了</span></span><br><span class="line">    <span class="comment">// “a: Int, b: Int”是匿名函数的参数列表</span></span><br><span class="line">    <span class="comment">// 匿名函数的返回值编译器能推算出来，就是“a+b”的值，也就是Int类型的</span></span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先调用createFunction，取得返回值后，紧接着通过“(5, 5)”调用匿名函数</span></span><br><span class="line">    <span class="comment">// 匿名函数被调用后，就无效了，因为外界没有任何地方持有该函数的引用</span></span><br><span class="line">    println(createFunction()(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="comment">// 下面这种写法其实也是操作符重载，调用函数时可以用“函数名()”也可以用“函数名.invoke()”</span></span><br><span class="line">    <span class="comment">// a()              a.invoke()</span></span><br><span class="line">    <span class="comment">// a(i)             a.invoke(i)</span></span><br><span class="line">    <span class="comment">// a(i, j)          a.invoke(i, j)</span></span><br><span class="line">    <span class="comment">// a(i_1, ……, i_n)  a.invoke(i_1, ……, i_n)</span></span><br><span class="line">    println(createFunction().invoke(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><br>　　范例1：实例内部类和静态内部类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例内部类，其会持有外部类的引用，可以访问外部类的成员</span></span><br><span class="line">    <span class="comment">// 创建实例内部类对象前，需要先创建外部类的引用</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"<span class="variable">$name</span>,<span class="variable">$age</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="comment">// 直接通过外部类名访问，不持有外部类引用，不可访问外部类成员</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"无法读取外部类成员"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Outer(<span class="string">"张三"</span>, <span class="number">18</span>).Inner().sayHello()</span><br><span class="line">    Outer.StaticInner().sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：匿名内部类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Java中有匿名内部类的概念，以Android为例，通常我们会这么写代码：</span></span><br><span class="line"><span class="comment">// Button btn = findViewById(R.id.btn);</span></span><br><span class="line"><span class="comment">// btn.setOnClickListener(new View.OnClickListener()&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码的语义是：</span></span><br><span class="line"><span class="comment">// 创建一个View.OnClickListener的实现类，这个类是匿名的（没有名字），</span></span><br><span class="line"><span class="comment">// 同时会为这个匿名类实例化一个对象，以便后续使用。</span></span><br><span class="line"><span class="comment">// 也就是说，创建匿名类时必须同时产生一个对象，</span></span><br><span class="line"><span class="comment">// 若只是创建一个单独匿名类，则是无意义的，因为没法使用它。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中，也支持这个操作（创建匿名类的同时创建一个对象），这个操作通过“对象表达式”来实现</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用“object”关键字定义一个对象表达式，表达式会定义匿名类并实例化出一个该类的对象</span></span><br><span class="line">    <span class="comment">// “:”表示继承/实现关系，当前匿名类继承了Person类，</span></span><br><span class="line">    <span class="comment">// 同时实现了View.OnClickListener和Runnable两个接口</span></span><br><span class="line">    <span class="comment">// 匿名对象可以继承/实现0~n个类/接口，其内部需要重写所有继承而来的抽象方法</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">object</span> : View.OnClickListener, Runnable, Person(<span class="string">"张三"</span>, <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 由于是继承了Person类，所以其内部可以访问Person类的对象</span></span><br><span class="line">            println(<span class="string">"我叫<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁了，onClick被调用了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"我叫<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁了，run被调用了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.onClick(<span class="literal">null</span>)</span><br><span class="line">    a.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：没有任何父类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若匿名内部类没有任何父类，则就可以省写为下面这样</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"我没有任何父类"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：单例模式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两个范例是将对象表达式写在某个函数内部，以此来实现匿名内部类。</span></span><br><span class="line"><span class="comment">// 事实上，我们可以将对象表达式定义在顶层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当对象表达式被定义在顶层时，我们需要为那个匿名对象指定一个名字</span></span><br><span class="line"><span class="comment">// 下面就定义了一个名为“SingleInstance”的对象</span></span><br><span class="line"><span class="comment">// 这个对象是匿名类的唯一一个对象，即我们可以用这个特性来实现单例设计模式</span></span><br><span class="line"><span class="keyword">object</span> SingleInstance &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"我叫<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对象的初始化过程是线程安全的并且在首次访问时进行</span></span><br><span class="line">    SingleInstance.name = <span class="string">"张三"</span></span><br><span class="line">    SingleInstance.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：伴生对象与静态函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于Kotlin需要支持跨平台，所以在Kotlin中没有Java语言中的静态函数的概念，</span></span><br><span class="line"><span class="comment">// 但实际开发中我们不可避免的会有一些静态工具类，总不能每次使用工具类都先创建一个对象吧</span></span><br><span class="line"><span class="comment">// 于是Kotlin就提供了一个“伴生对象”的概念</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类的内部使用“companion object”关键字来定义一个伴生对象</span></span><br><span class="line">    <span class="comment">// 这个对象可以有名字，也可以没有名字，如果没名字，则默认叫“Companion”</span></span><br><span class="line">    <span class="comment">// 下面这个伴生对象的名字叫“Instance”</span></span><br><span class="line">    <span class="comment">// 我们先将自己的“静态函数”定义到伴生对象的内部，外界就可以直接通过类名来调用这个函数了</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Instance &#123;</span><br><span class="line">        <span class="comment">// 定义一个常量</span></span><br><span class="line">        const <span class="keyword">val</span> FORMAT_TIME = <span class="string">"%02d:%02d:%02d"</span></span><br><span class="line">        <span class="comment">// 定义一个变量</span></span><br><span class="line">        <span class="keyword">var</span> number = <span class="number">666</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">formatDuring</span><span class="params">(mss: <span class="type">Long</span>)</span></span>: String? &#123;</span><br><span class="line">            <span class="keyword">val</span> hours = mss % (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line">            <span class="keyword">val</span> minutes = mss % (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>) / (<span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">            <span class="keyword">val</span> seconds = mss % (<span class="number">1000</span> * <span class="number">60</span>) / <span class="number">1000</span></span><br><span class="line">            <span class="keyword">return</span> String.format(FORMAT_TIME, hours, minutes, seconds)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将20分钟格式化显示</span></span><br><span class="line">    <span class="comment">// 通过“类名.方法名”直接调用</span></span><br><span class="line">    println(TextUtil.formatDuring(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">20</span>))</span><br><span class="line">    <span class="comment">// 通过“类名.伴生对象名.方法名”调用</span></span><br><span class="line">    println(TextUtil.Instance.formatDuring(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">20</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义了伴生对象的类，依然可以被实例化</span></span><br><span class="line">    <span class="keyword">var</span> util = TextUtil()</span><br><span class="line">    <span class="comment">// 普通对象无法访问伴生对象内定义的函数和方法，反之也一样（伴生对象无法访问外部类的成员）</span></span><br><span class="line">    <span class="comment">// 下面两个代码会编译报错</span></span><br><span class="line">    <span class="comment">// util.formatDuring(1000 * 60 * 20)</span></span><br><span class="line">    <span class="comment">// util.number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p><br>　　范例1：数据类入门。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Java中有JavaBean的概念，JavaBean用来保存数据，并为每个属性提供get、set方法</span></span><br><span class="line"><span class="comment">// 在Kotlin中提供了类似的概念，就是“数据类”，使用“data”关键词来定义</span></span><br><span class="line"><span class="comment">// 下面的“News”类表示一条新闻，“id”表示新闻的ID，“comment”表示新闻的用户评论数量</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">News</span></span>(<span class="keyword">var</span> id: String, <span class="keyword">var</span> comment: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> news1 = News(<span class="string">"100001"</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">var</span> news2 = News(<span class="string">"100002"</span>, <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器会为数据类自动生成如下几个函数：</span></span><br><span class="line">    <span class="comment">// 1、equals()/hashCode()</span></span><br><span class="line">    <span class="comment">// 2、toString()</span></span><br><span class="line">    <span class="comment">// 3、componentN()函数，按声明顺序对应于所有属性。</span></span><br><span class="line">    <span class="comment">// 4、copy()函数</span></span><br><span class="line">    <span class="comment">// 5、类内每个属性的get、set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过AS菜单栏的“Tool”-&gt;“Kotlin”-&gt;“Show Kotlin Bytecode” -&gt;“Decompile”功能</span></span><br><span class="line">    <span class="comment">// 来观察生成的字节码里是否有上面说的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出：News(id=100001, comment=100)</span></span><br><span class="line">    println(news1)</span><br><span class="line">    <span class="comment">// 输出：News(id=100002, comment=120)</span></span><br><span class="line">    println(news2)</span><br><span class="line">    <span class="comment">// 输出：false</span></span><br><span class="line">    println(news1 == news2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：自己重写函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上个范例生成的News.class类里没有无参构造方法，因此实例化对象的同时必须指定参数</span></span><br><span class="line"><span class="comment">// 但实际开发中，我们的JavaBean都是由JSON解析出来的，而JSON是需要无参构造方法的</span></span><br><span class="line"><span class="comment">// 我们可以给主构造器里的参数赋默认值来解决这个问题，此时就会生成无参构造方法了</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">News1</span></span>(<span class="keyword">var</span> id: String? = <span class="literal">null</span>, <span class="keyword">var</span> comment: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 小提示：如果类体中没有东西，可以省写类体（那对大括号）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时还有一个问题：</span></span><br><span class="line"><span class="comment">// 编译器自动帮我们生成的equals、hashCode等函数，是基于主构造函数里列出的属性的。</span></span><br><span class="line"><span class="comment">// 也就是说，若主构造器里有10个参数，那么equals等函数内部就让这10个参数参与计算，</span></span><br><span class="line"><span class="comment">// 但两个“News”对象是否相等，应该只判断其id属性值是否相等就可以，</span></span><br><span class="line"><span class="comment">// 没必要吧comment也算上，一旦算上了，若对象的comment属性值变了，就会认为不相等，显然不科学</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">News2</span></span>(<span class="keyword">var</span> id: String? = <span class="literal">null</span>, <span class="keyword">var</span> comment: <span class="built_in">Int</span> = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果在数据类体中有显式实现 equals()、 hashCode() 或者 toString()，</span></span><br><span class="line">    <span class="comment">// 或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (other) &#123;</span><br><span class="line">            !<span class="keyword">is</span> News2 -&gt; <span class="literal">false</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">this</span> === other ||</span><br><span class="line">                    id == other.id</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要注意的是，不允许为 componentN() 以及 copy() 函数提供显式实现。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输出：false</span></span><br><span class="line">    println(News2(<span class="string">"1001"</span>) == News2(<span class="string">"1002"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：屏蔽某个属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。</span></span><br><span class="line"><span class="comment">// 如需在生成的实现中排除一个属性，请将其声明在类体中：</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">News2</span></span>(<span class="keyword">var</span> id: String? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 此时那些生成的函数里，就不会考虑这个属性了</span></span><br><span class="line">    <span class="keyword">var</span> comment: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：</span></span><br><span class="line"><span class="comment">// 主构造函数需要至少有一个参数。</span></span><br><span class="line"><span class="comment">// 主构造函数的所有参数需要标记为 val 或 var。</span></span><br><span class="line"><span class="comment">// 数据类不能是抽象、开放、密封或者内部的。</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例4：解构。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事实上，数据类型主构造函数内列出的属性，也被称为“组件”</span></span><br><span class="line"><span class="comment">// 它们按照出现的顺序，被依次编号，从1开始</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">News</span></span>(<span class="keyword">var</span> id: String? = <span class="literal">null</span>, <span class="keyword">var</span> comment: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> news = News(<span class="string">"1001"</span>, <span class="number">666</span>)</span><br><span class="line">    <span class="comment">// 组件1就表示对象的id属性，组件2就表示对象的comment属性</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;news.component1()&#125;</span>,<span class="subst">$&#123;news.component2()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这种语法称为解构声明，一个解构声明同时创建多个变量。</span></span><br><span class="line">    <span class="comment">// 声明了两个新变量： id 和 comment，并且可以独立使用它们。</span></span><br><span class="line">    <span class="keyword">var</span> (id, comment) = news</span><br><span class="line">    println(<span class="string">"<span class="variable">$id</span>,<span class="variable">$comment</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个解构声明会被编译成以下代码：</span></span><br><span class="line">    <span class="comment">// val id = news.component1()</span></span><br><span class="line">    <span class="comment">// val comment = news.component2()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：多返回值函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你的函数需要返回2个值，可以使用Kotlin内置的Pair类来实现</span></span><br><span class="line"><span class="comment">// 下面“Pair&lt;Int, String&gt;”中的Int、String是泛型，可以改为你想要的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">create2Result</span><span class="params">()</span></span>: Pair&lt;<span class="built_in">Int</span>, String&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Pair(<span class="number">10086</span>, <span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你的函数需要返回3个值，可以使用Kotlin内置的Triple类来实现</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">create3Result</span><span class="params">()</span></span>: Triple&lt;<span class="built_in">Int</span>, String, <span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Triple(<span class="number">10086</span>, <span class="string">"World"</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> towResult = create2Result()</span><br><span class="line">    <span class="comment">// 可以通过Pair类的两个属性来访问</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;towResult.first&#125;</span>, <span class="subst">$&#123;towResult.second&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用解构表达式来解构返回值</span></span><br><span class="line">    <span class="comment">// 下面就是将Triple类的三个数据，解构到了a、b、c三个变量中了</span></span><br><span class="line">    <span class="keyword">var</span> (a, b, c) = create3Result()</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;a&#125;</span>, <span class="subst">$&#123;b&#125;</span>,<span class="subst">$&#123;c&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p><br>　　范例1：枚举的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用“enum”定义一个枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面定义四个枚举常量，每个枚举常量都是一个对象，枚举常量以逗号分隔。</span></span><br><span class="line">    RED, GREEN, YELLOW, BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为枚举类指定主构造函数，同时实现了“Runnable”接口</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color2</span></span>(<span class="keyword">var</span> colorName: String, <span class="keyword">var</span> colorValue: <span class="built_in">Int</span>) : Runnable &#123;</span><br><span class="line">    <span class="comment">// 枚举常量在创建的同时，需要为主构造器提供参数</span></span><br><span class="line">    RED(<span class="string">"红色"</span>, <span class="number">100</span>),</span><br><span class="line">    GREEN(<span class="string">"绿色"</span>, <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 每个枚举常量也可以单独重写自己的方法</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我是<span class="subst">$&#123;colorName&#125;</span>,你好啊！"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    YELLOW(<span class="string">"黄色"</span>, <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"黄色的run"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    BLUE(<span class="string">"蓝色"</span>, <span class="number">400</span>); <span class="comment">// 枚举常量和其它成员之间需要用“;”间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接在枚举类内部重写toString、run方法，</span></span><br><span class="line">    <span class="comment">// 若枚举常量自己没有重写它们，则会调用枚举类重写的函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> colorName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"通用的run"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输出：RED,GREEN</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;Color1.RED&#125;</span>,<span class="subst">$&#123;Color1.GREEN&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// 输出：红色,我是绿色,你好啊！</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;Color2.RED&#125;</span>,<span class="subst">$&#123;Color2.GREEN&#125;</span>"</span>)</span><br><span class="line">    Color2.RED.run()</span><br><span class="line">    Color2.YELLOW.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：枚举的应用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, GREEN, YELLOW, BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给Color类扩展一个函数，获取当前枚举对象的下一个枚举对象</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Color.<span class="title">next</span><span class="params">()</span></span>: Color &#123;</span><br><span class="line">    <span class="comment">// 所有枚举常量按照其定义的顺序来定，都一个“ordinal”属性，表示其编号，从0开始。</span></span><br><span class="line">    <span class="keyword">return</span> Color.values()[(ordinal + <span class="number">1</span>) % Color.values().size]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Color.RED.next())</span><br><span class="line">    println(Color.GREEN.next())</span><br><span class="line">    println(Color.YELLOW.next())</span><br><span class="line">    println(Color.BLUE.next())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在when表达式中使用</span></span><br><span class="line">    <span class="keyword">var</span> color = Color.RED</span><br><span class="line">    <span class="keyword">var</span> colorName = <span class="keyword">when</span> (color) &#123;</span><br><span class="line">        Color.RED -&gt; <span class="string">"红色"</span></span><br><span class="line">        Color.GREEN -&gt; <span class="string">"绿色"</span></span><br><span class="line">        Color.YELLOW -&gt; <span class="string">"黄色"</span></span><br><span class="line">        Color.BLUE -&gt; <span class="string">"蓝色"</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(colorName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两个枚举常量比较大小时，比较的就是枚举的ordinal</span></span><br><span class="line">    <span class="comment">// 输出：true</span></span><br><span class="line">    println(Color.BLUE &gt; Color.GREEN)</span><br><span class="line">    <span class="comment">// 枚举也可以定义区间</span></span><br><span class="line">    <span class="keyword">var</span> colorRange = Color.GREEN..Color.BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p><br>　　范例1：List。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个不可变的List集合，所谓不可变，就是该List对象没有提供add、remove、set等方法。</span></span><br><span class="line">    <span class="keyword">var</span> list1 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 可以通过get函数获取数据，也可以通过中括号方式获取</span></span><br><span class="line">    println(<span class="string">"第1个元素为：<span class="subst">$&#123;list1.get(<span class="number">0</span>)&#125;</span>，最后一个元素为：<span class="subst">$&#123;list1[list1.size - <span class="number">1</span>]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，list1的类型是“List&lt;Int&gt;”，而这个List是Kotlin里定义接口，不是Java的List。</span></span><br><span class="line">    <span class="comment">// 虽然如此，但是在JVM环境下，最终编译出来的接口还是会指向Java的List。</span></span><br><span class="line">    <span class="comment">// 原因也很简单，Kotlin除了支持JVM平台，还支持JS、Native平台，</span></span><br><span class="line">    <span class="comment">// 因此Kotlin需要定义自己的集合接口，作为统一的抽象，而具体的实现，可以由各个平台来做。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可变的List集合，MutableList也是Kotlin里定义接口。</span></span><br><span class="line">    <span class="keyword">var</span> list2 = mutableListOf(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    list2.<span class="keyword">set</span>(<span class="number">0</span>, <span class="number">666</span>)</span><br><span class="line">    list2[<span class="number">1</span>] = <span class="number">777</span></span><br><span class="line">    <span class="comment">// MutableList会自动扩容</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        list2.add(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运算符重载，“+=”表示添加元素，“-=”表示删除元素。</span></span><br><span class="line">    list2 += <span class="number">5</span></span><br><span class="line">    <span class="comment">// 输出：[666, 777, 8, 9, 10, 100, 100, 100, 5]</span></span><br><span class="line">    println(list2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的ArrayList是Kotlin中定义，它本质上是使用“typealias”关键字定义一个类型别名</span></span><br><span class="line">    <span class="comment">// 这个别名在JVM环境下，指向的是Java的java.util.ArrayList类</span></span><br><span class="line">    <span class="comment">// 因此java.util.ArrayList类的所有方法，在Kotlin中的ArrayList类中都可以用</span></span><br><span class="line">    <span class="keyword">var</span> list3 = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list3.add(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    println(list3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：Map。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 不可变的Map</span></span><br><span class="line">    <span class="keyword">var</span> map1 = mapOf(Pair(<span class="string">"姓名"</span>, <span class="string">"张三"</span>), Pair(<span class="string">"姓名"</span>, <span class="string">"李四"</span>))</span><br><span class="line">    println(<span class="string">"集合长度：<span class="subst">$&#123;map1.size&#125;</span>，<span class="subst">$&#123;map1.get("姓名")&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变的Map</span></span><br><span class="line">    <span class="comment">// 关键词“to”其实就是前面介绍的中缀表达式</span></span><br><span class="line">    <span class="keyword">var</span> map2 = mutableMapOf(<span class="string">"姓名"</span> to <span class="string">"张三"</span>, <span class="string">"年龄"</span> to <span class="string">"20"</span>)</span><br><span class="line">    <span class="comment">// 访问Map的元素也可以用中括号的形式</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;map2["姓名"]&#125;</span> ，<span class="subst">$&#123;map2["年龄"]&#125;</span>"</span>)</span><br><span class="line">    println(map2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map3 = TreeMap&lt;String, String&gt;()</span><br><span class="line">    map3.put(<span class="string">"姓名"</span>,<span class="string">"李四"</span>)</span><br><span class="line">    map3.put(<span class="string">"年龄"</span>,<span class="string">"18"</span>)</span><br><span class="line">    println(map3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你要使用TreeMap，则就会直接导入java.util包中的类</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例3：集合的遍历。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> id: String=<span class="string">""</span>, <span class="keyword">var</span> name: String=<span class="string">""</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> Person) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.id == other.id</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.hashCode()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> map = TreeMap&lt;String, Person&gt;()</span><br><span class="line">    map.put(<span class="string">"1003"</span>, Person(<span class="string">"1003"</span>, <span class="string">"王五"</span>, <span class="number">20</span>))</span><br><span class="line">    map.put(<span class="string">"1001"</span>, Person(<span class="string">"1001"</span>, <span class="string">"张三"</span>, <span class="number">18</span>))</span><br><span class="line">    map.put(<span class="string">"1004"</span>, Person(<span class="string">"1004"</span>, <span class="string">"赵六"</span>, <span class="number">21</span>))</span><br><span class="line">    map.put(<span class="string">"1002"</span>, Person(<span class="string">"1002"</span>, <span class="string">"李四"</span>, <span class="number">19</span>))</span><br><span class="line">    <span class="comment">// 普通遍历</span></span><br><span class="line">    <span class="keyword">for</span> (entry <span class="keyword">in</span> map) &#123;</span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;entry.key&#125;</span> -&gt; <span class="subst">$&#123;entry.value&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// forEach遍历</span></span><br><span class="line">    <span class="comment">// forEach函数接收一个“(Map.Entry&lt;K, V&gt;) -&gt; Unit”的参数</span></span><br><span class="line">    <span class="comment">// 于是按照lambda表达式的规则，我们可以直接简写成下面这样，it表示当前元素</span></span><br><span class="line">    map.forEach &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素的key为“1003”，则跳过当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (it.key == <span class="string">"1003"</span>) &#123;</span><br><span class="line">            <span class="comment">// forEach是一个已经定义好的标签，我们可以直接用</span></span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：集合的过滤/筛选。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个不可变集合</span></span><br><span class="line">    <span class="keyword">var</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Iterable接口的“filter”扩展函数筛选集合里的元素</span></span><br><span class="line">    <span class="comment">// “filter”扩展函数接收一个“(T) -&gt; Boolean”的参数函数</span></span><br><span class="line">    <span class="comment">// 运行时，“filter”函数会依次为集合的每个元素调用参数函数，若返回true，则认为符合条件</span></span><br><span class="line">    <span class="comment">// 整个集合遍历完毕后，“filter”函数就把所有返回true的元素组合成一个新的集合，返回给调用者</span></span><br><span class="line">    <span class="comment">// 也就是说，我们只需要把筛选条件写在参数函数里即可</span></span><br><span class="line">    list = list.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：2, 4, 6, 8</span></span><br><span class="line">    println(list.joinToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：集合的转换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个不可变集合</span></span><br><span class="line">    <span class="keyword">var</span> list1 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map函数用来执行转换。</span></span><br><span class="line">    <span class="comment">// map函数会依次为集合里的每一个元素，调用一下参数函数，并将其返回值记录</span></span><br><span class="line">    <span class="comment">// 当整个集合遍历完毕后，就将参数函数的返回值组成一个新的集合，并返回</span></span><br><span class="line">    <span class="comment">// 下面的代码用来将列表里的每个数字*100，然后转成String。</span></span><br><span class="line">    <span class="keyword">var</span> list2 = list1.map &#123; <span class="string">"串<span class="subst">$&#123;it * <span class="number">100</span>&#125;</span>"</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出：串100, 串200, 串300, 串400, 串500, 串600, 串700, 串800</span></span><br><span class="line">    println(list2.joinToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例6：混合运算。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    list1</span><br><span class="line">        .filter &#123;</span><br><span class="line">            it % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">        &#125;.map &#123;</span><br><span class="line">            <span class="string">"串<span class="subst">$&#123;it * <span class="number">100</span>&#125;</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        .forEach &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例7：flatMap。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 依次为集合里的每一个元素调用参数函数</span></span><br><span class="line">    <span class="comment">// 参数函数会要求返回一个集合，flatMap会记下来</span></span><br><span class="line">    <span class="comment">// 当整个集合遍历完毕后，floatMap会将记下来的所有集合中的所有数据，合并到一个新集合中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码会产生3个集合：</span></span><br><span class="line">    <span class="comment">// [1]、[1,2]、[1,2,3]</span></span><br><span class="line">    <span class="comment">// flatMap最终会将3个集合内的所有元素合并到一个新集合中</span></span><br><span class="line">    <span class="keyword">var</span> list2 = list1.flatMap &#123; <span class="number">1.</span>.it &#125;</span><br><span class="line">    <span class="comment">// 输出：6</span></span><br><span class="line">    println(list2.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p><br>　　在 Kotlin 中有这四个可见性修饰符：<code>private</code>、 <code>protected</code>、 <code>internal</code>和<code>public</code>，默认可见性是<code>public</code>。类、对象、接口、构造函数、方法与属性及其<code>setter</code>都可以有可见性修饰符，<code>getter</code>总是与属性有着相同的可见性。</p>
<p><br>　　范例1：包与顶层声明。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件名：example.kt</span></span><br><span class="line"><span class="comment">// 函数、属性和类、对象和接口可以直接在包内的顶层声明。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你不使用任何可见性修饰符，默认为 public，这意味着你的声明将随处可见。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你声明为 private，它只会在声明它的文件内可见。</span></span><br><span class="line"><span class="comment">// 在 example.kt 内可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; …… &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bar: <span class="built_in">Int</span> = <span class="number">5</span> <span class="comment">// 该属性随处可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>         <span class="comment">// setter只在 example.kt 内可见</span></span><br><span class="line">                        <span class="comment">// getter的可见性必须和属性可见性一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你声明为 internal，它会在相同模块内随处可见（什么是相同模块，后述）。</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> baz = <span class="number">6</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// protected 修饰符不适用于顶层声明。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要使用另一包中可见的顶层声明，需要将其导入进来。</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例2：类成员。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于类内部声明的成员：</span></span><br><span class="line"><span class="comment">// private 意味着该成员在这个类内部（包含其所有成员）可见；</span></span><br><span class="line"><span class="comment">// protected 意味着该成员具有与 private 一样的可见性，但也在子类中可见。</span></span><br><span class="line"><span class="comment">// internal 意味着能见到类声明的本模块内的任何客户端都可见其 internal 成员。</span></span><br><span class="line"><span class="comment">// public 意味着能见到类声明的任何客户端都可见其 public 成员。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你覆盖一个 protected 或 internal 成员并且没有显式指定其可见性，</span></span><br><span class="line"><span class="comment">// 该成员还会具有与原始成员相同的可见性。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">val</span> c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> d = <span class="number">4</span>  <span class="comment">// 默认 public</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> e: <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> : <span class="type">Outer</span></span>() &#123;</span><br><span class="line">    <span class="comment">// a 不可见</span></span><br><span class="line">    <span class="comment">// b、c、d 可见</span></span><br><span class="line">    <span class="comment">// Nested 和 e 可见</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> b = <span class="number">5</span>   <span class="comment">// “b”为 protected</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> c = <span class="number">7</span>   <span class="comment">// 'c' is internal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unrelated</span></span>(o: Outer) &#123;</span><br><span class="line">    <span class="comment">// o.a、o.b 不可见</span></span><br><span class="line">    <span class="comment">// o.c 和 o.d 可见（相同模块）</span></span><br><span class="line">    <span class="comment">// Outer.Nested 不可见，Nested::e 也不可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：主构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 您需要添加一个显式constructor关键字。</span></span><br><span class="line"><span class="comment">// 默认情况下，所有构造函数都是 public，下面的构造函数是私有的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(a: <span class="built_in">Int</span>) &#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，局部变量、函数和类不能有可见性修饰符。</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例4：模块。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 可见性修饰符 internal 意味着该成员只在相同模块内可见。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所谓的模块就是：</span></span><br><span class="line"><span class="comment">// 一个 IntelliJ IDEA 模块</span></span><br><span class="line"><span class="comment">// 一个 Maven 项目</span></span><br><span class="line"><span class="comment">// 一个 Gradle 源代码集（例外是 test 源代码集可以访问 main 的 internal 声明）</span></span><br><span class="line"><span class="comment">// 一次 &lt;kotlinc&gt; Ant 任务执行所编译的一套文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中第四条是本质，即同批次编译出来的文件属于相同的模块。</span></span><br><span class="line"><span class="comment">// 直观的讲，大致可以认为模块就是一个jar包、一个aar包。</span></span><br><span class="line"><span class="comment">// internal关键字一般由SDK开发者用于隐藏模块内部细节实现，一些特殊的类、函数不想给外界使用。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要知道的是，internal是Kotlin提出的概念。</span></span><br><span class="line"><span class="comment">// 如果你在Java语言中调用Kotlin的internal成员，默认情况下也是可以调的。</span></span><br><span class="line"><span class="comment">// 可以用“@JvmName”注解来解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个注解用来修改“sayHello”函数被编译后生成的函数名称</span></span><br><span class="line">    <span class="comment">// 若我们把名称搞成“%”开头，那么在Java端就无法调用了，因为违反Java标识符命名规定。</span></span><br><span class="line">    <span class="meta">@JvmName(<span class="meta-string">"%ksjfhks"</span>)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Hello World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进阶特性"><a href="#进阶特性" class="headerlink" title="进阶特性"></a>进阶特性</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><br>　　范例1：代理是干什么用的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个飞翔接口，其内有四个函数，每个函数对应一种飞行姿势</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly1</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly2</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly3</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly4</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个鸟类，实现了这四种飞行姿势</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>() : Fly &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly1</span><span class="params">()</span></span> = println(<span class="string">"飞行姿势-1！"</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly2</span><span class="params">()</span></span> = println(<span class="string">"飞行姿势-2！"</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly3</span><span class="params">()</span></span> = println(<span class="string">"飞行姿势-3！"</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly4</span><span class="params">()</span></span> = println(<span class="string">"飞行姿势-4！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时产品有个需求：在Fly实现类执行fly1的时候，记录一些信息，以便后续统计分析</span></span><br><span class="line"><span class="comment">// 需求分析：</span></span><br><span class="line"><span class="comment">// 1、记录信息的操作显然不能在Fly的某个子类（比如Bird）中写，因为任何子类都可能有这个需求</span></span><br><span class="line"><span class="comment">// 2、现在是fly1需要记录，说不定以后Fly类还会提供一个fly5函数，且fly5也需要记录</span></span><br><span class="line"><span class="comment">// 为了实现这个需求，我们打算定义一个新类，由其执行记录任务，同时它需要实现Fly接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirdRecord1</span></span>(<span class="keyword">var</span> bird: Fly) : Fly &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bird.fly1()</span><br><span class="line">        println(<span class="string">"记录数据啦"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bird.fly2()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly3</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bird.fly3()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly4</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bird.fly4()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的代码有个问题：目前只有fly1需要记录数据，但我们却重写了另外三个函数</span></span><br><span class="line"><span class="comment">// 对于此类情况，Kotlin提供了代理功能，可以让我们只重写fly1就可以了</span></span><br><span class="line"><span class="comment">// 写法很简单，只需要在类主构造器的后面加上“by bird”就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirdRecord2</span></span>(<span class="keyword">var</span> bird: Fly) : Fly <span class="keyword">by</span> bird &#123;</span><br><span class="line">    <span class="comment">// 上面这行代码的语义就是：</span></span><br><span class="line">    <span class="comment">// 1、定义一个名为BirdRecord2的类，接收一个名为bird的Fly实现类</span></span><br><span class="line">    <span class="comment">// 2、BirdRecord2类也实现了Fly接口，只不过接口中的方法默认由bird对象去实现</span></span><br><span class="line">    <span class="comment">// 3、但若BirdRecord2类明确提供了方法实现，则优先调用重写后的方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bird.fly1()</span><br><span class="line">        println(<span class="string">"记录数据啦"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bird = Bird()</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// 飞行姿势-1！</span></span><br><span class="line">    <span class="comment">// 记录数据啦</span></span><br><span class="line">    BirdRecord1(bird).fly1()</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// 飞行姿势-1！</span></span><br><span class="line">    <span class="comment">// 记录数据啦</span></span><br><span class="line">    BirdRecord2(bird).fly1()</span><br><span class="line">    <span class="comment">// 输出：飞行姿势-4！</span></span><br><span class="line">    BirdRecord2(bird).fly4()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：代理-属性隐藏。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> message: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> message = <span class="string">"BaseImpl: x = <span class="variable">$x</span>"</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; println(message) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b &#123;</span><br><span class="line">    <span class="comment">// 在 b 的 `print` 实现中不会访问到这个属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> message = <span class="string">"Message of Derived"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> derived = Derived(BaseImpl(<span class="number">10</span>))</span><br><span class="line">    <span class="comment">// 程序输出：</span></span><br><span class="line">    <span class="comment">// BaseImpl: x = 10</span></span><br><span class="line">    <span class="comment">// Message of Derived</span></span><br><span class="line">    derived.print()</span><br><span class="line">    println(derived.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：代理 - 属性值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个name属性，类型是String，其默认值是一个PersonProxy对象。</span></span><br><span class="line">    <span class="comment">// 当JVM需要读写name的值时，不再直接读写，而是通过代理类来读写。</span></span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> PersonProxy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="string">"张三"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要获取属性值时（应该就是那个by关键字，待测试），调用此方法</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(person: <span class="type">Person</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">"前端访问<span class="subst">$&#123;property.name&#125;</span>"</span>)</span><br><span class="line">        <span class="comment">// 统一返回一个默认值</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要修改属性值时，调用此方法，执行修改，若你在方法里不做任何操作，则不会修改</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(person: <span class="type">Person</span>, property: <span class="type">KProperty</span>&lt;*&gt;, s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"前端请求修改 <span class="subst">$&#123;property.name&#125;</span> 属性的值从“<span class="subst">$&#123;this.value&#125;</span>”到“<span class="variable">$s</span>”"</span>)</span><br><span class="line">        <span class="keyword">this</span>.value = s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    println(p.name)</span><br><span class="line">    p.name = <span class="string">"李四"</span></span><br><span class="line">    println(p.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：属性代理 - 延迟初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Android开发时，下面的代码是比较常见的：</span></span><br><span class="line"><span class="comment">//class MainActivity : Activity() &#123;</span></span><br><span class="line"><span class="comment">//    var textView: TextView;</span></span><br><span class="line"><span class="comment">//    override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span><br><span class="line"><span class="comment">//        super.onCreate(savedInstanceState)</span></span><br><span class="line"><span class="comment">//        textView = findViewById(R.id.textView)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// 但是由于Kotlin的var属性要求定义的同时必须立即初始化，所以上面的代码是无法编译通过的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法1：为其赋值null</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity1</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> textView: TextView? = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        textView = findViewById(R.id.textView)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用TextView的时候，需要用“?.”，防止空指针</span></span><br><span class="line">        textView?.setText(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法2：使用“lateinit”关键字，将属性标记为稍后初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> textView: TextView;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 为了防止textView被重复初始化，Kotlin提供了"isInitialized"函数</span></span><br><span class="line">        <span class="comment">// 用来帮我们查看View是否已经初始化了</span></span><br><span class="line">        <span class="comment">// 很显然，这个解法也很差劲，也不推荐大家使用</span></span><br><span class="line">        <span class="keyword">if</span>(::textView.isInitialized)&#123;</span><br><span class="line">            textView = findViewById(R.id.textView)</span><br><span class="line">        &#125;</span><br><span class="line">        textView.setText(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法3：使用“lazy”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity3</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 这里必须使用“val”关键词定义属性</span></span><br><span class="line">    <span class="comment">// 下面代码的语义是：</span></span><br><span class="line">    <span class="comment">// 这个变量目前不需要初始化，当外界首次使用此变量时，</span></span><br><span class="line">    <span class="comment">// 就执行后面的lambda表达式里的语句进行初始化</span></span><br><span class="line">    <span class="keyword">val</span> textView <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.textView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        textView.setText(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事实上“lazy”是一个函数，我们进一步去查看其源码就会发现</span></span><br><span class="line"><span class="comment">// 它返回了一个名为“SynchronizedLazyImpl”的实现类，并将其赋值给textView</span></span><br><span class="line"><span class="comment">// 当textView每次访问值时，都会找SynchronizedLazyImpl类，而在其内部就会判断</span></span><br><span class="line"><span class="comment">// 若当前“SynchronizedLazyImpl”内部的属性未初始化，则调用lambda表达式初始化</span></span><br><span class="line"><span class="comment">// 若初始化过了，则直接返回对应的值。</span></span><br><span class="line"><span class="comment">// 说白了“SynchronizedLazyImpl”就是一个代理，一个中间商。</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例5：属性代理 - 监听值变化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 给属性添加观察者，当属性值改变时，会回调这个lambda表达式</span></span><br><span class="line">    <span class="comment">// “匿名用户”是这个属性的默认值</span></span><br><span class="line">    <span class="keyword">var</span> personName: String <span class="keyword">by</span> Delegates.observable(<span class="string">"匿名用户"</span>) &#123; </span><br><span class="line">        property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;property.name&#125;</span> &#123;<span class="subst">$&#123;oldValue&#125;</span> -&gt; <span class="subst">$&#123;newValue&#125;</span>&#125; "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = Person()</span><br><span class="line">    <span class="comment">// 输出：匿名用户</span></span><br><span class="line">    println(p.personName)</span><br><span class="line">    <span class="comment">// 输出：personName &#123;匿名用户 -&gt; 张三&#125;</span></span><br><span class="line">    p.personName = <span class="string">"张三"</span></span><br><span class="line">    <span class="comment">// 输出：张三</span></span><br><span class="line">    println(p.personName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><br>　　范例1：泛型基础。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于泛型是干什么用的，本文不再重复介绍，请参阅笔者写的《Java语言》一文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型类的定义：</span></span><br><span class="line"><span class="comment">// 在类名后面加上“&lt;泛型&gt;”即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">var</span> x: T, <span class="keyword">var</span> y: T)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型函数的定义：</span></span><br><span class="line"><span class="comment">// 在函数名称之前添加“&lt;泛型&gt;”即可</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">getPoint</span><span class="params">(x: <span class="type">T</span>, y: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在泛型的后面使用“:”可以限制泛型的上界</span></span><br><span class="line"><span class="comment">// 也就是说，泛型T只能是Number或者Number的子类</span></span><br><span class="line"><span class="comment">// 若没有使用“:”指明上界，则默认上界为“Any?”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2</span>&lt;<span class="type">T : Number</span>&gt;</span>(<span class="keyword">var</span> x: T, <span class="keyword">var</span> y: T)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Point&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    Point&lt;String&gt;(<span class="string">"331"</span>, <span class="string">"2332"</span>)</span><br><span class="line">    <span class="comment">// 由于编译器可以通过我们传递给主构造器的值推算出泛型的类型，</span></span><br><span class="line">    <span class="comment">// 因此上面的&lt;Int&gt;和&lt;String&gt;可以省写</span></span><br><span class="line">    Point(<span class="string">"331"</span>, <span class="string">"2332"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面语句会编译报错</span></span><br><span class="line">    <span class="comment">// Point2("331", "2332")</span></span><br><span class="line">    Point2(<span class="number">1.2</span>, <span class="number">5.4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：where子句。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型T必须是“Comparable&lt;T&gt;”的子类，返回值也需要是T类型的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">max1</span><span class="params">(x: <span class="type">T</span>, y: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当泛型需要满足多个条件时，可以使用“where”来列举所有条件</span></span><br><span class="line"><span class="comment">// 下面的泛型T需要满足两个条件：</span></span><br><span class="line"><span class="comment">// 1、T必须是Comparable&lt;T&gt;的子类</span></span><br><span class="line"><span class="comment">// 2、T必须是Number的子类</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">max2</span><span class="params">(x: <span class="type">T</span>, y: <span class="type">T</span>)</span></span>: T</span><br><span class="line">        where T : Comparable&lt;T&gt;,</span><br><span class="line">              T : Number &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(max1(<span class="number">19</span>, <span class="number">332</span>))</span><br><span class="line">    println(max1(<span class="string">"ABC"</span>, <span class="string">"abc"</span>))</span><br><span class="line">    <span class="comment">// 此时若传递字符串给max2函数，则会编译报错</span></span><br><span class="line">    println(max2(<span class="number">4.4</span>, <span class="number">5.3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：不型变。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">var</span> x: T, <span class="keyword">var</span> y: T) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先来重申一下两个概念：</span></span><br><span class="line">    <span class="comment">// “类”和“类型”，List是一个类也是一个类型，“List&lt;String&gt;”和“List&lt;Int&gt;”只是一个类型。</span></span><br><span class="line">    <span class="comment">// “子类”和“子类型”，</span></span><br><span class="line">    <span class="comment">//     Int是Number的“子类”</span></span><br><span class="line">    <span class="comment">//     Int是Int?的“子类型”，虽然两者都对应Int类，但二者之间没有“继承”关系。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p1: Point&lt;<span class="built_in">Long</span>&gt; = Point(<span class="number">1</span>L, <span class="number">2</span>L)</span><br><span class="line">    <span class="comment">// 下面代码会编译出错，因为默认情况下Point&lt;Number&gt;并不是Point&lt;Long&gt;的父类型</span></span><br><span class="line">    <span class="comment">// 像这种Number是Long的父类，但Point&lt;Number&gt;并不是Point&lt;Long&gt;的父类型，</span></span><br><span class="line">    <span class="comment">// 我们称之为不型变。</span></span><br><span class="line">    <span class="keyword">var</span> p2: Point&lt;Number&gt; = p1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为什么要有这个设定呢？</span></span><br><span class="line">    <span class="comment">// 假设“p2 = p1”可以编译通过，</span></span><br><span class="line">    <span class="comment">// 由于p2是Point&lt;Number&gt;类型的，那么你的同事就可能写出如下代码：</span></span><br><span class="line">    p2.x = <span class="number">1.2</span></span><br><span class="line">    p2.y = <span class="number">2.4</span></span><br><span class="line">    <span class="comment">// 当你试图通过p1使用x和y值时，就可能出现类转换异常ClassCastException</span></span><br><span class="line">    <span class="keyword">val</span> x: <span class="built_in">Long</span> = p1.x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：协变。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想让“Point&lt;Long&gt;”顺利赋值给“Point&lt;Number&gt;”，</span></span><br><span class="line"><span class="comment">// 可以在泛型T的前面添加一个关键字“out”。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> x: T, <span class="keyword">val</span> y: T) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这种通过“out”关键字来实现“p2=p1”的操作，称之为协变</span></span><br><span class="line">    <span class="keyword">var</span> p1: Point&lt;<span class="built_in">Long</span>&gt; = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">var</span> p2: Point&lt;Number&gt; = p1</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p2.x&#125;</span>，<span class="subst">$&#123;p2.y&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin默认不支持协变是为了保证数据安全，防止外界恶意修改。</span></span><br><span class="line">    <span class="comment">// 通过“out”关键字实现协变之后，类要付出的代价自然就是，禁止泛型T被外界修改。</span></span><br><span class="line">    <span class="comment">// 1、主构造器或者类内的属性，若是泛型T类型，则：</span></span><br><span class="line">    <span class="comment">//    a、若属性是private修饰的，则编译没有任何问题，因为外界无法访问，也就无法修改。</span></span><br><span class="line">    <span class="comment">//    b、若不是private修饰的，则不能使用var声明，可以用val声明，以此来禁止修改。</span></span><br><span class="line">    <span class="comment">// 2、类内的函数不能接收泛型T类型的参数（因为你可能在函数内部执行写操作），</span></span><br><span class="line">    <span class="comment">// 但类内函数可以返回泛型T类型的参数。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事实上，我们之前介绍的“listOf”函数就是使用了“out关键字”，列表不支持修改操作</span></span><br><span class="line">    <span class="comment">// public interface List&lt;out E&gt; : Collection&lt;E&gt;</span></span><br><span class="line">    <span class="keyword">var</span> a1 = listOf&lt;<span class="built_in">Long</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">var</span> a2: List&lt;Number&gt; = a1</span><br><span class="line">    println(a2.joinToString())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 而MutableList则没有使用“out”关键字，因此它可以修改，但不可以协变</span></span><br><span class="line">    <span class="keyword">var</span> m1 = mutableListOf&lt;<span class="built_in">Long</span>&gt;(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">    m1[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">    m1.add(<span class="number">777</span>)</span><br><span class="line">    <span class="comment">// 下面的代码会编译报错</span></span><br><span class="line">    <span class="keyword">var</span> m2: MutableList&lt;Number&gt; = m1</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总结一句话：类的泛型被标为协变后，意味着它可读不可写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例5：逆变。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想让“Point&lt;Number&gt;”顺利赋值给“Point&lt;Long&gt;”，</span></span><br><span class="line"><span class="comment">// 可以在泛型T的前面添加一个关键字“in”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="type">in T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">var</span> x: T, <span class="keyword">private</span> <span class="keyword">val</span> y: T) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(n: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = n</span><br><span class="line">        println(<span class="string">"<span class="variable">$x</span>，<span class="variable">$y</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这种通过“in”关键字来实现“p2=p1”的操作，称之为逆变</span></span><br><span class="line">    <span class="keyword">var</span> p1: Point&lt;Number&gt; = Point(<span class="number">1.3</span>, <span class="number">2.3</span>)</span><br><span class="line">    <span class="keyword">var</span> p2: Point&lt;<span class="built_in">Long</span>&gt; = p1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 很显然，若x和y没用private修饰，当外界执行如下代码时，就会出现类异常</span></span><br><span class="line">    <span class="comment">// var l : Long = p2.x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin默认不支持逆变为了防止读取数据时，发生ClassCastException异常。</span></span><br><span class="line">    <span class="comment">// 通过“in”关键字实现逆变之后，类要付出的代价自然就是，禁止泛型T被外界读取。</span></span><br><span class="line">    <span class="comment">// 1、主构造器或者类内的属性，若是泛型T类型，则：</span></span><br><span class="line">    <span class="comment">//    a、若属性是private修饰的，则编译没有任何问题，因为外界无法读取。</span></span><br><span class="line">    <span class="comment">//    b、否则编译报错。</span></span><br><span class="line">    <span class="comment">// 2、类内的函数能接收泛型T类型的参数，但不可以返回泛型T类型的参数。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事实上，Comparable接口就是使用了“in关键字”</span></span><br><span class="line">    <span class="comment">// public interface Comparable&lt;in T&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     public operator fun compareTo(other: T): Int</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总结一句话：类被标为逆变后，意味着它可写不可读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例6：我自己负责安全问题，请放行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们知道协变是只读不写，但实际开发中往往有需求希望在协变状态下，函数也能支持泛型参数</span></span><br><span class="line"><span class="comment">// 此时我们就可以在泛型之前添加一个注解，来让编译器放行</span></span><br><span class="line"><span class="comment">// 也就是说，我们明确告知编译器，由我们自己来负责安全问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">var</span> x: <span class="meta">@UnsafeVariance</span> T, <span class="keyword">var</span> y: <span class="meta">@UnsafeVariance</span> T) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(x1: @<span class="type">UnsafeVariance</span> <span class="type">T</span>, y1: @<span class="type">UnsafeVariance</span> <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 这样我们就可以同时实现协变与写操作了</span></span><br><span class="line">        <span class="comment">// 但是不建议这么做，你看看本范例的输出就明白了，数据就会不一致</span></span><br><span class="line">        x = x1</span><br><span class="line">        y = y1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1: Point&lt;<span class="built_in">Long</span>&gt; = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">var</span> p2: Point&lt;Number&gt; = p1</span><br><span class="line">    <span class="comment">// 输出：1，2</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p2.x&#125;</span>，<span class="subst">$&#123;p2.y&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    p2.setValue(<span class="number">6.6</span>, <span class="number">7.7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出：6，7</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p1.x&#125;</span>，<span class="subst">$&#123;p1.y&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// 输出：6.6，7.7</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;p2.x&#125;</span>，<span class="subst">$&#123;p2.y&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相应的，逆变也支持这个注解</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例7：使用处型变。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型的协变和逆变，是可以直接写在使用处的</span></span><br><span class="line"><span class="comment">// from只读不写，to只写不读</span></span><br><span class="line"><span class="comment">// 本函数可以复制任意泛型的列表</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copy</span><span class="params">(from: <span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, to: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> from.indices) &#123;</span><br><span class="line">        to[i] = from[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s1 = mutableListOf&lt;String&gt;(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</span><br><span class="line">    <span class="keyword">var</span> s2 = mutableListOf&lt;String&gt;(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>)</span><br><span class="line">    copy(s1, s2)</span><br><span class="line">    <span class="comment">// 输出：a, b, c, d</span></span><br><span class="line">    println(s2.joinToString())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i1 = mutableListOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">var</span> i2 = mutableListOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    copy(i1, i2)</span><br><span class="line">    <span class="comment">// 输出：1, 2, 3, 4</span></span><br><span class="line">    println(i2.joinToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><br>　　范例1：反射的简介。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Kotlin支持两套反射API：</span></span><br><span class="line"><span class="comment">// 1、Java的反射API，可以直接用，但不支持Kotlin的各类特性</span></span><br><span class="line"><span class="comment">// 2、Kotlin自有的API，支持Kotlin各种特性，但需要额外移入一个库“kotlin-reflect”。</span></span><br><span class="line"><span class="comment">// 之所以要拆出来一个库，是为了减少不使用反射功能的应用程序所需的运行时库大小。</span></span><br><span class="line"><span class="comment">// 另外Kotlin自有的反射库首次反射的时候速度会比Java反射库要慢，后面就会好了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以通过下面代码添加依赖：</span></span><br><span class="line"><span class="comment">// 这个依赖也可以不加，但只能进行很少的、基础反射操作。</span></span><br><span class="line"><span class="comment">// 测试发现，引入下面这个版本的反射库后，再打正式包时，会增加包体积几百K。</span></span><br><span class="line"><span class="comment">// 另外，引入的反射库版本号要和你的Kotlin版本一致，我的Kotlin版本是1.5.30，所以才引入这个。</span></span><br><span class="line">implementation <span class="string">"org.jetbrains.kotlin:kotlin-reflect:1.5.30"</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例2：反射类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> id: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的的字节码，字节码统一使用“KClass”类表示，和Java使用“Class”类一样</span></span><br><span class="line">    <span class="keyword">var</span> pClass: KClass&lt;Person&gt; = Person::<span class="class"><span class="keyword">class</span></span></span><br><span class="line">    <span class="comment">// 输出：Person</span></span><br><span class="line">    println(pClass.simpleName)</span><br><span class="line">    <span class="comment">// 输出：com.kotlintest.Person</span></span><br><span class="line">    println(pClass.qualifiedName)</span><br><span class="line">    <span class="comment">// 以下字段，若没有引入反射库，则运行时会抛异常</span></span><br><span class="line">    <span class="comment">// 若类被“data”修饰，则 isData = true</span></span><br><span class="line">    <span class="comment">// 若类被“open”修饰，则 isOpen = true</span></span><br><span class="line">    <span class="comment">// 若类被“inner”修饰，则 isInner = true</span></span><br><span class="line">    <span class="comment">// 若类“不可以被继承”修饰，则 isFinal = true</span></span><br><span class="line">    <span class="comment">// 若类是“抽象类”或者“接口”，则 isAbstract = true</span></span><br><span class="line">    <span class="comment">// 输出：是抽象类：false</span></span><br><span class="line">    println(<span class="string">"是抽象类：<span class="subst">$&#123;pClass.isAbstract&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过类的对象也可以获取到字节码</span></span><br><span class="line">    <span class="keyword">var</span> pClass2 = Person(<span class="string">"10001"</span>)::<span class="class"><span class="keyword">class</span></span></span><br><span class="line">    <span class="comment">// 输出：true</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;pClass === pClass2&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：Kotlin和Java字节码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取Kotlin的String的字节码</span></span><br><span class="line">    <span class="keyword">var</span> clazz = String::<span class="class"><span class="keyword">class</span></span></span><br><span class="line">    println(clazz)</span><br><span class="line">    <span class="comment">// 通过Kotlin的字节码，也可以获取Java的String的字节码</span></span><br><span class="line">    println(clazz.java)</span><br><span class="line">    <span class="comment">// 可以继续获取</span></span><br><span class="line">    println(clazz.java.kotlin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例4：函数、属性、内部类、父类等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kotlintest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.full.*</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> id: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Hello World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(id: String) : Person(id), Runnable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Hello World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">InnerClassB</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pClass = Student::<span class="class"><span class="keyword">class</span></span></span><br><span class="line">    <span class="comment">// 获取当前类内的“属性”和“函数”，不包含当前类内的“构造器”和“内部类”，</span></span><br><span class="line">    <span class="comment">// 也不包含父类的“属性”和“函数”</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> pClass.declaredMembers) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相应的还有如下字段，具体的介绍也看官方文档：</span></span><br><span class="line">    <span class="comment">// 获取函数列表（全部）：declaredFunctions</span></span><br><span class="line">    <span class="comment">// 获取函数列表(非扩展、非静态函数)：declaredMemberFunctions</span></span><br><span class="line">    <span class="comment">// 获取属性列表：declaredMemberProperties</span></span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内部类，同样不会包含父类里面定义的</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> pClass.nestedClasses) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前类是通过“对象表达式”定义的匿名类，则可以使用这个属性获取该对象</span></span><br><span class="line">    <span class="comment">// pClass.objectInstance</span></span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父类以及接口</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> pClass.superclasses) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KClass类内部还有很多属性，大家可以自行研究。</span></span><br></pre></td></tr></table></figure>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><br>　　注解实际上就是一种代码标签，它作用的对象是代码。对于我们来说，使用注解的方式有两种：</p>
<pre><code>1、使用Kotlin或者其他开发者定义好的注解
2、自定义注解
   2.1、以Kotlin内置的各类注解作为基础，定义出自己的注解
   2.2、使用反射技术在特定的时机下，解析代码上的注解，并依据注解内的各个属性值来决定执行哪些操作。
</code></pre><p>　　很显然，日常开发中，我们很少会去自定义注解，且网上自定义注解的资料也一大堆，因此本文只会去介绍一些常用的注解的使用方法。</p>
<p><br>　　范例1：@Transient注解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 使用此注解，该属性将不会被序列化（比如Gson就不会解析它）</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">var</span> isGood = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：@Synchronized注解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你想创建同步函数，可以使用这个注解</span></span><br><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后的字节码如下所示：</span></span><br><span class="line"><span class="comment">// public final static synchronized test()V</span></span><br></pre></td></tr></table></figure>
<p><br>　　范例3：@JvmStatic注解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于老项目来说，打算使用Kotlin后，一开始不可能将所有代码都改为Kotlin</span></span><br><span class="line"><span class="comment">// 必然会存在一部分Java代码，而在Java中调用Kotlin的类、函数是有一些特殊写法的</span></span><br><span class="line"><span class="comment">// 比如你有一个单例类：</span></span><br><span class="line"><span class="keyword">object</span> CommonUtils &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Hello world!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不在printHello函数上面加上JvmStatic注解，那么在Java代码中就只能这么调用</span></span><br><span class="line"><span class="comment">// CommonUtils.INSTANCE.printHello();</span></span><br><span class="line"><span class="comment">// 加了之后，就可以这么写：</span></span><br><span class="line"><span class="comment">// CommonUtils.printHello();</span></span><br></pre></td></tr></table></figure>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>　　协程可以让异步代码同步化，可以降低异步程序的设计复杂度，由于笔者事务繁忙，且日常开发暂时没有设置到这块，所以暂时搁浅。</p>
<h1 id="第三节-Android中的Kotlin"><a href="#第三节-Android中的Kotlin" class="headerlink" title="第三节 Android中的Kotlin"></a>第三节 Android中的Kotlin</h1><p><br>　　范例1：Application的单例对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个伴生对象，其内部持有一个App的引用</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Instance &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: App? = <span class="literal">null</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span> = instance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在onCreate对象中，可以访问到伴生对象的属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        instance = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例2：let、run、also、apply函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mViewPager: ViewPager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        mViewPager = findViewById(R.id.viewPager)</span><br><span class="line">        <span class="comment">// 由于mViewPager是可空类型，因此每次调用该对象的函数时都需要使用“?.”符号</span></span><br><span class="line">        <span class="comment">// 为了省事，我们可以通过let函数只调用一次“?.”</span></span><br><span class="line">        mViewPager?.let &#123;</span><br><span class="line">            <span class="comment">// 这里的it就是表示“mViewPager”。</span></span><br><span class="line">            it.offscreenPageLimit = <span class="number">4</span></span><br><span class="line">            it.adapter = MainPagerAdapter(supportFragmentManager)</span><br><span class="line">            it.currentItem = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相应的，还有一个run函数，它的特点是：</span></span><br><span class="line"><span class="comment">// 在大括号里面，使用“this”关键词（而不是it）来表示“ViewPager”,</span></span><br><span class="line"><span class="comment">// 不太推荐使用此函数，当层级嵌套比较多时，理解上容易混乱。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，还有一个also函数，它特点是：</span></span><br><span class="line"><span class="comment">// 使用“it”关键字，同时整个表达式会返回该对象，比如</span></span><br><span class="line"><span class="keyword">var</span> viewPager = mViewPager?.also&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，还有一个also函数，它特点是：</span></span><br><span class="line"><span class="comment">// 使用“this”关键字，同时整个表达式会返回该对象。</span></span><br></pre></td></tr></table></figure>
<p><br><strong>本文参考阅读：</strong></p>
<ul>
<li><a href="https://book.kotlincn.net/" target="_blank" rel="noopener">Kotlin 官方文档 中文版</a></li>
<li><a href="https://www.jianshu.com/p/1821eb89bdfd" target="_blank" rel="noopener">Kotlin注解(2)自定义注解</a></li>
<li><a href="https://juejin.cn/post/6844903829868134407" target="_blank" rel="noopener">教你如何完全解析Kotlin中的注解</a></li>
</ul>
<p><br><br></p>

      
    </div>

    <footer class="post-footer">
      

      
      
    </footer>
  </article>


  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="language-006/"
           data-title="第六章 Kotlin" data-url="http://yoursite.com/language-006/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="键盘" />
          <p class="site-author-name" itemprop="name">键盘</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://weishu.me/" title="weishu" target="_blank">weishu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ryanhoo.github.io/" title="ryanhoo" target="_blank">ryanhoo</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一节-起源概述"><span class="nav-number">1.</span> <span class="nav-text">第一节 起源概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向JVM的语言"><span class="nav-number">1.1.</span> <span class="nav-text">面向JVM的语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kotlin"><span class="nav-number">1.2.</span> <span class="nav-text">Kotlin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境搭建"><span class="nav-number">1.3.</span> <span class="nav-text">环境搭建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二节-Kotlin入门"><span class="nav-number">2.</span> <span class="nav-text">第二节 Kotlin入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础语法"><span class="nav-number">2.1.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">2.1.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制流程"><span class="nav-number">2.1.2.</span> <span class="nav-text">控制流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-number">2.2.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类和对象"><span class="nav-number">2.2.1.</span> <span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">2.2.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">2.2.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">2.2.4.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空类型安全"><span class="nav-number">2.2.5.</span> <span class="nav-text">空类型安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展"><span class="nav-number">2.2.6.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符重载"><span class="nav-number">2.2.7.</span> <span class="nav-text">操作符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda表达式"><span class="nav-number">2.2.8.</span> <span class="nav-text">lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">2.2.9.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类"><span class="nav-number">2.2.10.</span> <span class="nav-text">数据类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类"><span class="nav-number">2.2.11.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合框架"><span class="nav-number">2.2.12.</span> <span class="nav-text">集合框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性修饰符"><span class="nav-number">2.2.13.</span> <span class="nav-text">可见性修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶特性"><span class="nav-number">2.3.</span> <span class="nav-text">进阶特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代理"><span class="nav-number">2.3.1.</span> <span class="nav-text">代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型"><span class="nav-number">2.3.2.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射"><span class="nav-number">2.3.3.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解"><span class="nav-number">2.3.4.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程"><span class="nav-number">2.3.5.</span> <span class="nav-text">协程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三节-Android中的Kotlin"><span class="nav-number">3.</span> <span class="nav-text">第三节 Android中的Kotlin</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">键盘</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
