<!doctype html>



  


<html class="theme-next mist use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="http://www.gov.cn/" title="不只是看客" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="做为一个程序员，用AI进行辅助编程是早晚的事，头铁嘴硬的人最终都会变成小丑。 从今天开始，笔者的博文将会使用ChatGPT进行辅助编写，以前一些理论性的概念为了确保正确性，前后得搜好几篇博客相互印证对比才敢确定，同时想做一个表格也得手打，现在都不是问题了。 模仿贾队长的话来说，AI来之前我干活慢、写不出牛逼的代码，AI来之后我干活还慢，那他妈AI不白来了吗？ 按照老规矩，先了解一些AI相关的基础知">
<meta property="og:type" content="article">
<meta property="og:title" content="第一章 AI编程入门">
<meta property="og:url" content="http://yoursite.com/ai-001/index.html">
<meta property="og:site_name" content="不只是看客">
<meta property="og:description" content="做为一个程序员，用AI进行辅助编程是早晚的事，头铁嘴硬的人最终都会变成小丑。 从今天开始，笔者的博文将会使用ChatGPT进行辅助编写，以前一些理论性的概念为了确保正确性，前后得搜好几篇博客相互印证对比才敢确定，同时想做一个表格也得手打，现在都不是问题了。 模仿贾队长的话来说，AI来之前我干活慢、写不出牛逼的代码，AI来之后我干活还慢，那他妈AI不白来了吗？ 按照老规矩，先了解一些AI相关的基础知">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/ai/ai_1_1.png">
<meta property="og:image" content="http://yoursite.com/img/ai/ai_1_3.png">
<meta property="og:image" content="http://yoursite.com/img/ai/ai_1_4.png">
<meta property="og:image" content="http://yoursite.com/img/ai/ai_1_5.png">
<meta property="og:image" content="http://yoursite.com/img/ai/ai_1_6.png">
<meta property="og:image" content="http://yoursite.com/img/ai/ai_1_7.png">
<meta property="og:image" content="http://yoursite.com/img/ai/ai_1_2.png">
<meta property="og:updated_time" content="2025-04-09T03:23:37.202Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第一章 AI编程入门">
<meta name="twitter:description" content="做为一个程序员，用AI进行辅助编程是早晚的事，头铁嘴硬的人最终都会变成小丑。 从今天开始，笔者的博文将会使用ChatGPT进行辅助编写，以前一些理论性的概念为了确保正确性，前后得搜好几篇博客相互印证对比才敢确定，同时想做一个表格也得手打，现在都不是问题了。 模仿贾队长的话来说，AI来之前我干活慢、写不出牛逼的代码，AI来之后我干活还慢，那他妈AI不白来了吗？ 按照老规矩，先了解一些AI相关的基础知">
<meta name="twitter:image" content="http://yoursite.com/img/ai/ai_1_1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/ai-001/">

  <title> 第一章 AI编程入门 | 不只是看客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">不只是看客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                第一章 AI编程入门
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2025-03-27T16:16:00+08:00" content="2025-03-27">
              2025-03-27
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                    <span itemprop="name">人工智能</span>
                </span>

                
                

              
            </span>
          

          

          
          
             <span id="/ai-001/" class="leancloud_visitors" data-flag-title="第一章 AI编程入门">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>做为一个程序员，用AI进行辅助编程是早晚的事，头铁嘴硬的人最终都会变成小丑。</p>
<pre><code>从今天开始，笔者的博文将会使用ChatGPT进行辅助编写，以前一些理论性的概念为了确保正确性，前后得搜好几篇博客相互印证对比才敢确定，同时想做一个表格也得手打，现在都不是问题了。
</code></pre><p>模仿贾队长的话来说，AI来之前我干活慢、写不出牛逼的代码，AI来之后我干活还慢，那他妈AI不白来了吗？</p>
<p>按照老规矩，先了解一些AI相关的基础知识吧。</p>
<h1 id="什么是-AI-大模型？"><a href="#什么是-AI-大模型？" class="headerlink" title="什么是 AI 大模型？"></a>什么是 AI 大模型？</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>AI <strong>大模型</strong>（Large AI Model）是指<strong>参数规模巨大、能力全面的人工智能模型</strong>，它们通过深度学习训练，能够处理<strong>自然语言、代码、图像、音频等多种任务</strong>。</p>
<hr>
<p><strong> 核心特点： </strong></p>
<ol>
<li><strong>超大参数量</strong>：通常拥有 <strong>数十亿到万亿级</strong> 参数，如 GPT-4o、Claude 3.7。  </li>
<li><strong>通用能力强</strong>：可用于对话、翻译、代码、创作、推理等任务。  </li>
<li><strong>多模态支持</strong>：部分大模型支持文本、图像、音频、视频输入（如 Gemini 1.5）。  </li>
<li><strong>训练基于海量数据</strong>：模型从互联网文本、代码库、学术论文等数据学习。  </li>
<li><strong>自监督学习</strong>：无需明确标注数据，通过预测下一个词或填空的方式进行训练。</li>
</ol>
<hr>
<h2 id="广为人知的-AI-大模型（截止至2025年3月28日）"><a href="#广为人知的-AI-大模型（截止至2025年3月28日）" class="headerlink" title="广为人知的 AI 大模型（截止至2025年3月28日）"></a>广为人知的 AI 大模型（截止至2025年3月28日）</h2><table>
<thead>
<tr>
<th>模型名称</th>
<th>开发公司</th>
<th>特点</th>
<th>强项</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GPT-4.5（Orion）</strong></td>
<td>OpenAI</td>
<td>大型多模态语言模型，支持15种语言</td>
<td>多语言理解与生成</td>
<td>自然语言处理、内容创作、翻译等</td>
</tr>
<tr>
<td><strong>Grok 3</strong></td>
<td>xAI</td>
<td>强大的聊天、编码与推理能力</td>
<td>数学、科学与代码生成 <strong>[编码强]</strong></td>
<td>编程辅助、科学研究、教育等</td>
</tr>
<tr>
<td><strong>DeepSeek-V3-0324</strong></td>
<td>深度求索</td>
<td>开源模型，专注于数学、编码及中文处理</td>
<td>数学与编程能力 <strong>[编码强]</strong>，性价比高</td>
<td>数学求解、代码生成、中文自然语言处理等</td>
</tr>
<tr>
<td><strong>Gemini 2.5 Pro</strong></td>
<td>谷歌</td>
<td>增强型AI模型，提升推理能力</td>
<td>理解、数学、编码 <strong>[编码强]</strong>及多模态处理</td>
<td>复杂问题解答、编程辅助、多媒体内容生成等</td>
</tr>
<tr>
<td><strong>Ernie 4.5</strong></td>
<td>百度</td>
<td>升级版AI模型，具备增强的推理与多模态处理能力</td>
<td>多数据类型处理与转换</td>
<td>内容生成、数据分析、多媒体处理等</td>
</tr>
<tr>
<td><strong>Claude 3.7 Sonnet</strong></td>
<td>Anthropic</td>
<td>专注于安全性和可控性的AI模型</td>
<td>高可靠性与安全性</td>
<td>医疗咨询、法律分析、教育辅导等</td>
</tr>
<tr>
<td><strong>Llama 3.3 7B</strong></td>
<td>Meta</td>
<td>开源模型，擅长数学、常识及指令遵循</td>
<td>性价比高</td>
<td>教育、研究、开发等领域</td>
</tr>
<tr>
<td><strong>Qwen2.5-Omni-7B</strong></td>
<td>阿里巴巴</td>
<td>多模态处理，支持在智能手机上运行</td>
<td>移动端兼容性及多模态处理</td>
<td>智能助手、多媒体生成、实时翻译等</td>
</tr>
<tr>
<td><strong>讯飞星火认知大模型</strong></td>
<td>科大讯飞</td>
<td>具备文本生成、语言理解、知识问答与逻辑推理等核心能力</td>
<td>多领域应用能力</td>
<td>教育、医疗、智能客服等</td>
</tr>
<tr>
<td><strong>文心一言大模型</strong></td>
<td>百度</td>
<td>能理解复杂提示词，支持多模态生成</td>
<td>文学创作与商业文案撰写</td>
<td>文学创作、商业文案撰写、多模态生成等</td>
</tr>
</tbody>
</table>
<p><br>其实基于不同的划分方法，大模型还可以继续细化：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通用大模型</strong></td>
<td>处理多种任务和数据类型，适用于广泛应用场景</td>
<td>GPT-4, Claude, Gemini, DeepSeek, 文心一言</td>
</tr>
<tr>
<td><strong>专业领域大模型</strong></td>
<td>针对特定专业领域（如编程、医学、法律、金融等）进行优化</td>
<td>Code Llama, DeepSeek Coder, BioGPT, 专业法律大模型</td>
</tr>
<tr>
<td><strong>多模态大模型</strong></td>
<td>同时处理文本、图像、音频等多种数据，实现跨模态生成与理解</td>
<td>DALL·E, Stable Diffusion, Gemini 2.5 Pro, Qwen2.5-Omni-7B</td>
</tr>
<tr>
<td><strong>开源大模型</strong></td>
<td>开放源码，便于社区二次开发和定制，适合研究及多场景应用</td>
<td>Meta 的 Llama 系列（如 Llama 3）、Mistral</td>
</tr>
<tr>
<td><strong>垂直领域知识大模型</strong></td>
<td>针对特定行业或领域（如教育、科研、工业制造等）整合专业数据与知识，提供精准决策支持</td>
<td>金融大模型、医疗大模型、教育大模型</td>
</tr>
</tbody>
</table>
<p>通过以上这些不同类型的大模型，开发者可以根据具体应用场景选择最合适的模型，既能利用通用模型的广泛适用性，也能发挥专业领域模型在特定任务上的优势。</p>
<h2 id="ChatGPT-与-GPT-4-5-是什么关系？"><a href="#ChatGPT-与-GPT-4-5-是什么关系？" class="headerlink" title="ChatGPT 与 GPT-4.5 是什么关系？"></a>ChatGPT 与 GPT-4.5 是什么关系？</h2><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>ChatGPT</strong></th>
<th><strong>GPT-4.5</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>一个面向用户的聊天对话平台，用于与用户进行自然语言交互</td>
<td>一个大型自然语言处理模型，提供文本生成和理解能力</td>
</tr>
<tr>
<td><strong>核心功能</strong></td>
<td>提供交互式对话、问答、内容生成和辅助编程等服务</td>
<td>作为引擎支持各种自然语言处理任务，如生成、翻译、推理等</td>
</tr>
<tr>
<td><strong>用户视角</strong></td>
<td>用户直接与 ChatGPT 交互，获得即时答案和建议</td>
<td>用户通常不直接与 GPT-4.5 交互，而是通过应用或 API 间接使用该模型</td>
</tr>
<tr>
<td><strong>开发者视角</strong></td>
<td>集成和构建基于 ChatGPT 的产品和服务</td>
<td>用作核心 AI 技术，通过 API 或集成到产品中提供强大语言理解与生成能力</td>
</tr>
<tr>
<td><strong>更新方式</strong></td>
<td>版本更新可能涉及整体产品功能的迭代</td>
<td>独立发布和更新，当前最新版本为 GPT-4.5（Orion）</td>
</tr>
<tr>
<td><strong>作用比喻</strong></td>
<td>汽车（展示和操作平台）</td>
<td>发动机（提供动力和核心技术）</td>
</tr>
</tbody>
</table>
<p><strong>拓展： GPT-4.5 与 GPT-4o 的关系</strong></p>
<pre><code>根据 OpenAI 官方页面的信息，GPT-4.5 是在 GPT-4 技术基础上进一步改进的版本，主要针对文本任务进行了性能优化、推理能力提升以及更高效的运算，而 GPT-4o 则是一个全新的多模态模型，支持文本、图像等多种输入方式。

这意味着：
GPT-4.5：侧重于文本处理和对话的改进，是对原有 GPT-4 的增量升级，提升了推理速度和准确性。
GPT-4o：扩展了多模态能力，能够处理文本和图像等多种数据输入，提供更加丰富的交互体验，同时也在速度和成本上做出了优化。

因此，GPT-4.5 和 GPT-4o 是基于 GPT-4 技术的不同产品，它们各自针对不同的应用场景进行优化和升级，并非同一模型的不同版本。
</code></pre><h2 id="编码能力强的大模型"><a href="#编码能力强的大模型" class="headerlink" title="编码能力强的大模型"></a>编码能力强的大模型</h2><p>最上面第一个表格都是由 ChatGPT 生成的，我要求它针对编码能力强的模型重点标记，有点AI经验的读者可能发现，最常用的“Claude 3.7 Sonnet”并没有被打上编码强的标签，于是我继续让它对此做出解释：</p>
<table>
<thead>
<tr>
<th>模型名称</th>
<th>优势</th>
<th>劣势</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Claude 3.7 Sonnet</strong></td>
<td>在通用编码任务和多模态处理上表现均衡；部分 SWE 编码测试中准确率较高</td>
<td>针对某些特定任务（如数学推理、中文深度处理）可能表现略逊</td>
<td>通用开发、跨语言与跨领域编码任务</td>
</tr>
<tr>
<td><strong>DeepSeek-V3-0324</strong></td>
<td>在数学推理、前端开发以及中文编程任务上具有明显优势；性价比高</td>
<td>在一些广泛的通用编码任务中可能不如 Claude 3.7 Sonnet 均衡</td>
<td>针对中文和特定领域需求的编程任务</td>
</tr>
</tbody>
</table>
<p>结论： </p>
<pre><code>目前的信息显示，Claude 3.7 Sonnet 和 DeepSeek-V3-0324 各有千秋，具体优劣取决于任务要求和测试标准。  
- Claude 3.7 Sonnet 更适合需要处理多模态数据和广泛通用编码任务的场景；  
- DeepSeek-V3-0324 则在数学推理、前端开发以及中文处理等特定任务中展现出更强的优势。
因此，两者的编码能力无法简单地用“谁强谁弱”来一概而论，最好根据具体应用场景选择适合的模型。
</code></pre><h1 id="AI-编程助手"><a href="#AI-编程助手" class="headerlink" title="AI 编程助手"></a>AI 编程助手</h1><p>下面是当前热门 AI 编程助手及其特点（截止至2025年3月28日）</p>
<table>
<thead>
<tr>
<th>AI 编程助手</th>
<th>开发公司</th>
<th>主要特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GitHub Copilot</strong></td>
<td>GitHub / Microsoft</td>
<td>基于 GPT 系列，自动代码补全；深度集成 VS Code 等 IDE</td>
<td>代码补全、函数建议、Pair Programming</td>
</tr>
<tr>
<td><strong>Amazon CodeWhisperer</strong></td>
<td>Amazon</td>
<td>针对 AWS 优化，支持多种编程语言；高效生成代码建议</td>
<td>云端开发、API 集成、自动代码生成</td>
</tr>
<tr>
<td><strong>Cursor AI</strong></td>
<td>Cursor</td>
<td>类 ChatGPT 编程助手，支持 Figma 解析与 UI 代码转换；智能代码优化</td>
<td>前端/移动端代码生成、UI 转换、自动化编程</td>
</tr>
<tr>
<td><strong>Tabnine</strong></td>
<td>Tabnine</td>
<td>本地运行，隐私友好；支持个性化训练和多语言补全</td>
<td>多语言代码补全、隐私敏感项目</td>
</tr>
<tr>
<td><strong>Codeium</strong></td>
<td>Exafunction</td>
<td>免费且轻量，支持70+编程语言；响应速度快</td>
<td>快速代码补全、跨语言开发</td>
</tr>
<tr>
<td><strong>DeepSeek Coder</strong></td>
<td>DeepSeek</td>
<td>开源模型，专注代码生成与中文优化；数学与编程能力突出</td>
<td>中文开发、代码生成、AI 编程研究</td>
</tr>
<tr>
<td><strong>Code Llama</strong></td>
<td>Meta</td>
<td>开源 AI 编程助手，支持本地部署；适合离线和嵌入式开发</td>
<td>开源开发、离线代码生成、研究与实验</td>
</tr>
<tr>
<td><strong>PolyCoder</strong></td>
<td>OpenAI</td>
<td>专注于代码生成，多语言支持；针对编程任务进行专门优化</td>
<td>自动代码生成、编程研究、特定语言模型试验</td>
</tr>
<tr>
<td><strong>Trae AI</strong></td>
<td>字节跳动</td>
<td>AI 原生 IDE，提供 Chat 模式与 Builder 模式；支持端到端项目生成和 UI 解析</td>
<td>自动项目搭建、端到端代码生成、跨平台 UI 转换</td>
</tr>
</tbody>
</table>
<h2 id="仅仅是助手"><a href="#仅仅是助手" class="headerlink" title="仅仅是助手"></a>仅仅是助手</h2><p>最初在抖音看到有人介绍 Cursor 的用法，发现都是针对网页、小程序开发的简单介绍，顿时就没了兴趣，感觉对App开发没什么用。后来体验了几天 Cursor 之后，发现确实对编码有提效，但这个<font color="red">提效不是全方位的，而是在特定场景下的提效</font>。</p>
<p>首先，在使用 Cursor 进行辅助编程时，我会开启两个IDE，一个是 Cursor ，一个是 Android Studio 。</p>
<pre><code>1、项目的编译、打包必须在Android Studio中进行， Cursor 完成不了。

2、虽然直接在 Cursor 里写代码，多一个代码提示功能(而这对我没什么用)，但它的 IDE 的风格与快捷键与本人习惯完全不一致，我不想再去习惯它，所以常规的编码工作依然在Android Studio中进行。

3、只有当遇到需要辅助编程的场景，比如需要写一个自定义控件的时候，我会在 Cursor 中具体描述需求，由它来编写代码。同时为了不给自己找麻烦，在让 Cursor 写代码之前，我会把本地代码提交一下，如果它写的不满意，就他妈直接回滚。
</code></pre><p>其次，AI 写出的代码质量和你描述需求的能力成正比。</p>
<pre><code>如果你只传递一个png格式的设计稿，并告诉他帮我写一个大转盘的功能，那得到的结果大概率是你不满意的。
第一个问题就是，它可能会把大转盘的类文件放到一个你不满意的包下面。
第二个问题，它可能会用xml的方式聚合多个view，来实现你的需求，比如一个ImageView展示转盘，一个ImageView展示指针。
第三个问题，转盘的转动效果你不满意，它可能就给你转个3圈，而且开始和结束的速度是一样的。

稍微好一些的提需求方式是：
你帮我在home/dialog包下创建一个抽奖对话框，对话框的样子是我传递给你的png图所展示的样子。
转盘的图片你可以用bg_lottery.png，指针的图片用ic_lottery_arrow.png。
同时要求通过自绘View的形式来实现转盘功能，转盘包含4个奖品，它们按照顺时针方向排列，中奖概率依次为10%、20%、30%、40%。

即便你像上面描述的这么细致，依然不可能一口气就把功能实现，通常你需要经历多轮的沟通后，才会有一个比较满意的结果，虽然如此也一定会比自己从头写要快。
</code></pre><p>第三，不要神话它目前阶段的能力，以我目前的使用体感来说：</p>
<pre><code>1、不要把编程助手想象成“诸葛亮”，没有那么强。如果你打算在你的老项目中直接使用 AI 编程助手，不论你需求描述的多么详细，AI编程助手都很难在一次沟通中就实现你的完整需求（若此时你想抬杠请走开）。因为 AI 编程助手并不会整体扫描你的整个项目，深入理解你的每行代码的逻辑，它只是在接到你的命令时，小范围的理解代码，并依据需求来生成代码，所以不可避免的出现意料之外的结果。

2、你应该调整自己的角色定位，从“一线编码人员”转变成“架构师”、“小组长”的角色。即由你来事先统筹项目架构、拆分需求，然后再由AI来帮你实现功能。

3、目前看起来，越是独立的功能模块（比如自定义控件、给图片加水印等工具方法），AI的提效能力越大。
</code></pre><p>第四，助手懂得多。</p>
<pre><code>AI编程助手可以编写所有类型的项目，游戏、APP（Android、iOS）、网站、小程序等等。
所以不论你是哪个工种，都可以使用AI编程助手，本文档是以Android为切入点，但这东西都是一通百通。
</code></pre><h2 id="到底选谁？"><a href="#到底选谁？" class="headerlink" title="到底选谁？"></a>到底选谁？</h2><p>这取决于你对 AI 编程助手的需求：</p>
<pre><code>假设 Cursor 提供了1万个功能，但你都用不到，你的需求只是写个简单爬虫、创建 html5 的小工具，而这些功能任何一个 AI 编程助手都可以实现，你干嘛要选收钱的呢?
另外，AI 编程助手本身是一直在变化的，大家应该做的不是几选一，而是都去了解、使用，用发展的眼光去看待 AI 编程助手，不要只盯着眼前。
</code></pre><p>我最开始使用的是 Cursor ，但免费用户是有限额的，在我发出了一个让 Cursor 将大量 Java 类转到 Kotlin 类的命令时，限额用完了，我第一反应就是去使用 Trae AI 了，既然大家使用的大模型都差不多，为什么要交钱？</p>
<p>万万没想到，大聪明不止我一个，此时此刻至少还有 506 个：</p>
<center><br><img src="/img/ai/ai_1_1.png" alt><br></center>

<p>既然免费的需要排队，那肯定不能用在实际生产中了，目前看起来只能选 Cursor 了。<br>其实不全对，排队是因为 Claude-3.7-Sonnet 这个大模型比较火，换一个模型就好了，比如换成 DeepSeek-V3-0324。</p>
<p>需要注意的是，模型与模型之间的差异还是比较大的：</p>
<pre><code>比如我先用 Claude-3.5-Sonnet ，让它帮我生成一个界面，界面中间放一个按钮，点击后展示“Hello World”。
虽然它创建的 Activity 是对的，但将 Activity 写入到清单文件的时候，写到&lt;manifest&gt;外面去了。
而换成 Claude-3.7-Sonnet 则没有这个问题。
</code></pre><p><br>目前看起来，Trae AI 似乎是一个不错的选择，可以用 DeepSeek-V3-0324 生成代码，本身还是免费的。<br>不过它并不一定合符你的需求，因为我接下来问了 DeepSeek 这么一个问题：</p>
<pre><code>截止至2025年3月28号，Cursor 具备哪些 Android 开发功能，而 Trae AI 不具备？
</code></pre><table>
<thead>
<tr>
<th><strong>功能类别</strong></th>
<th><strong>Cursor</strong></th>
<th><strong>Trae AI</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全栈开发支持</strong></td>
<td>✅ 深度集成VS Code生态，兼容Android Studio插件<br>✅ 支持复杂多模块项目构建</td>
<td>❌ 官方未提及Android原生开发支持<br>⭕ 专注Web/游戏快速原型开发</td>
</tr>
<tr>
<td><strong>代码生成效率</strong></td>
<td>⏱️ 实测响应时间快3倍<br>📄 符合企业级规范（时间戳/API安全等）</td>
<td>⏳ 复杂逻辑理解不足<br>⚠️ 可能出现依赖配置错误</td>
</tr>
<tr>
<td><strong>Android语言支持</strong></td>
<td>🔧 原生支持Java/Kotlin<br>🚀 自动生成Jetpack Compose布局代码</td>
<td>🔴 未明确支持Kotlin/Jetpack<br>🟡 主要支持Python/JavaScript</td>
</tr>
<tr>
<td><strong>调试能力</strong></td>
<td>🔍 精准定位Android特有错误（如<code>CursorWindowAllocationException</code>）<br>📌 提供修复建议</td>
<td>🛠️ 侧重Web应用调试<br>🚫 无ANR/内存泄漏针对性支持</td>
</tr>
<tr>
<td><strong>跨平台兼容性</strong></td>
<td>🌐 Windows/macOS/Linux全支持<br>⚙️ 集成ADB/Gradle工具链</td>
<td>🍎 仅支持Mac系统<br>🔗 未整合Android开发环境</td>
</tr>
<tr>
<td><strong>典型场景示例</strong></td>
<td>📱 生成多线程安全的数据库操作代码<br>🔗 自动处理Activity/Fragment生命周期绑定</td>
<td>🕹️ 快速生成2D小游戏逻辑<br>🌍 创建简单CRUD网页应用</td>
</tr>
</tbody>
</table>
<p>总结：</p>
<pre><code>Cursor 在 Android 开发中拥有直接解析 Figma 设计、生成 Jetpack Compose 和 XML 布局代码的优势，同时还具备 API 绑定、Gradle 优化以及代码语言转换等高级功能。
Trae AI 则主要侧重于整体项目搭建和快速原型开发，缺乏针对 Android 平台的深度代码生成和优化功能。
</code></pre><p>如果你是 Android 开发者，Cursor 绝对是更好的 AI 助手！<br>如果你是 iOS 开发者，答案也是一样的，不信的话就自己去问ChatGPT。在以前，脑袋里有千百个问题但周围没人有能力回答你，慢慢的就不会问了，现在不同了，只要你有问题，那就一定能得到答案，答案可能不对，但你就说有没有吧？</p>
<hr>
<p><br>最后再问一个问题：将一个 Android 项目，转换成 iOS 项目，用 Cursor 能实现吗?</p>
<p>如果你希望从 Android（Kotlin / Jetpack Compose / XML）转换为 iOS（Swift / SwiftUI / UIKit），Cursor 可以在以下几个方面提供帮助：</p>
<table>
<thead>
<tr>
<th><strong>转换内容</strong></th>
<th><strong>Cursor 支持？</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UI 布局（Jetpack Compose ➝ SwiftUI）</strong></td>
<td>✅ <strong>可以部分转换，需手动调整</strong></td>
</tr>
<tr>
<td><strong>UI 布局（XML ➝ UIKit / Storyboard）</strong></td>
<td>✅ <strong>可以部分转换，但可能需要调整 Autolayout</strong></td>
</tr>
<tr>
<td><strong>业务逻辑（Kotlin ➝ Swift）</strong></td>
<td>✅ <strong>可以辅助代码转换，但无法完全自动化</strong></td>
</tr>
<tr>
<td><strong>网络请求（Retrofit ➝ Alamofire / URLSession）</strong></td>
<td>✅ <strong>可以自动转换 Retrofit 调用至 Swift 网络库</strong></td>
</tr>
<tr>
<td><strong>数据库（Room ➝ CoreData / Realm）</strong></td>
<td>✅ <strong>可以转换基本的数据存储逻辑</strong></td>
</tr>
<tr>
<td><strong>Android API（Jetpack API ➝ iOS API）</strong></td>
<td>❌ <strong>部分 API 需要手动适配</strong></td>
</tr>
<tr>
<td><strong>第三方库（Android-only 库 ➝ iOS 版本）</strong></td>
<td>❌ <strong>需要手动查找替代方案</strong></td>
</tr>
<tr>
<td><strong>Gradle 配置 ➝ Xcode 项目设置</strong></td>
<td>❌ <strong>需要手动配置 Xcode</strong></td>
</tr>
</tbody>
</table>
<p>结论：</p>
<pre><code>1、Cursor 可以帮助自动转换 UI &amp; 业务逻辑，但 iOS 适配仍需要手动调整，无法做到 100% 自动转换
2、适合小型项目或单个组件的迁移，不适用于完整复杂项目的全自动转换
</code></pre><p><br>这么说的话，那换一个问题：是将 Android 转换成 iOS 成本大，还是转成 Flutter 或者 React Native 成本大？</p>
<p>如果你的目标是让 Android 应用运行在 iOS，主要有两种方案：<br>1️⃣ <strong>直接转换为 iOS（Kotlin ➝ Swift / Jetpack Compose ➝ SwiftUI）</strong><br>2️⃣ <strong>转换为跨平台框架（Flutter / React Native），实现一套代码适配两端</strong>  </p>
<p>那么，哪种方案的成本更低？让我们从 <strong>代码迁移难度、维护成本、长期扩展性</strong> 等方面对比👇</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Android ➝ iOS（Kotlin ➝ Swift）</strong></th>
<th><strong>Android ➝ Flutter / React Native</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>代码复用率</strong></td>
<td>❌ <strong>低</strong>（大部分代码需手动迁移）</td>
<td>✅ <strong>高</strong>（大部分业务逻辑可复用）</td>
</tr>
<tr>
<td><strong>UI 适配</strong></td>
<td>❌ <strong>Jetpack Compose ➝ SwiftUI / UIKit 需要大量重写</strong></td>
<td>✅ <strong>Flutter / React Native 可共用 UI</strong></td>
</tr>
<tr>
<td><strong>开发成本</strong></td>
<td>💸 <strong>高</strong>（需要 iOS 专业开发）</td>
<td>💸💸 <strong>中等（Flutter &gt; React Native）</strong></td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>❌ <strong>高</strong>（Android &amp; iOS 维护两套代码）</td>
<td>✅ <strong>低</strong>（一套代码，两端运行）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>✅ <strong>原生性能最佳</strong></td>
<td>🔄 <strong>Flutter 接近原生，React Native 略逊</strong></td>
</tr>
<tr>
<td><strong>API 兼容性</strong></td>
<td>❌ <strong>Android API 需全部重写成 iOS API</strong></td>
<td>✅ <strong>Flutter / RN 直接封装平台 API</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td><strong>已有 iOS 代码或长期专注 iOS 生态</strong></td>
<td><strong>想减少维护成本 &amp; 适配多平台</strong></td>
</tr>
</tbody>
</table>
<p>结论：哪个方案更划算？</p>
<table>
<thead>
<tr>
<th><strong>你的情况</strong></th>
<th><strong>推荐方案</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>已有大量 iOS 代码，或已有 iOS 团队</strong></td>
<td><strong>直接转换为 iOS（Kotlin ➝ Swift）</strong>，成本最高，需要维护两套代码，适合已有 iOS 代码库或团队</td>
</tr>
<tr>
<td><strong>希望尽量少改动代码，快速上线 iOS 版</strong></td>
<td><strong>Flutter / React Native</strong>，一套代码适配 Android &amp; iOS，长期维护更轻松</td>
</tr>
<tr>
<td><strong>未来还要支持 Web / 桌面端</strong></td>
<td><strong>Flutter 更适合</strong></td>
</tr>
<tr>
<td><strong>对性能要求极高（如游戏、AR、AI 应用）</strong></td>
<td><strong>原生 iOS 更优</strong></td>
</tr>
</tbody>
</table>
<h1 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h1><p>关于 Cursor 如何安装，我就不赘述了。就像之前说的，我会同时使用 Cursor 和 Android Studio 。所以在 Cursor 中我没有去修改主题色、字体大小、安装什么 Kotlin 插件等的，唯一只干了一件事，安装中文插件。</p>
<center><br><img src="/img/ai/ai_1_3.png" alt><br></center>

<p>一切就绪之后，会看到如下内容，你可以选择打开本地项目，或者直接拉取远程项目。</p>
<center><br><img src="/img/ai/ai_1_4.png" alt><br></center>

<h2 id="2048游戏"><a href="#2048游戏" class="headerlink" title="2048游戏"></a>2048游戏</h2><p>下面笔者将以一个<font color="red">“2048”</font>的项目为示例，来介绍 Cursor 的最初级用法。<br>首先按照上面的示意，选择<font color="red">“Open project”</font>按钮，找到一个你想要的位置，创建一个名为<font color="red">“2048”</font>的文件夹，接下来 Cursor 生成的代码会放到该文件夹下面。</p>
<p>直接 Cursor 右上角的对话框里输入：帮我生成一个网页版的2048游戏。</p>
<center><br><img src="/img/ai/ai_1_5.png" alt><br></center>

<p>接到命令后，Cursor 就开始生成代码了，很显然为了代码的维护性，它不会将所有的代码都写在一个文件里，所以生成代码的时候也是依次生成，上图中可以看出，优先生成的是 <font color="red">index.html</font> 文件。</p>
<p>每个文件生成完毕后，不会立即保存，由你来阅读确认之后，点击文件框右上角的“✔️”按钮后，才会保存文件。</p>
<pre><code>由于生成代码的速度很快，所以大部分情况下是，你还没看完第一个文件的代码，第二就生成完了，所以你可以点击上图我红框框起来的按钮，一键保存所有文件（由于我截屏的时候AI只写完了一个，所以按钮的文案是“Accept”，如果是写完了多个则文案就是“Accept All”）。
</code></pre><p>最终的效果也很不错，如下图所示：</p>
<center><br><img src="/img/ai/ai_1_6.png" alt><br></center>

<h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><p>与 Cursor 沟通时，可以选择<font color="red"> Agent </font>、<font color="red"> Ask </font>和<font color="red"> Edit </font>三个模式。</p>
<center><br><img src="/img/ai/ai_1_7.png" alt><br></center>

<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>是否可修改代码</strong></th>
<th><strong>适合的任务</strong></th>
<th><strong>不适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Agent</strong></td>
<td>可以</td>
<td>复杂代码生成、跨文件修改、自动化重构、完整项目管理</td>
<td>可能改动过大，不适合小范围微调</td>
</tr>
<tr>
<td><strong>Ask</strong></td>
<td>⚠ 间接可以</td>
<td>三种模式中，最全面的代码解释、优化建议、提供修改思路</td>
<td>不会直接修改代码，需要手动操作</td>
</tr>
<tr>
<td><strong>Edit</strong></td>
<td>可以</td>
<td><strong>单文件代码优化</strong>，局部重构、bug 修复</td>
<td>不能跨文件修改，适用于小范围调整，涉及多个文件 Edit 可能无法正确处理全部依赖关系</td>
</tr>
</tbody>
</table>
<p>需要注意的是，在 Cursor 最新版本中， Edit 模式改名为 Manual 了。</p>
<pre><code>We&apos;ve also renamed &quot;Edit&quot; to &quot;Manual&quot; to better reflect its behavior.
</code></pre><h2 id="解决实际问题"><a href="#解决实际问题" class="headerlink" title="解决实际问题"></a>解决实际问题</h2><p>虽然上面写出的 2048 游戏确实很厉害，但这对提升我工作效率没什么屌用。<br>事实上信任是需要逐步建立的，招来个新人也是从一开始的小需求开始，做的好就继续上强度，与 AI 编程助手的相处也是类似。</p>
<pre><code>一开始接触 AI 编程助手时，可能一时半会反应不过来该指挥它去做什么，主要是不知道它的上限在哪，生怕提个复杂点的需求它搞不定，还把代码搞乱了。因此我在决定用 AI 助手写代码之前，会先把本地代码提交干净。
</code></pre><p>就像当 ChatGPT 刚出来的时候，也不知道问什么问题能有效的帮助自己，随着慢慢对它的熟悉之后，就能高效使用了，比如：</p>
<pre><code>我看到一个海外华人博主电动汽车自燃，保险公司拒赔，它就问了 ChatGPT 拒赔是否合法，结果 ChatGPT 找到了合同漏洞，并按照博主的要求“以白人的口吻写出一封索赔邮件，要有理有据，暗含威胁”，最终保险公司配了他几万刀。
</code></pre><hr>
<p>那么好的，正好手上有个小问题需要写脚本处理一下。<br>我手上有3个json文件，里面保存了3组图片，我需要将前100张图片对应的zip下载到本地，最后内置到APK里，由于这3个json的内容很容易变动，且相互之间有重复的图片，要是每次手动下载zip就很恶心与浪费流量，所以就提出了如下需求：</p>
<pre><code>写个脚本，从当前文件夹中读取base_1、base_2、daily三个文件，同时需要对内容进行base64解密，得到真实的json数据。 
然后将base_1、base_2两个文件的imageList字段下前100条记录，以及daily文件的前10条记录融合在一起。 融合的时候需要排重，以元素的id字段为排重依据。 
接着遍历融合后的元素列表，若某个元素的resource字段对应的文件，在/Users/cutler/xx/image目录下存在则将文件复制到当前目录的images目录下，若不存在则触发文件下载，并保存到当前目录的images目录下。
最后输出融合后元素的总个数，以及本次下载文件的个数。
</code></pre><p>经过几轮的沟通（有我需求的变化，也有它写的代码有问题），最终得到如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_and_decode</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        encoded_data = f.read()</span><br><span class="line">    decoded_data = base64.b64decode(encoded_data).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> json.loads(decoded_data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 读取并解码三个文件</span></span><br><span class="line">    base1 = read_and_decode(<span class="string">'/Users/cutler/workspace/ai/level/base_1'</span>)</span><br><span class="line">    base2 = read_and_decode(<span class="string">'/Users/cutler/workspace/ai/level/base_2'</span>)</span><br><span class="line">    daily = read_and_decode(<span class="string">'/Users/cutler/workspace/ai/level/daily'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 收集所有元素，以id为键去重</span></span><br><span class="line">    merged = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理base_1的前120条记录</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> base1.get(<span class="string">'imageList'</span>, [])[:<span class="number">120</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'id'</span> <span class="keyword">in</span> item:</span><br><span class="line">            merged[item[<span class="string">'id'</span>]] = item</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理base_2的前120条记录</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> base2.get(<span class="string">'imageList'</span>, [])[:<span class="number">120</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'id'</span> <span class="keyword">in</span> item:</span><br><span class="line">            merged[item[<span class="string">'id'</span>]] = item</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理daily的前20条记录</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> daily.get(<span class="string">'imageList'</span>, [])[:<span class="number">20</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'id'</span> <span class="keyword">in</span> item:</span><br><span class="line">            merged[item[<span class="string">'id'</span>]] = item</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建images目录</span></span><br><span class="line">    os.makedirs(<span class="string">'images'</span>, exist_ok=<span class="keyword">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计下载文件数</span></span><br><span class="line">    download_count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历融合后的元素</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> merged.values():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'resource'</span> <span class="keyword">in</span> item:</span><br><span class="line">            resource = item[<span class="string">'resource'</span>]</span><br><span class="line">            filename = resource.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">            src_path = <span class="string">f"/Users/cutler/workspace/android/level/app/src/main/assets/image/<span class="subst">&#123;filename&#125;</span>"</span></span><br><span class="line">            dst_path = <span class="string">f"images/<span class="subst">&#123;filename&#125;</span>"</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> os.path.exists(src_path):</span><br><span class="line">                shutil.copy2(src_path, dst_path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">f"准备下载: <span class="subst">&#123;resource&#125;</span>"</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 临时禁用SSL验证</span></span><br><span class="line">                    <span class="keyword">import</span> ssl</span><br><span class="line">                    <span class="keyword">import</span> time</span><br><span class="line">                    ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 添加重试机制</span></span><br><span class="line">                    max_retries = <span class="number">3</span></span><br><span class="line">                    retry_delay = <span class="number">2</span>  <span class="comment"># 秒</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> attempt <span class="keyword">in</span> range(max_retries):</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            urllib.request.urlretrieve(resource, dst_path)</span><br><span class="line">                            download_count += <span class="number">1</span></span><br><span class="line">                            print(<span class="string">f"成功下载: <span class="subst">&#123;filename&#125;</span>"</span>)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">except</span> (URLError, ConnectionResetError) <span class="keyword">as</span> e:</span><br><span class="line">                            <span class="keyword">if</span> attempt == max_retries - <span class="number">1</span>:</span><br><span class="line">                                print(<span class="string">f"下载失败: <span class="subst">&#123;resource&#125;</span> - 错误: <span class="subst">&#123;str(e)&#125;</span> (尝试 <span class="subst">&#123;max_retries&#125;</span> 次后)"</span>)</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                print(<span class="string">f"下载失败，第 <span class="subst">&#123;attempt + <span class="number">1</span>&#125;</span> 次重试..."</span>)</span><br><span class="line">                                time.sleep(retry_delay)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    print(<span class="string">f"下载失败: <span class="subst">&#123;resource&#125;</span> - 错误: <span class="subst">&#123;str(e)&#125;</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出统计信息</span></span><br><span class="line">    print(<span class="string">f"本次共下载了 <span class="subst">&#123;download_count&#125;</span> 个文件"</span>)</span><br><span class="line">    print(<span class="string">f"融合后共有 <span class="subst">&#123;len(merged)&#125;</span> 个元素"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>如果沟通过程中出现了错误，直接将错误信息复制给 Cursor 就行，多一个字不用说，它就可以自己寻找原因并解决，大概率能解决掉。</p>
<pre><code>这对于编程初学者来说，并不是一个多好的消息，直接放弃思考了，且上瘾性比较强，对个人排查问题的能力有很大的弱化。
</code></pre><p><br>有了这个 Python 代码后，当这三个文件内容有变化时，直接执行它就可以了，如果你的电脑上没有安装 Python ，那么 Cursor 和 Trae 都会询问你是否安装，若同意则自动帮你下载安装。</p>
<pre><code>其实几年前我学过 Python 但工作中从来没用过，以至于学的东西几乎全忘了，唯一记得的是 Python 没有大括号直接通过缩进来表示层级。
但是有了 Cursor 那就太方便了，写我虽然写不出来，但通过看它写的代码，来排查逻辑那指定是一点问题没有。
</code></pre><h2 id="解决实际-Android-问题的过程还原"><a href="#解决实际-Android-问题的过程还原" class="headerlink" title="解决实际 Android 问题的过程还原"></a>解决实际 Android 问题的过程还原</h2><p>目前为止，我用 AI 编程工具 完成了3个需求：</p>
<pre><code>第一个是上面提到的大转盘相关的2个自定义控件
第二个是上面的脚本
第三个是 Android 里的 RecyclerView 手势算法
</code></pre><p>本节主要介绍第三个需求的实现过程，下面是代码的现状以及新的需求：</p>
<hr>
<p>首先我的项目中有一个名为“<font color="red"> MyRecyclerView </font>”的类，用来展示一个水平方向的列表。<br>当用户<font color="red">按下并拖动</font>某个 Item 时，我会计算用户手指在<font color="red"> 水平 </font>和<font color="red"> 垂直 </font>方向上已经拖动的距离，若满足一定的阈值（比如水平在 10 像素以内，垂直在 10 像素以上），我就认为用户此时正在向上拖动这个 Item ，则就会拦截 MyRecyclerView 的事件，不让它继续支持水平滚动，然后执行后续逻辑。</p>
<p>现在需求有变，要求按照“<font color="red"> 用户手指拖动的角度 </font>”来判断用户的意图，若用户手指拖动的<font color="red">角度在 45 度以内</font>（包含左上方、正上方、右上方三个方向），则认为用户正在向上拖动这个 Item ，则就会拦截 MyRecyclerView 的事件，不让它继续支持水平滚动，然后执行后续逻辑。</p>
<hr>
<p>那么好的，接下来是我与 Cursor 的对话过程。</p>
<p>首先我试探性的问了一句：</p>
<pre><code>MyRecyclerView类的isTouchingItem变量你知道干什么用的吗?
</code></pre><p>主要是看看他到底能不能理解代码的上下文，如果连理解都做不到，那还是拜拜吧。</p>
<pre><code>Cursor 接到问题的第一个反应是：“让我搜索一下JigsawRecyclerView类”
……
搜搜完毕后，确实给出了差不多正确的反馈，不过此时也让我意识到，我提的需求并不完整，以至于它还需要先去找这个类在哪。
</code></pre><p>然后我开始正式提出需求：</p>
<pre><code>我想将isTouchingItem置位true的条件改一下，若用户按下的点与首次move的点之间，距离y轴原点夹角小于45度，则走后续逻辑。 需要注意的是需要处理两个方向的逻辑，就是左上，右上，都需要判断45度角。
</code></pre><p>一通操作之后，代码确实写出来的，但是报错了，我直接将错误信息交给它，让它修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e: file:///Users/cutler/workspace/android/aaaa/app/src/main/java</span><br><span class="line">/com/aaa/aaa/aaa/aaa/widget/MyRecyclerView.kt:25:20 Unresolved reference: toDegrees</span><br></pre></td></tr></table></figure></p>
<p>这是因为他引用的<code>kotlin.math.toRadians</code>函数我本地没有，后来它换成了Java的<code>Math.toDegrees</code>函数就可以了。<br>大致的代码是这样的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算移动点与按下点之间的角度</span></span><br><span class="line"><span class="keyword">val</span> deltaX = event.x - downX</span><br><span class="line"><span class="keyword">val</span> deltaY = event.y - downY</span><br><span class="line"><span class="keyword">val</span> angle = Math.toDegrees(atan2(deltaY.toDouble(), deltaX.toDouble()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否在45度角范围内（只处理左上方和右上方）</span></span><br><span class="line"><span class="keyword">val</span> isWithinAngle = <span class="keyword">when</span> &#123;</span><br><span class="line">    <span class="comment">// 第一象限（右上）：0-45度</span></span><br><span class="line">    deltaX &gt;= <span class="number">0</span> &amp;&amp; deltaY &lt;= <span class="number">0</span> &amp;&amp; angle <span class="keyword">in</span> <span class="number">0.0</span>.<span class="number">.45</span><span class="number">.0</span> -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 第二象限（左上）：135-180度</span></span><br><span class="line">    deltaX &lt;= <span class="number">0</span> &amp;&amp; deltaY &lt;= <span class="number">0</span> &amp;&amp; angle <span class="keyword">in</span> <span class="number">135.0</span>.<span class="number">.180</span><span class="number">.0</span> -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这代码不用跑就知道有问题，但为了证据确凿，我运行并打印了变量<code>angle</code>的值，并告知 Cursor 现在的情况：</p>
<pre><code>你的角度是不是算错了，我往右上方滑动手指，打印出的angle都是负数
</code></pre><p>它此时也反应过来的，回复到：</p>
<pre><code>啊，我明白问题所在了。在Android的坐标系中，Y轴是向下为正，而我们在计算角度时需要考虑这个坐标系的特点，让我修改一下代码。
</code></pre><p>运行之后，依然不对，于是我们进行如下对话：</p>
<pre><code>还是不对。我现在从下往上垂直滑动，打印出的角度是90，按我的预期应该是0。
啊，我明白了。我们需要调整角度的计算方式，让垂直向上的方向为0度，让我修改一下代码。
……
左上角的判断似乎是错的。也应该相对于垂直方向往左45的，我觉得应该是315到360度才对
您说得对，我理解错了左上方的角度范围。让我修改一下代码
……
那右上方的判断条件是否需要变化一下？
是的，您说得对。既然左上方是315-360度，那么右上方应该是0-45度。让我修改一下代码
</code></pre><p>至此得到最终的代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算移动点与按下点之间的角度</span></span><br><span class="line"><span class="keyword">val</span> deltaX = event.x - downX</span><br><span class="line"><span class="keyword">val</span> deltaY = event.y - downY</span><br><span class="line"><span class="comment">// 计算与垂直向上方向的夹角（0度为正上方）</span></span><br><span class="line"><span class="keyword">val</span> angle = (Math.toDegrees(atan2(deltaX.toDouble(), -deltaY.toDouble())) + <span class="number">360</span>) % <span class="number">360</span></span><br><span class="line"><span class="comment">// 判断是否在45度角范围内（只处理左上方和右上方）</span></span><br><span class="line"><span class="keyword">val</span> isWithinAngle = <span class="keyword">when</span> &#123;</span><br><span class="line">    <span class="comment">// 右上方：0-45度</span></span><br><span class="line">    deltaX &gt;= <span class="number">0</span> &amp;&amp; deltaY &lt;= <span class="number">0</span> &amp;&amp; angle <span class="keyword">in</span> <span class="number">0.0</span>.<span class="number">.45</span><span class="number">.0</span> -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 左上方：315-360度</span></span><br><span class="line">    deltaX &lt;= <span class="number">0</span> &amp;&amp; deltaY &lt;= <span class="number">0</span> &amp;&amp; angle <span class="keyword">in</span> <span class="number">315.0</span>.<span class="number">.360</span><span class="number">.0</span> -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的聊天过程中，虽然 Cursor 看起来像是一个新兵蛋子，但他解决我最重要的问题“计算角度”，对于我这种<font color="red">大专巅峰的学者</font>来说，一般都懒得去学三角函数这种低级的招数。</p>
<h1 id="Trae-AI"><a href="#Trae-AI" class="headerlink" title="Trae AI"></a>Trae AI</h1><p>Trae AI 的安装过程更简单了，而且还是免费的，如果你的 Curosr 达到限额，且不需要使用 Cursor 的高级功能，那么用它写 Android 也是没问题的。</p>
<p>唯一需要知道的就是，Trae AI 分为<font color="red"> “Chat” </font>和<font color="red"> “Builder” </font>两个模式。</p>
<center><br><img src="/img/ai/ai_1_2.png" alt><br></center>

<p>这两个模式的对比如下：</p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>Chat 模式</strong> 🗨️</th>
<th><strong>Builder 模式</strong> 🏗️</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心功能</strong></td>
<td>类似 ChatGPT，提供代码问答、调试、解释</td>
<td>AI 直接生成完整项目，自动化编程</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>代码查询、修复、优化、理解代码逻辑</td>
<td>生成完整项目、组件、API，甚至端到端的应用</td>
</tr>
<tr>
<td><strong>交互方式</strong></td>
<td>开发者与 AI 进行对话式交互，逐步修改代码</td>
<td>AI 根据需求生成项目，开发者可调整和优化</td>
</tr>
<tr>
<td><strong>代码补全</strong></td>
<td>✅ 支持</td>
<td>✅ 支持</td>
</tr>
<tr>
<td><strong>代码解释</strong></td>
<td>✅ 提供代码段解析</td>
<td>❌ 主要是代码生成</td>
</tr>
<tr>
<td><strong>自动编程</strong></td>
<td>❌ 以问答为主，需要手动实现</td>
<td>✅ AI 负责编写核心代码</td>
</tr>
<tr>
<td><strong>适合用户</strong></td>
<td>需要即时代码帮助、调试、优化的开发者</td>
<td>想用 AI 快速搭建项目、组件的开发者</td>
</tr>
</tbody>
</table>
<p>🤔 那如果把 Builder 模式当 Chat 模式用，会有什么问题？</p>
<table>
<thead>
<tr>
<th><strong>问题类型</strong></th>
<th><strong>可能的影响</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>输出方式不同</strong></td>
<td>Builder 模式更倾向于<strong>生成完整项目</strong>，而不是逐步回答问题。你可能只是想问一个小问题，但 Builder 可能直接给你一堆代码。</td>
</tr>
<tr>
<td><strong>缺少交互性</strong></td>
<td>Chat 模式可以像 ChatGPT 一样<strong>逐步引导你</strong>优化代码，而 Builder 更像是“一次性”生成代码，交互性较弱。</td>
</tr>
<tr>
<td><strong>代码解释能力弱</strong></td>
<td>Chat 模式擅长解释代码、分析错误，而 Builder 主要负责<strong>代码生成</strong>，不会详细解释它为什么这样写。</td>
</tr>
<tr>
<td><strong>计算资源消耗更大</strong></td>
<td>Builder 可能会调用更多计算资源来生成完整代码，而 Chat 只处理小片段，使用 Builder 可能会导致<strong>不必要的性能开销</strong>。</td>
</tr>
<tr>
<td><strong>适用场景不匹配</strong></td>
<td>Chat 模式适合<strong>问答、修复</strong>，Builder 适合<strong>自动创建项目</strong>。如果你只是想问一个小问题，Builder 可能会“过度执行”。</td>
</tr>
</tbody>
</table>
<p>🚀 也就是说：<br>如果只是想<strong>问问题、改代码、优化逻辑</strong>，请用 <strong>Chat 模式</strong>！<br>如果你想让 AI <strong>生成一个完整项目或功能</strong>，用 <strong>Builder 模式</strong> 更合适！<br>如果你打算开启一个全新的项目，那么你可能会先用 Builder 生成，然后用 Chat 小步迭代。</p>
<hr>

      
    </div>

    <footer class="post-footer">
      

      
      
    </footer>
  </article>


  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="ai-001/" data-title="第一章 AI编程入门" data-url="http://yoursite.com/ai-001/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="键盘">
          <p class="site-author-name" itemprop="name">键盘</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://weishu.me/" title="weishu" target="_blank">weishu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ryanhoo.github.io/" title="ryanhoo" target="_blank">ryanhoo</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是-AI-大模型？"><span class="nav-number">1.</span> <span class="nav-text">什么是 AI 大模型？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广为人知的-AI-大模型（截止至2025年3月28日）"><span class="nav-number">1.2.</span> <span class="nav-text">广为人知的 AI 大模型（截止至2025年3月28日）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChatGPT-与-GPT-4-5-是什么关系？"><span class="nav-number">1.3.</span> <span class="nav-text">ChatGPT 与 GPT-4.5 是什么关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码能力强的大模型"><span class="nav-number">1.4.</span> <span class="nav-text">编码能力强的大模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AI-编程助手"><span class="nav-number">2.</span> <span class="nav-text">AI 编程助手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#仅仅是助手"><span class="nav-number">2.1.</span> <span class="nav-text">仅仅是助手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#到底选谁？"><span class="nav-number">2.2.</span> <span class="nav-text">到底选谁？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cursor"><span class="nav-number">3.</span> <span class="nav-text">Cursor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2048游戏"><span class="nav-number">3.1.</span> <span class="nav-text">2048游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种模式"><span class="nav-number">3.2.</span> <span class="nav-text">三种模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决实际问题"><span class="nav-number">3.3.</span> <span class="nav-text">解决实际问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决实际-Android-问题的过程还原"><span class="nav-number">3.4.</span> <span class="nav-text">解决实际 Android 问题的过程还原</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Trae-AI"><span class="nav-number">4.</span> <span class="nav-text">Trae AI</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">键盘</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
