<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="http://www.gov.cn/" title="不只是看客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="基础入门　　什么是数据结构？  数据结构是计算机存储、组织数据的方式。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。  逻辑结构　　所谓逻辑结构，指的是数据及数据间的邻接关系。说白了它描述数据间是以什么方式排列的，而与他们在计算机中的存储位置无关。常见的逻辑结构有如下几种： 　　1、线">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章 数据结构">
<meta property="og:url" content="http://yoursite.com/c-base-002/index.html">
<meta property="og:site_name" content="不只是看客">
<meta property="og:description" content="基础入门　　什么是数据结构？  数据结构是计算机存储、组织数据的方式。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。  逻辑结构　　所谓逻辑结构，指的是数据及数据间的邻接关系。说白了它描述数据间是以什么方式排列的，而与他们在计算机中的存储位置无关。常见的逻辑结构有如下几种： 　　1、线">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/base/base002_01.png">
<meta property="og:image" content="http://yoursite.com/img/base/base002_02.png">
<meta property="og:image" content="http://yoursite.com/img/base/base002_03.png">
<meta property="og:image" content="http://yoursite.com/img/base/base002_04.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_04.svg">
<meta property="og:image" content="http://yoursite.com/img/base/base001_05.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_06.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_07.jpg">
<meta property="og:image" content="http://yoursite.com/img/base/base001_08.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_09.png">
<meta property="og:image" content="http://yoursite.com/img/base/base001_10.png">
<meta property="og:updated_time" content="2022-11-11T03:08:57.794Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第二章 数据结构">
<meta name="twitter:description" content="基础入门　　什么是数据结构？  数据结构是计算机存储、组织数据的方式。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。  逻辑结构　　所谓逻辑结构，指的是数据及数据间的邻接关系。说白了它描述数据间是以什么方式排列的，而与他们在计算机中的存储位置无关。常见的逻辑结构有如下几种： 　　1、线">
<meta name="twitter:image" content="http://yoursite.com/img/base/base002_01.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/c-base-002/"/>

  <title> 第二章 数据结构 | 不只是看客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">不只是看客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                第二章 数据结构
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2011-05-18T21:10:00+08:00" content="2011-05-18">
              2011-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                    <span itemprop="name">计算机基础</span>
                </span>

                
                

              
            </span>
          

          

          
          
             <span id="/c-base-002/" class="leancloud_visitors" data-flag-title="第二章 数据结构">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><p>　　<strong>什么是数据结构？</strong></p>
<blockquote>
<p>数据结构是计算机存储、组织数据的方式。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系，分为<font color="red">逻辑结构</font>和<font color="red">存储结构</font>。</p>
</blockquote>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>　　所谓逻辑结构，指的是数据及数据间的<font color="red">邻接关系</font>。说白了它描述数据间是以什么方式排列的，而与他们在计算机中的存储位置无关。常见的逻辑结构有如下几种：</p>
<p>　　<strong>1、线性结构</strong><br>　　结构中的元素存在<font color="red">1对1</font>的关系。如下图A、B、C，每个结点最多只有一个直接前驱和一个直接后继，即<font color="red">从前到后</font>顺序排列元素。</p>
<center><br><img src="/img/base/base002_01.png" alt=""><br></center>

<p>　　<strong>2、树形结构</strong><br>　　结构中的元素存在<font color="red">1对多</font>的关系。如下图所示，一个结点可以有多个子结点，但每个结点只能有一个父结点，元素按照上下级的顺序排列。</p>
<center><br><img src="/img/base/base002_02.png" alt=""><br></center>

<p>　　<strong>3、图状结构</strong><br>　　结构中的元素存在<font color="red">多对多</font>的关系。如下图所示，元素之间没有上下级的关系，只有邻接关系。</p>
<center><br><img src="/img/base/base002_03.png" alt=""><br></center>

<p>　　<strong>4、集合</strong><br>　　结构中数据元素除了同属一个集合外，别无任何关系。</p>
<center><br><img src="/img/base/base002_04.png" alt=""><br></center>

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>　　逻辑结构只是在现实世界中对数据的排列方式进行描述，我们需要在计算机中实现它。<br>　　数据的逻辑结构在计算机内的表示称为数据的<font color="red">存储结构</font>，其对逻辑结构的表示有两方面：</p>
<blockquote>
<p>1、对逻辑结构中数据元素的表示（通过2进制表示）。<br>2、对逻辑结构中数据间的邻接关系的表示。</p>
</blockquote>
<p>　　在计算机中数据间的邻接关系有4种：顺序存储、链式存储、索引存储、散列存储：</p>
<blockquote>
<p> 一般使用<font color="red">顺序存储</font>或者<font color="red">链式存储</font>来表示<font color="red">线性结构</font>。<br> 一般使用<font color="red">链式存储</font>来表示<font color="red">树形结构</font>和<font color="red">图状结构</font>。<br> 一般使用<font color="red">散列存储</font>来表示<font color="red">哈希表</font>。</p>
</blockquote>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>　　算法(Algorithm) ：即完成某件事所用的步骤、方法。</p>
<p>　　<strong>算法的五大特性</strong></p>
<blockquote>
<p>第一，有穷性： 算法能在合理的时间内执行完毕，执行1000年的算法不具备有穷性。<br>第二，可行性： 算法中的所有步骤必须是计算机能做到的，除数为0就不具备可行性。<br>第三，确定性： 算法中的每一步都必须清楚，不能有歧义。<br>第四、五，输入/输出性： 算法可以没有输入，但是必须要有输出。</p>
</blockquote>
<p>　　计算机中为什么除数不能为0?</p>
<blockquote>
<p>0在数学中代表着无穷小，无穷小的倒数就是无穷大，任何数除以0得到的结果都是无穷大，而无穷大意味着计算机为了表示这个无穷大的数，内存会被填满，因此不允许除数0。</p>
</blockquote>
<p>　　<strong>算法设计的要求</strong><br>　　设计一个算法要求： 正确性、健壮性、可读性、效率。其中：</p>
<blockquote>
<p>健壮性：也称为鲁棒性，当输入的数据非法时，算法也能应对，即算法是否能经受住各种数据的考验。<br>效率：指的是算法的执行时间与存储量。</p>
</blockquote>
<p>　　说白了一个算法好与坏的评价标准是：<font color="red">正确，可读，健壮，效率高，空间省</font>！</p>
<p>　　<strong>算法效率的度量</strong><br>　　常用的度量算法效率的指标是：</p>
<blockquote>
<p>时间复杂度：在最坏情况下，估计算法执行时间的一个上界，采用大O(字母O)记法。<br>空间复杂度：用来度量算法所需的存储空间，就是算法产生的数据所占据的空间。</p>
</blockquote>
<p>　　时间复杂度，就是程序中基本操作语句执行的次数。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    sum+=i;</span><br></pre></td></tr></table></figure></p>
<p>　　其中<code>sum+=i</code>执行了<code>100</code>次，而<code>for(int i=0;i&lt;100;i++)</code>执行了<code>101</code>次，因此整个程序的时间复杂度为<code>101</code>或者说为<code>n</code>，因为<code>100</code>是一个常数，程序的执行次数会随着这个常数的变化而变化，因此，一般就称其复杂度为<code>n</code>，即<font color="red">线性增长</font>。</p>
<p>　　在分析时间复杂度时，应该<font color="red">以程序或算法中执行次数最多的语句为准</font>，通常情况下是最内层循环的时间复杂多，最内层语句的执行次数计算出来后，取最高的次幂(其他低次幂直接忽略掉)，然后去掉该项中的常数因子即可。</p>
<p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fromModule=lemma_search-box" target="_blank" rel="noopener">百度百科 - 数据结构</a></li>
</ul>
<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>　　<font color="red">线性表</font> (Linear_List) 简称表，由具有相同类型的有限多个数据元素组成的一个有序序列。<br>　　表中数据元素的个数n称为表的长度，长度为0的是空表，在非空线性表中，只有一个首元素和一个尾元素，中间元素有且仅有一个直接前驱和直接后继。</p>
<p>　　线性表按照元素的排列顺序分为：</p>
<blockquote>
<p>有序表：如果线性表中的元素的值按递增(减)顺序排列，则此表称为有序表。<br>无序表：否则称为无序表。</p>
</blockquote>
<p>　　线性表按照表的存储结构分为：</p>
<blockquote>
<p>静态存储：表中元素存放在<font color="red">连续的空间</font>中，使用顺序式存储方式，一般使用数组表示。<br>动态存储：表中元素存放在<font color="red">不连续的空间</font>中，使用链式存储方式，一般需要自己构建链表。</p>
</blockquote>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>　　静态存储在计算机内的表示形式就是：<font color="red">顺序表</font>。</p>
<blockquote>
<p>特点：在内存中开辟连续的存储空间，顺序存储每一个数据元素，两个元素紧挨着存储。<br>优点：顺序表一般使用数组实现，可以使用数组的下标，对元素进行高速的存取。<br>缺点：插入和删除的时候，需要移动元素，尤其是在数组中具有很多元素的情况下，在数组的前部进行数据的插入和删除操作。</p>
</blockquote>
<p><br>　　范例1：顺序表的常见操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10   <span class="comment">//定义数组的最大容量</span></span></span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;     <span class="comment">//定义一个全局变量，用来代表数组内当前元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> element)</span></span>&#123;   <span class="comment">//本函数用于向数组中插入元素 。</span></span><br><span class="line">    <span class="keyword">if</span>(Count == MAX)&#123;   <span class="comment">//如果数组已经满了，则不允许插入新数据。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">array</span>[Count++] = element;   <span class="comment">//否则，就将新数据插入数组，并且更新Count。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>&#123;     <span class="comment">//本函数用于将所有元素输出 。</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Count;i++)&#123;   <span class="comment">//遍历数组，从0开始，一直到最后一个元素结束。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> element)</span></span>&#123;   <span class="comment">//本函数用于删除指定的元素 。</span></span><br><span class="line">    <span class="keyword">int</span> index,i;</span><br><span class="line">    index = search(<span class="built_in">array</span>,element);  <span class="comment">//先查找元素是否存在 。</span></span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">-1</span>)&#123;   <span class="comment">//如果元素存在，则开始删除操作 。</span></span><br><span class="line">        <span class="keyword">for</span>(i=index+<span class="number">1</span>;i&lt;Count;i++)&#123;  <span class="comment">//将待删元素之后的所有元素都前移一个位置 。</span></span><br><span class="line">            <span class="built_in">array</span>[i<span class="number">-1</span>] = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Count-- ;  <span class="comment">//删除成功后，别忘了更新Count 。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//然后函数返回1 。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果元素不存在，则返回-1 。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> element)</span></span>&#123;   <span class="comment">//本函数用于 查找指定元素在数组中的下标。</span></span><br><span class="line">    <span class="keyword">if</span>(Count == <span class="number">0</span>)&#123;            <span class="comment">//如果数组为空，则直接返回-1。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        <span class="comment">//如果数组不为空，则开始进行查找操作。</span></span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Count;i++)&#123;  <span class="comment">//遍历数组，从0开始依次匹配元素。</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] == element)&#123;  <span class="comment">//如果找到了，则返回这个元素的下标。</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//如果最终没有找到，则返回 -1 。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面列出了最基础的三个操作：增、删、查。
</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>　　<font color="red">链表</font>是一种物理存储单元上<font color="red">非连续、非顺序</font>的存储结构，数据元素的逻辑顺序是通过链表中的指针实现的，而所谓的动态存储落实到计算机中，就是通过链表来实现的。</p>
<blockquote>
<p>简单的来说，链表其实就像是火车一样，火车有一个火车头，其后跟着N节车厢，各节车厢尾部都有一个“挂钩”，用于与其他车厢首尾相连，而最后一个车厢尾部是没有挂钩的，或者有挂钩，但是并不去使用它。<br>链表也是如此，每个元素都是链表的一个节点，每个节点内部也都有一个指针，指向下一个节点。同时也有链表头的概念，一个链表全靠表头作为起点，没有表头，根本就没法找到这个链表中的其他元素。</p>
</blockquote>
<p>　　关于链表还需要知道的是：</p>
<blockquote>
<p>特点：链表中的结点分散在内存中的各个角落，相邻的结点间通过指针联系。<br>优点：链表中的结点，只有在需要的时候才去建立，不必事先开辟过多空间，且删除和增加结点时，不需要移动元素。<br>缺点：链表不可以高速存取，结点的存储密度低。</p>
</blockquote>
<p><br>　　范例1：链表的常见操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>   <span class="comment">// 定义一个结点结构体。</span></span><br><span class="line">    <span class="keyword">int</span> sid;  <span class="comment">//数据域。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为struct Node类型起一个别名Student，以方便后面建立变量。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Student</span>;</span> </span><br><span class="line"><span class="comment">//建立一个链表的头结点，以此为链表的表头。</span></span><br><span class="line">Student *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Student *e)</span></span>&#123;    <span class="comment">//本函数用来向链表的表尾增加一个结点。</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;   <span class="comment">//如果链表的表头为空。</span></span><br><span class="line">        head = e;    <span class="comment">// 则将这个结点作为此链表的第一个元素 插入到表头。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果表头结点不为空，说明链表中已存在结点，则继续向下执行。</span></span><br><span class="line">        Student *p = head;  <span class="comment">//将表头结点的地址取出，开始遍历链表。</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;  <span class="comment">//一直遍历到链表的最后一个结点为止。</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = e; <span class="comment">//使最后一个结点的next指针指向新结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;           <span class="comment">//本函数用来遍历链表。</span></span><br><span class="line">    Student *p = head;   <span class="comment">//将表头结点的地址取出，开始遍历链表。</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;  <span class="comment">//如果p不是最后一个结点。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;sid);  <span class="comment">//则将p的值输出。</span></span><br><span class="line">        p = p-&gt;next;  <span class="comment">//p指向下一个结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);  <span class="comment">//遍历完所有结点后，换行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student* <span class="title">search</span><span class="params">(<span class="keyword">int</span> keyword)</span></span>&#123;   <span class="comment">//本函数用来查找链表中的元素。</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;   <span class="comment">//如果链表为空，则直接返回NULL。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//如果链表不为空，则开始查找。</span></span><br><span class="line">        Student *p = head;  <span class="comment">//开始遍历链表。</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;  <span class="comment">//如果p正在指向一个具体的结点。</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;sid == keyword)&#123;  <span class="comment">//判断当前结点是否和指定关键字相等。</span></span><br><span class="line">                <span class="keyword">return</span> p;  <span class="comment">//如果相等的话，则返回p结点。</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;  <span class="comment">//否则继续遍历下去。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//如果到最后仍然没有找到，则返回NULL。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">remove</span><span class="params">(<span class="keyword">int</span> keyword)</span></span>&#123;   <span class="comment">//本函数用来删除链表中的元素。</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;  <span class="comment">//如果链表为空，则直接返回-1。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//如果链表不为空，则开始进行匹配。</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;sid == keyword)&#123; <span class="comment">//如果头结点是待删结点。</span></span><br><span class="line">            head = head-&gt;next;  <span class="comment">//则直接让头结点指向下一结点。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//删除成功，返回1。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//如果头结点不是待删结点。</span></span><br><span class="line">            Student *p1,*p2;  <span class="comment">//准备遍历链表。</span></span><br><span class="line">            p1 = p2 = head; <span class="comment">// p2用来代表当前结点，p1用来保存p2前面的那一个结点。</span></span><br><span class="line">            <span class="keyword">while</span>(p2!=<span class="literal">NULL</span> &amp;&amp; p2-&gt;sid != keyword)&#123; <span class="comment">//如果p2不是待删结点。</span></span><br><span class="line">                p1 = p2;    <span class="comment">//使p1指向p2。</span></span><br><span class="line">                p2 = p2-&gt;next;  <span class="comment">//p2指向下一个结点。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2 != <span class="literal">NULL</span>)&#123;  <span class="comment">//如果p2是待删结点。</span></span><br><span class="line">                p1-&gt;next = p2-&gt;next;  <span class="comment">//让p2前面的结点p1的next指针指向p2的next。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//删除成功返回1。</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//在当前链表中，没找到待删元素，返回-1。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面列出了最基础的三个操作：增、删、查。
-  链表中最后一个结点的next指针为NULL。
</code></pre><p>　　上面介绍的就是最简单的单链表，除此之外，还有如下三种链表：</p>
<blockquote>
<p>双（向）链表：结点中包含有2个指针，分别指向结点的直接前继和直接后继。<br>双端链表：是单链表的变形，具有表头和表尾2个指针，因为在实际应用中经常要在表头和表尾进行插入删除等操作。后面讨论链队的时候，会仔细讲解。<br>循环表：循环表的最后一个结点的next指针不为null，而是指向了表的第一个结点，只要知道某一结点的地址就可以找到该表的所有结点。</p>
</blockquote>
<p>　　<strong>线性表小结</strong></p>
<blockquote>
<p>顺序表：元素顺序存放在一片连续的存储空间中的表。<br>　　优点：可以高速存取，结点的存储密度高。<br>　　缺点：需要开辟连续的存储空间，长度固定。<br>　　使用场合：适合于处理少量数据时使用。<br>链表：元素随机分布在内存的各个地方，各元素之间通过指针来连接。<br>　　优点：不需要开辟连续的存储空间，链表长度可变。<br>　　缺点：结点的存储密度低、不能随机存取。<br>　　使用场合：链表的适合于处理中少量的数据时使用。</p>
</blockquote>
<p>　　上面说在链表中结点的存储密度低，原因如下：</p>
<blockquote>
<p>假设一个结点占20字节，如果用顺序表存储数据，则这20字节可以全用来存储数据。<br>如果使用链表，则至少要分出一些字节，作为指针域，存储下一个结点的信息。<br>因此，所谓的存储密度就是在说，结点中存储空间利用的是否充分。</p>
</blockquote>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>　　栈(Stack) ：<font color="red">只允许在表的一端进行插入和删除的线性表</font>，允许插入和删除的一端称为栈顶(top), 另一端称为栈底(bottom)。</p>
<blockquote>
<p>特点： 后进先出、后来居上。<br>分类： 顺序栈和链栈。<br>常见的操作：压栈、弹栈、判断栈空、返回栈顶、栈内元素个数。</p>
</blockquote>
<p><br>　　范例1：顺序栈。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10      <span class="comment">//定义数组(栈)的最大容量。</span></span></span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;         <span class="comment">//记录当前栈中的元素个数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> element)</span></span>&#123;  <span class="comment">//本函数用来完成压栈操作。</span></span><br><span class="line">    <span class="keyword">if</span>(Count == MAX)&#123;   <span class="comment">//如果栈满了，则不允许压栈。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">//返回-1 。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;            <span class="comment">//如果栈未满，则开始压栈。</span></span><br><span class="line">        <span class="built_in">array</span>[Count++] = element;  <span class="comment">//将元素放到数组的最后一个位置。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">//压栈成功，返回1。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>&#123;   <span class="comment">//本函数用来遍历栈中的元素。</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"栈-----------------------顶"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=Count<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//从最后一个元素开始输出，因为数组的最后一个元素代表栈顶。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t   %d\n"</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"栈-----------------------底\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;      <span class="comment">//本函数用来获得栈中元素的个数。</span></span><br><span class="line">    <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;  <span class="comment">//本函数用来判断栈是否为空。</span></span><br><span class="line">    <span class="keyword">return</span> Count == <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>&#123;  <span class="comment">//本函数用来返回栈中的当前栈顶元素。</span></span><br><span class="line">    <span class="keyword">if</span>(Count == <span class="number">0</span>)&#123;  <span class="comment">//如果栈空，则返回-1。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[Count<span class="number">-1</span>];  <span class="comment">//如果栈没空，则返回栈顶元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>&#123;   <span class="comment">//本函数用来弹出当前栈顶元素。</span></span><br><span class="line">    <span class="keyword">if</span>(Count == <span class="number">0</span>)&#123;   <span class="comment">//如果栈空，则返回-1。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[--Count];   <span class="comment">//如果栈没空，则弹出栈顶元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,<span class="built_in">array</span>[MAX];  <span class="comment">//定义一个数组，用来代表顺序栈。</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)&#123;  <span class="comment">//向栈中压入MAX个元素。</span></span><br><span class="line">        push(<span class="built_in">array</span>,i);  <span class="comment">//通过调用push()函数，来向栈中压入数据。</span></span><br><span class="line">        print(<span class="built_in">array</span>);   <span class="comment">//每压入一个数据，都遍历一遍栈中的元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面列出了最基础的三个操作：增、删、查。
-  压栈的算法和顺序表增加元素的算法是一样的，数组的最后一个元素，代表顺序栈的栈顶，第一个元素代表顺序栈的栈底。
-  本范例只是作为一个范例，若栈内有一个数据元素本身的值就是-1 ，则本范例没有对产生的歧义进行处理。
</code></pre><p><br>　　范例2：链栈。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>          <span class="comment">//定义一个结点类型。</span></span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">20</span>];     <span class="comment">//结点的数据域。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个结点的指针。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Student</span>;</span>  <span class="comment">//给这个结点类型 起一个别名Student。</span></span><br><span class="line">Student *head=<span class="literal">NULL</span>;  <span class="comment">//定义一个栈顶指针。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Student *element)</span></span>&#123; <span class="comment">//本函数用来将一个结点压入栈顶。</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123; <span class="comment">//如果栈顶为空，则将元素压入栈顶。</span></span><br><span class="line">        head = element;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;      <span class="comment">//如果栈顶不为空。</span></span><br><span class="line">        element-&gt;next = head;  <span class="comment">//让新元素的next指向当前栈顶。。</span></span><br><span class="line">        head = element;  <span class="comment">//然后使head指针指向新元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;  <span class="comment">//本函数用来遍历栈中的元素。</span></span><br><span class="line">    Student *p;  <span class="comment">//定义一个用来遍历的指针。</span></span><br><span class="line">    p = head;  <span class="comment">//最初，使指针p指向栈顶元素。</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;  <span class="comment">//如果p当前所指向的位置，不是栈底。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t\t%s\n"</span>,p-&gt;info);  <span class="comment">//输出当前位置的数据。</span></span><br><span class="line">        p = p-&gt;next;  <span class="comment">//p指向栈中的下一个元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);  <span class="comment">//换行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;      <span class="comment">//本函数用来获取栈中元素的个数。</span></span><br><span class="line">    Student *p;  <span class="comment">//定义一个用于遍历栈的指针。</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//用来计算栈中元素的个数，从0开始累计。</span></span><br><span class="line">    p = head;  <span class="comment">//p从栈顶元素开始遍历。</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;  <span class="comment">//如果p当前所指向的位置，不是栈底。</span></span><br><span class="line">        p = p-&gt;next;   <span class="comment">//p指向栈中的下一个元素。</span></span><br><span class="line">        i++;  <span class="comment">//变量增加1。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">//返回最终的结果。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">peek</span><span class="params">()</span></span>&#123;      <span class="comment">//本函数用来获取栈顶元素中info成员的信息。</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;  <span class="comment">//如果栈空。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"null"</span>;   <span class="comment">//则返回一个字符串常量。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//如果栈非空。</span></span><br><span class="line">        <span class="keyword">return</span> head-&gt;info ;    <span class="comment">//则返回栈顶元素中的info成员的信息。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;    <span class="comment">//本函数用来弹出栈顶元素。</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;  <span class="comment">//如果栈空 则返回-1。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     <span class="comment">//如果栈非空。</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">//栈顶指针下移一个位置。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//返回1。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面列出了最基础的三个操作：增、删、查。
-  压栈的算法和顺序表增加元素的算法是一样的，数组的最后一个元素，代表顺序栈的栈顶，第一个元素代表顺序栈的栈底。
-  本范例只是作为一个范例，若栈内有一个数据元素本身的值就是-1 ，则本范例没有对产生的歧义进行处理。
</code></pre><p><br>　　接下来介绍一些算法，来展示一下栈的实际应用。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>　　程序调用自身的编程技巧称为<font color="red">递归（ recursion）</font>。<br>　　接下来，我们通过计算“N!”来介绍递归的写法，其中“N!”表示N的阶乘，即任何大于等于1的自然数n 阶乘表示方法：</p>
<center><br><img src="/img/base/base001_04.svg" alt=""><br></center>

<p><br>　　范例1：阶乘。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) &#123;        <span class="comment">//解决</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                  <span class="comment">//分解</span></span><br><span class="line">        <span class="keyword">return</span> num*fact(num-<span class="number">1</span>);   <span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  递归一定要有一个结束的条件，否则程序就没有出口了，本范例中当num&lt;=1时程序就不会继续向下递归了。
</code></pre><p>　　其实递归属于计算机科学中的一个名为“分治法”的算法。</p>
<blockquote>
<p>字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
</blockquote>
<p>　　分治法是通常是通过函数递归来实现的，其在每一层递归上都有三个步骤：</p>
<blockquote>
<p>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。<br>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。<br>合并：将各个子问题的解合并为原问题的解。</p>
</blockquote>
<p>　　方法/函数的递归，就是利用了栈的原理，后来居上，同时会从最上面开始解决问题。</p>
<p><br>　　范例2：汉诺塔算法（Hanoi）。</p>
<blockquote>
<p>有A、B、C三座塔，其中在A塔上，从下到上地穿好了由大到小的64片金片。<br>任务规则：<br>1、将A塔上面的盘子，全部移动到C塔上。<br>2、一次只能移动一个盘子。<br>3、不论将盘子移动到哪座塔，都需要保证小盘子在大盘子上面，始终保持“上小下大”的顺序。</p>
</blockquote>
<p>　　显然，要完成任务需要三步：</p>
<blockquote>
<p>第一步，要想将A塔上的第64个盘子到C塔，需要将前63个盘子移到B塔上。<br>第二步，将第64个盘子移到C塔。<br>第三步，将移走的前63个盘子从B塔中移回到C塔的第64个盘子的上面。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanio</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 　　按上面说的，我们需要提供出四个数据才能开始移动。</span></span><br><span class="line">    <span class="comment">// 　　第一，指出打算要移走A塔的前几个盘子。</span></span><br><span class="line">    <span class="comment">// 　　第二，当前正在移动的盘子的起点塔 (即想要将盘子从哪个塔移走)。</span></span><br><span class="line">    <span class="comment">// 　　第三，当前正在移动的盘子可以借助的辅助塔。</span></span><br><span class="line">    <span class="comment">// 　　第四，当前正在移动的盘子要移向的目标塔。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanio</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">char</span> start, <span class="keyword">char</span> help, <span class="keyword">char</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            System.out.println(start+<span class="string">" -----&gt;  "</span>+end);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            hanio(count-<span class="number">1</span>, start, end, help);</span><br><span class="line">            System.out.println(start+<span class="string">" -----&gt;  "</span>+end);</span><br><span class="line">            hanio(count-<span class="number">1</span>, help, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hanio test = <span class="keyword">new</span> Hanio();</span><br><span class="line">        test.hanio(<span class="number">64</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>　　范例3：螺旋数。<br>　　从键盘输入一个整数(1~20)，则以该数字为矩阵的大小，把1，2，3 … n(n+1)/2 的数字按照顺时针螺旋的形式填入其中。如：</p>
<blockquote>
<p>输入数字3，则程序输出：<br>1   2   3<br>6   4<br>5<br>输入数字4，则程序输出：<br>1   2   3   4<br>9   10  5<br>8   6<br>7</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelixNumber</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   保存螺旋数的数组。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] array;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   构造方法,初始化array属性。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelixNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   功能：向数组中添加数字。</span></span><br><span class="line"><span class="comment">     *   <span class="doctag">@param</span>  n  当前要添加进数组的数字。</span></span><br><span class="line"><span class="comment">     *   <span class="doctag">@param</span>  x  当前要添加位置的行坐标。</span></span><br><span class="line"><span class="comment">     *   <span class="doctag">@param</span>  y  当前要添加位置的列坐标。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">full</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">this</span>.array.length;</span><br><span class="line">        <span class="comment">// 若数组已经填充完毕，则返回。</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; len*(len+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = x,j = y;</span><br><span class="line">        <span class="comment">// 先填充列上的元素。</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="comment">// 若当前位置上，没有数字，则将n填入进去。</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.array[i][j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">this</span>.array[i][j] = n++;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 若存在数字,则跳出。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于经过上面的操作后，坐标有偏差，所以在此纠正。</span></span><br><span class="line">        j-=<span class="number">2</span>; i+=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//然后填充主对角线上的元素。</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len &amp;&amp; j&gt;=<span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">            <span class="comment">// 若当前位置上，没有数字，则将n填入进去。</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.array[i][j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">this</span>.array[i][j] = n++;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 若存在数字,则跳出。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于经过上面的操作后，坐标有偏差，所以在此纠正。</span></span><br><span class="line">        i-=<span class="number">2</span>; j+=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后填充行上的元素。</span></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 若当前位置上，没有数字，则将n填入进去。</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.array[i][j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">this</span>.array[i][j] = n++;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 若存在数字，则纠正坐标后，跳出循环。</span></span><br><span class="line">                i++; j++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  进行下一轮递归。</span></span><br><span class="line">        <span class="keyword">this</span>.full(n, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h3><p>　　迷宫首先得有一张地图，一般来说都使用一个二维数组来表示地图，二维数组<code>a[i][j]</code>上的值为<code>1</code>代表墙，为<code>0</code>则代表路，如下图所示：</p>
<center><br><img src="/img/base/base001_05.png" alt=""><br></center>

<p>　　有了地图之后呢，很显然咱们得规定一个起点和终点，并且将游戏者放到起点上去。<br>　　从起点开始，按东、南、西、北的顺序开始走，将走过的所有路都置为1(同时压栈)，以防止重复走，如果走到了死路，则回到上一步(弹栈)，一直到走到终点为止。</p>
<p>　　下面是迷宫程序的完整JAVA源代码，一共三个类，可以直接运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：</span></span><br><span class="line"><span class="comment"> * 1. 本类是迷宫程序的入口类，提供了main方法。</span></span><br><span class="line"><span class="comment"> * 2. 本类同时用来构建迷宫程序的主界面。</span></span><br><span class="line"><span class="comment"> * 3. 用户鼠标左键点击窗口中的任意位置即可开始游戏。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MazeFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FRAME_TITLE = <span class="string">"Maze"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MazeFrame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 设置窗口的标题、在屏幕中的初始位置、窗口的宽高。</span></span><br><span class="line">        <span class="keyword">super</span>(FRAME_TITLE);</span><br><span class="line">        setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">        <span class="comment">// 设置用户点击窗口右上角的关闭按钮的动作，此处为摧毁当前JFrame窗口。</span></span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将界面设置到当前JFrame中。</span></span><br><span class="line">        MazePanel panel = <span class="keyword">new</span> MazePanel();</span><br><span class="line">        add(panel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argss)</span></span>&#123;</span><br><span class="line">        MazeFrame mazeFrame = <span class="keyword">new</span> MazeFrame();</span><br><span class="line">        <span class="comment">// 将主窗口置为可见状态。</span></span><br><span class="line">        mazeFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 功能：本类用来描述一个栈。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MazeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; array;  <span class="comment">// 使用一个List对象来保存栈中的元素。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> now_count;       <span class="comment">// 记录当前栈中所具有的元素的个数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MazeStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        now_count = <span class="number">0</span>;</span><br><span class="line">        array = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now_count--;</span><br><span class="line">            <span class="keyword">return</span> (Point) array.remove(now_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T point)</span> </span>&#123;</span><br><span class="line">        array.add(point);</span><br><span class="line">        now_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now_count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (Point) array.get(now_count - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now_count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MazePanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 游戏者的当前位置，Point是系统内置的类，其中包含了x和y两个坐标值。</span></span><br><span class="line">    <span class="keyword">private</span> Point now_point; </span><br><span class="line">    <span class="keyword">private</span> Point start_point; <span class="comment">// 游戏的起点位置。</span></span><br><span class="line">    <span class="keyword">private</span> Point final_point; <span class="comment">// 游戏的终点位置。</span></span><br><span class="line">    <span class="comment">// 记录游戏者最终找到的一条正确的路线中的所有位置。</span></span><br><span class="line">    <span class="keyword">private</span> MazeStack&lt;Point&gt; finalPath; </span><br><span class="line">    <span class="comment">// 记录游戏者所有走过的路线中的所有位置。</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Point&gt; allPath; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mapCopy[][]; <span class="comment">// 地图副本。</span></span><br><span class="line">    <span class="comment">// 游戏者的当前所走的步数，其值最初时为0。</span></span><br><span class="line">    <span class="comment">// 此变量在程序模拟游戏者找路的过程时使用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stepCount; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStarting = <span class="keyword">false</span>; <span class="comment">// 标识程序当前是否处于 “开始游戏” 状态。</span></span><br><span class="line">    <span class="keyword">private</span> Timer time;</span><br><span class="line">    <span class="keyword">private</span> Rectangle2D player; <span class="comment">// 使用一个长方形来代表游戏者。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PASS_BY = <span class="number">2</span>;<span class="comment">// 标识当前位置已经被走过。</span></span><br><span class="line">    <span class="comment">// 迷宫地图。0代表可走，1代表墙，2代表已走过。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> map[][] = </span><br><span class="line">    &#123;       &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MazePanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化地图副本。</span></span><br><span class="line">        mapCopy = <span class="keyword">new</span> <span class="keyword">int</span>[map.length][map.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map[i].length; j++)</span><br><span class="line">                mapCopy[i][j] = map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将游戏者的初始位置置为地图上的 (2,1) 并将该位置压入栈中 。</span></span><br><span class="line">        start_point = now_point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        finalPath = <span class="keyword">new</span> MazeStack&lt;Point&gt;();</span><br><span class="line">        finalPath.push(now_point);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置游戏的终点位置。</span></span><br><span class="line">        final_point = <span class="keyword">new</span> Point(<span class="number">17</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为当前JPanel添加鼠标事件监听器，以便用户点击窗口任意位置后，开始游戏。</span></span><br><span class="line">        addMouseListener(<span class="keyword">new</span> MouseAdapter() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent mouseevent)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 若还没有开始游戏。</span></span><br><span class="line">                <span class="keyword">if</span> (!isStarting) &#123;</span><br><span class="line">                    isStarting = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 游戏者会从(2,1)点出发，探索整个迷宫。</span></span><br><span class="line">                    walk(start_point.x, start_point.y);</span><br><span class="line">                    <span class="comment">// 执行到此处，表示已经探索完迷宫并已经找到出口。</span></span><br><span class="line">                    <span class="comment">// 下面的代码用来播放玩家行走路线，每一步间隔80毫秒。</span></span><br><span class="line">                    time = <span class="keyword">new</span> Timer(<span class="number">80</span>, MazePanel.<span class="keyword">this</span>);</span><br><span class="line">                    time.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        allPath = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 游戏者开始行走。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录当前位置。</span></span><br><span class="line">        allPath.add(<span class="keyword">new</span> Point(i, j));</span><br><span class="line">        <span class="comment">// 若当前位置是终点。</span></span><br><span class="line">        <span class="keyword">if</span> (i == final_point.x &amp;&amp; j == final_point.y) &#123;</span><br><span class="line">            System.out.println(<span class="string">"恭喜您,程序找到出口了! 正确的行走步骤为："</span>);</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; !finalPath.isEmpty(); k++) &#123;</span><br><span class="line">                Point temp = finalPath.pop();</span><br><span class="line">                System.out.println(<span class="string">"( "</span> + temp.x + <span class="string">" , "</span> + temp.y + <span class="string">" )"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"系统：经过辛苦的计算,成功抵达出口,一共需要走 "</span> </span><br><span class="line">                + k + <span class="string">" 步。"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[i][j] = PASS_BY; <span class="comment">// 标识当前位置已经被走过。</span></span><br><span class="line">            <span class="keyword">if</span> (map[i][j + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前位置的东部（上北下南左西右东）仍然可以行走，则向东走。</span></span><br><span class="line">                finalPath.push(<span class="keyword">new</span> Point(i, j + <span class="number">1</span>));</span><br><span class="line">                walk(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map[i + <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前位置的南部仍然可以行走，则向南走。</span></span><br><span class="line">                finalPath.push(<span class="keyword">new</span> Point(i + <span class="number">1</span>, j));</span><br><span class="line">                walk(i + <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前位置的西部仍然可以行走，则向西走。</span></span><br><span class="line">                finalPath.push(<span class="keyword">new</span> Point(i, j - <span class="number">1</span>));</span><br><span class="line">                walk(i, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map[i - <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前位置的北部仍然可以行走，则向北走。</span></span><br><span class="line">                finalPath.push(<span class="keyword">new</span> Point(i - <span class="number">1</span>, j));</span><br><span class="line">                walk(i - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若当前位置旁边的四个方向都走不通(已走过或是死路)，则返回上一步。</span></span><br><span class="line">            <span class="keyword">if</span> (!finalPath.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.allPath.add(finalPath.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：通过定时器来模拟游戏者的行走过程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionevent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now_point.x != final_point.x || now_point.y != final_point.y) &#123;</span><br><span class="line">            now_point.x = ((Point) allPath.get(stepCount)).x;</span><br><span class="line">            now_point.y = ((Point) allPath.get(stepCount)).y;</span><br><span class="line">            stepCount++;</span><br><span class="line">            repaint(); <span class="comment">// 重绘界面。</span></span><br><span class="line">            System.out.println(<span class="string">"( "</span> + now_point.x + <span class="string">" , "</span> + now_point.y + <span class="string">" )"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String msg = JOptionPane.showInputDialog(<span class="keyword">null</span>, </span><br><span class="line">                <span class="string">" 恭喜您,抵达出口!\n您一共走过了"</span> + stepCount </span><br><span class="line">                + <span class="string">"步,请问你现在是什么感想?"</span>);</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, msg + <span class="string">"  ?  哈哈,那恭喜您了"</span>);</span><br><span class="line">            <span class="comment">// 停止定时器。</span></span><br><span class="line">            time.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paint(g);</span><br><span class="line">        Graphics2D graphics2d = (Graphics2D) g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapCopy.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mapCopy[i].length; j++) &#123;</span><br><span class="line">                player = <span class="keyword">new</span> java.awt.geom.Rectangle2D.Double(i * <span class="number">25</span> + <span class="number">110</span>,</span><br><span class="line">                 j * <span class="number">25</span> + <span class="number">20</span>, <span class="number">24</span>D, <span class="number">24</span>D);</span><br><span class="line">                <span class="keyword">if</span> (mapCopy[j][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == now_point.x &amp;&amp; i == now_point.y) &#123;</span><br><span class="line">                        graphics2d.setPaint(Color.blue);</span><br><span class="line">                        graphics2d.fill(player);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    graphics2d.setPaint(Color.red);</span><br><span class="line">                    graphics2d.fill3DRect(i * <span class="number">25</span> + <span class="number">110</span>, j * <span class="number">25</span> + <span class="number">20</span>, </span><br><span class="line">                        <span class="number">24</span>, <span class="number">24</span>, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>　　一个表达式由<font color="red">操作数</font>、<font color="red">操作符</font>和<font color="red">分界符</font>三部分组成：</p>
<blockquote>
<p>比如表达式“(3+4)/2”<br>其中3、4、2是操作数，+、/是操作符，括号是分界符</p>
</blockquote>
<p>　　拿上面的表达式来说，表达式的结果我们看一眼就知道，但是计算机不能像咱们这样做，因为它不会，为了让计算机能正确算出结果，我们需要准备2个栈，一个是符号栈（用来存放操作符），另一个是数字栈（用来存放操作数）。</p>
<p>　　计算机会从左到右顺序扫描表达式，并进行如下判断：</p>
<blockquote>
<p>若是操作数，则直接压入数字栈。<br>若是操作符，则进一步判断：<br>　　若当前符号栈为空，则直接将该运算符压入符号栈。<br>　　若当前符号栈栈顶符号是左括号‘(’则也直接将该运算符压入符号栈。<br>　　若当前符号栈栈顶符号的优先级&lt;该运算符，还是直接将该运算符压栈。<br>　　若当前符号栈栈顶符号的优先级&gt;=该运算符，则将栈顶运算符(OP)取出来，接着从数字栈中取2个数b、a，将a(OP)b的结果压入数字栈中。<br>　　若当前符号是右括号‘)’，则不将它压入栈，而是不断从2个栈中，弹出1个符号和2个操作数，然后将运算结果压入数字栈，直到遇到左括号‘(’。<br>　　然后，继续向表达式的后面扫描，直到表达式结束。</p>
</blockquote>
<p>　　下面是表达式求值程序的完整JAVA源代码，一共三个类，可以直接运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数为null"</span>);</span><br><span class="line">        Node&lt;T&gt; curr = <span class="keyword">new</span> Node&lt;T&gt;(data, head);</span><br><span class="line">        head = curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        T data = head.getData();</span><br><span class="line">        head = head.getNext();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> head.getData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链栈的节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式计算类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedStack&lt;Double&gt; numStack; <span class="comment">// 数字栈</span></span><br><span class="line">    <span class="keyword">private</span> LinkedStack&lt;Character&gt; chStack; <span class="comment">// 符号栈</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Expression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numStack = <span class="keyword">new</span> LinkedStack&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">this</span>.chStack = <span class="keyword">new</span> LinkedStack&lt;Character&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">compulation</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expression == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数为null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> value = Double.NaN;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 分解表达式 将结果放到符号栈和数字栈。</span></span><br><span class="line">            pushStack(expression);</span><br><span class="line">            <span class="comment">// 不断的从符号栈弹出符号进行计算。</span></span><br><span class="line">            <span class="keyword">while</span> (!chStack.isEmpty()) &#123;</span><br><span class="line">                calc();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算完后 栈顶元素就是表达式的结果。</span></span><br><span class="line">            value = numStack.pop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"表达式不规范或者包含非法字符,停止计算!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushStack</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(expression);</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 尝试从字符串头部解析出一个数字</span></span><br><span class="line">            <span class="keyword">boolean</span> mark = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                c = str.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (!(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + (c - <span class="number">48</span>);</span><br><span class="line">                str.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">                mark = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mark) &#123;</span><br><span class="line">                numStack.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (chStack.peek() != <span class="string">'('</span>)</span><br><span class="line">                        calc();</span><br><span class="line">                    chStack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!chStack.isEmpty() &amp;&amp; chStack.peek() != <span class="string">'('</span></span><br><span class="line">                            &amp;&amp; (chStack.peek() == <span class="string">'*'</span> || chStack.peek() == <span class="string">'/'</span> </span><br><span class="line">                                || chStack.peek() == <span class="string">'%'</span>))</span><br><span class="line">                        calc();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!chStack.isEmpty() &amp;&amp; chStack.peek() != <span class="string">'('</span>)</span><br><span class="line">                        calc();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">')'</span>)</span><br><span class="line">                    chStack.push(c);</span><br><span class="line">                str.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Double b = numStack.pop();</span><br><span class="line">        Double a = numStack.pop();</span><br><span class="line">        <span class="keyword">char</span> op = chStack.pop();</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            numStack.push(a + b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            numStack.push(a - b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            numStack.push(a * b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">                numStack.push(a / b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">            numStack.push(a % b);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Expression exp = <span class="keyword">new</span> Expression();</span><br><span class="line">        System.out.print(<span class="string">"输入表达式:  "</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String expression = sc.next();</span><br><span class="line">        System.out.println(exp.compulation(expression));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  输入“55-4*5+(4+1*100/(5-3))*3+(4+2)”，程序输出“203.0”。
</code></pre><p><br>　　关于表达式，还有以下两个小知识点，了解即可。</p>
<p>　　<strong>表达式的分类</strong></p>
<blockquote>
<p>中缀表达式：A+B<br>前缀表达式：+AB<br>后缀表达式：AB+</p>
</blockquote>
<p>　　显而易见，操作符在前，则就叫前缀表达式，以此类推。</p>
<p>　　<strong>中缀式转后缀式</strong></p>
<blockquote>
<p>中缀式： a+b*(c-d)-e/f<br>后缀式： abcd-*+ef/-</p>
</blockquote>
<p>　　转换过程：</p>
<blockquote>
<p>1、在a+b*(c-d)-e/f中，最先计算(c-d)，而c-d的后缀式就是cd-。<br>2、接着计算b*(cd-)，因此就是bcd-*，就是把*放到式子的最后面。<br>3、然后计算a+(bcd-*)，因此就是abcd-*+<br>4、接着计算e/f，因此就是ef/<br>5、最后计算(abcd-*+)-(ef/)，因此结果就是abcd-*+ef/-。</p>
</blockquote>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>　　<font color="red">队列( Queue )</font>：插入和删除操作必须分别在不同的两端进行的线性表。允许插入的一端称<font color="red">队尾</font>，允许删除的一端称<font color="red">队首</font>，</p>
<blockquote>
<p>特点：先进先出。(FIFO，first in first out)<br>分类：顺序队 和 链队。</p>
</blockquote>
<p>　　由于队列的插入和删除操作分别在表的两端进行，因此需要设置<font color="red">队头指针</font>和<font color="red">队尾指针</font>。</p>
<p><br>　　范例1：链队。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;   <span class="comment">//结点中的数据域。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//结点中的指针域。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span>  <span class="comment">//为结点结构体起一个别名，将struct Node改成 Node 。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>     <span class="comment">//定义一个队列结构体。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span>  <span class="comment">//队列的队首指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span>   <span class="comment">//队列的队尾指针。</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue* <span class="title">createQueue</span><span class="params">()</span></span>&#123;      <span class="comment">//本函数用来建立一个队列。</span></span><br><span class="line">    Queue *que = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue *));  <span class="comment">//从内存中开辟队列空间。</span></span><br><span class="line">    <span class="keyword">if</span>(que == <span class="literal">NULL</span>)&#123;  <span class="comment">//如果开辟失败，则返回NULL。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    que-&gt;front = <span class="literal">NULL</span>;  <span class="comment">//如果开辟成功，则初始化队列的头指针。</span></span><br><span class="line">    que-&gt;rear = <span class="literal">NULL</span>;   <span class="comment">//初始化队列的尾指针。</span></span><br><span class="line">    <span class="keyword">return</span> que;  <span class="comment">//返回这个队列。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;   <span class="comment">//本函数用来建立一个结点。</span></span><br><span class="line">    Node* temp = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *));  <span class="comment">//从内存中开辟结点空间。</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)&#123;  <span class="comment">//如果开辟失败，则返回NULL。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;data = i;  <span class="comment">//如果开辟成功，则初始化结点的数据域。</span></span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//初始化结点的next指针。</span></span><br><span class="line">    <span class="keyword">return</span> temp;  <span class="comment">//返回这个结点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Queue* que)</span></span>&#123;  <span class="comment">//本函数用来判断队列是否为空。</span></span><br><span class="line">    <span class="keyword">return</span> que-&gt;front == <span class="literal">NULL</span>;  <span class="comment">//如果头指针为NULL 则就认为队列为空。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Queue* que,Node *element)</span></span>&#123;   <span class="comment">//本函数用来将元素入队。</span></span><br><span class="line">    <span class="keyword">if</span>(element == <span class="literal">NULL</span>)&#123;    <span class="comment">//如果元素为空，则不允许入队。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(que))&#123;     <span class="comment">//如果队列为空。</span></span><br><span class="line">        que-&gt;front = que-&gt;rear = element;    <span class="comment">// 头指针和尾指针同时指向新元素。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//如果队列不为空。</span></span><br><span class="line">        que-&gt;rear-&gt;next = element;     <span class="comment">// 则将新元素增加到当前队尾的后面。</span></span><br><span class="line">        que-&gt;rear = element;    <span class="comment">// 修改队尾指针。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">(Queue* que,<span class="keyword">int</span> *result)</span></span>&#123;   <span class="comment">//本函数用来返回队首元素。</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(que))&#123;  <span class="comment">//如果队列为空。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//则肯定无法返回队首元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">    *result = que-&gt;front-&gt;data;  <span class="comment">//如果队列非空，则将队首元素的data域的值赋值给result。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//返回成功。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Queue* que)</span></span>&#123;  <span class="comment">//本函数用来遍历队列。</span></span><br><span class="line">    Node* p = que-&gt;front;  <span class="comment">//建立一个临时结点，从队首指针开始，向后遍历。</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;  <span class="comment">//如果当前结点不为空。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);  <span class="comment">//输出当前结点的数据域。</span></span><br><span class="line">        p = p-&gt;next;  <span class="comment">//当前结点继续向后遍历。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);  <span class="comment">//换行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(Queue* que)</span></span>&#123;   <span class="comment">//本函数用来将队列元素出队。</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(que))&#123;  <span class="comment">//如果队列为空 则返回0。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    que-&gt;front = que-&gt;front-&gt;next; <span class="comment">//否则，使队列的队首元素指向下一个元素。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//返回成功标记。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面列出了最基础的三个操作：增、删、查。
</code></pre><h2 id="数组、矩阵"><a href="#数组、矩阵" class="headerlink" title="数组、矩阵"></a>数组、矩阵</h2><p>　　<strong>数组</strong><br>　　<font color="red">数组(Array)</font>本身也是一个数据结构，是线性表的推广。数组元素的个数是固定的，一旦数组定义完毕，其长度就不能再发生变化，且数组元素具有相同的数据类型。</p>
<blockquote>
<p>使用n表示数组的维数：<br>当n=1时，称其为一维数组，一维数组是一个定长的线性表。<br>当n&gt;1时，称其为多维数组，如二维数组。二维数组本身也是一个线性表，它的每一个元素都是一个线性表。 </p>
</blockquote>
<p>　　二维数组存储元素的方式：按行存储和按列存储。现在假设每个数据元素占用<code>L</code>个单元，<code>m、n</code>为数组的行和列<code>(m,n&gt;=1)</code>，且<code>i</code>表示行数<code>j</code>表示列数：</p>
<blockquote>
<p>按行存储方式，地址计算公式：Loc(aij) = Loc(a11) + ((i-1)<em>n+j-1)</em>L<br>按列存储方式，地址计算公式：Loc(aij) = Loc(a11) +((j-1)<em>m+i-1)</em>L</p>
</blockquote>
<p>　　<strong>矩阵</strong><br>　　矩阵就是一个二维数组，它分为：</p>
<blockquote>
<p> 普通矩阵：元素分布无规律。<br> 特殊矩阵：值相同的元素或零元素在矩阵中分布有一定的规律，其又可以分为对称矩阵和三角矩阵。<br> 稀疏矩阵：零元素在矩阵中占比重非常大，且非0元素分布无规律。</p>
</blockquote>
<p>　　其中特殊矩阵和稀疏矩阵可以被压缩存储。</p>
<blockquote>
<p>之所以要对矩阵压缩，是因为矩阵是很多科学与工程计算问题中研究的数学对象，为了节省存储空间，才需要对他们进行压缩，而所谓的压缩存储是指：为多个值相同的元只分配一个存储空间，对零元不分配空间。</p>
</blockquote>
<p><br>　　范例1：n*n二维数组倒置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 3</span></span><br><span class="line">main()&#123;    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[MAX][MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;MAX;j++)&#123;</span><br><span class="line">           temp = <span class="built_in">array</span>[i][j];</span><br><span class="line">           <span class="built_in">array</span>[i][j] = <span class="built_in">array</span>[j][i];</span><br><span class="line">           <span class="built_in">array</span>[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对称矩阵压缩"><a href="#对称矩阵压缩" class="headerlink" title="对称矩阵压缩"></a>对称矩阵压缩</h3><p>　　对称矩阵是指一个行列相等、以<font color="red">主对角线</font>为对称轴，各元素对应相等（<code>Aij == Aji</code>）的矩阵。</p>
<center><br><img src="/img/base/base001_06.png" alt=""><br></center>

<blockquote>
<p>所谓主对角线，就是指从矩阵左上角到右下角这一斜线方向上的n个元素所在的对角线。<br>上图中的红线就是主对角线。</p>
</blockquote>
<p>　　对阵矩阵的存储空间为<code>n²</code>，我们只需要压缩其上三角(或下三角)+主对角线上的元素即可，压缩后有<code>n*(n+1)/2</code>个元素，可以存储在一个一维数组里。</p>
<p><br>　　范例1：下三角矩阵按行压缩。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">zipArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[][MAX])</span></span>&#123;  <span class="comment">//本函数用来压缩一个对称矩阵。</span></span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(MAX*(MAX+<span class="number">1</span>)/<span class="number">2</span>)); </span><br><span class="line">    <span class="keyword">int</span> i ,j,index;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            index = i*(i+<span class="number">1</span>)/<span class="number">2</span>+j;  <span class="comment">//计算aij在一维数组中的位置。</span></span><br><span class="line">            temp[index] = <span class="built_in">array</span>[i][j];  <span class="comment">//将aij存放到index指定的位置中去。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;  <span class="comment">//返回压缩后的矩阵。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  下三角按行压缩： index=i*(i+1)/2+j
-  上三角按列压缩： index=j*(j+1)/2+i
</code></pre><p><br>　　范例2：当然也可以这样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">zipArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[][MAX])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(MAX*(MAX+<span class="number">1</span>)/<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">int</span> i ,j,index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="comment">// 直接这么写，就完事了。</span></span><br><span class="line">            temp[index++] = <span class="built_in">array</span>[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例3：解压缩。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unzipArray</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">// 如果用户给出的坐标在下三角区。</span></span><br><span class="line">    <span class="keyword">if</span>(j&lt;=i)&#123;</span><br><span class="line">        <span class="comment">// 使用下三角按行的压缩公式，将元素取出。</span></span><br><span class="line">        temp = p[i*(i+<span class="number">1</span>)/<span class="number">2</span>+j];  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">        <span class="comment">// 如果用户给出的坐标在上三角区。</span></span><br><span class="line">        <span class="comment">// 在对称矩阵中，下三角按行压缩和上三角按列压缩，压缩出来的数组是一样的。</span></span><br><span class="line">        <span class="comment">// 因此，如果用户输入的是上三角区的坐标，则应该用这个公式，来从一维数组中取数据。</span></span><br><span class="line">        <span class="comment">// 使用上三角按列的压缩公式，将元素取出。</span></span><br><span class="line">        temp = p[j*(j+<span class="number">1</span>)/<span class="number">2</span>+i];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  所谓的解压缩，就是指给定一个数组p，以及i和j坐标，函数计算出该位置上元素的值。
</code></pre><h3 id="三角矩阵压缩"><a href="#三角矩阵压缩" class="headerlink" title="三角矩阵压缩"></a>三角矩阵压缩</h3><p>　　三角矩阵是方形（<code>n*n</code>）矩阵的一种，因其“<font color="red">非C</font>”元素的排列呈三角形状而得名，三角矩阵分<font color="red">上三角矩阵</font>和<font color="red">下三角矩阵</font>两种：</p>
<blockquote>
<p>下三角矩阵：非C元素在矩阵的下三角区，反之则是上三角矩阵。<br>1 C C<br>2 3 C<br>4 5 6<br>其中C代表相同的一个常数，上面的矩阵可以换写成：<br>1 9 9<br>2 3 9<br>4 5 6</p>
</blockquote>
<p><br>　　范例1：下三角按行压缩三角矩阵。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">zipArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[][MAX])</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(MAX*(MAX+<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">int</span> i ,j,index;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=MAX;j++)&#123;</span><br><span class="line">            index = i*(i+<span class="number">1</span>)/<span class="number">2</span>+j;  </span><br><span class="line">            temp[index] = <span class="built_in">array</span>[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[MAX*(MAX+<span class="number">1</span>)/<span class="number">2</span>] = <span class="built_in">array</span>[<span class="number">0</span>][MAX<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   一个n*n的三角矩阵，压缩后一定为 n*(n+1)/2+1个元素。
-  上三角矩阵就压缩上三角，下三角矩阵就压缩下三角。
-  三角矩阵的压缩就是在对称矩阵的最后加一个元素而已。
</code></pre><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>　　在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为<font color="red">稀疏矩阵</font>。存储方法：</p>
<blockquote>
<p>由于稀疏矩阵非0元素的分布没有什么规律可言，因此在存储非零元素值的同时，还必须存储它在矩阵中的位置（行号和列号）。<br>即每个结点至少要有：i、j、aij三个信息，我们称其为一个“三元组”。</p>
</blockquote>
<p>　　元素的三元组，再加上一个特殊的三元组就组成一个稀疏矩阵的三元组表。<br>　　特殊的三元组：表示矩阵的行数、列数、以及非0元素的个数。</p>
<p>　　下面是一个3行4列的稀疏矩阵：</p>
<blockquote>
<p>8 0 0 1<br>0 4 0 0<br>0 0 6 0     </p>
</blockquote>
<p>　　那么这个稀疏矩阵的三元组表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M3*<span class="number">4</span> = &#123;</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>&#125;, &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="矩阵乘积"><a href="#矩阵乘积" class="headerlink" title="矩阵乘积"></a>矩阵乘积</h3><p>　　首先，只有当<code>矩阵A</code>的列数与<code>矩阵B</code>的行数相等时<code>A×B</code>才有意义。<br>　　然后，一个矩阵<code>a(m,n)</code>乘以矩阵<code>b(n,p)</code>，会得到矩阵<code>c(m,p)</code>。</p>
<p>　　那具体是如何乘的呢？假设有如下两个矩阵：<br>　　A：      </p>
<blockquote>
<p>1  2<br>3  4<br>5  6 </p>
</blockquote>
<p>　　B：</p>
<blockquote>
<p>5  6  7<br>8  9  10</p>
</blockquote>
<p>　　具体过程： </p>
<blockquote>
<p>首先，用A的第一行依次乘以B的每一列。<br>C[0][0] = 1*5 + 2*8<br>C[0][1] = 1*6 + 2*9<br>C[0][2] = 1*7 + 2*10<br>然后，用A的第二行依次乘以B的每一列。<br>C[1][0] = 3*5 + 4*8<br>C[1][1] = 3*6 + 4*9<br>C[1][2] = 3*7 + 4*10<br>最后，用A的第三行依次乘以B的每一列。<br>C[2][0] = 5*5 + 6*8<br>C[2][1] = 5*6 + 6*9<br>C[2][2] = 5*7 + 6*10</p>
</blockquote>
<p>　　矩阵乘法的两个重要性质：</p>
<blockquote>
<p>矩阵乘法不满足交换律：假设A*B可以相乘，但是交换过来后B*A两个矩阵有可能根本不能相乘。<br>矩阵乘法满足结合律：假设有三个矩阵A、B、C，那么(AB)C和A(BC)的结果的第i行第j列上的数都等于所有A(ik)*B(kl)*C(lj)的和（枚举所有的k和l）。</p>
</blockquote>
<p><br>　　范例1：矩阵乘积。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 2</span></span><br><span class="line">main()&#123;   </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">//定义一个3行2列的数组a。</span></span><br><span class="line">    <span class="keyword">int</span> b[MAX][<span class="number">3</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;    <span class="comment">//定义一个2行3列的数组b。</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">3</span>];  <span class="comment">//a和b的乘积是一个3行3列的数组。</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;   <span class="comment">// i 控制数组c的行数的变化。</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;  <span class="comment">// j 控制数组c的列数的变化。</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;   <span class="comment">// 迭代变量。</span></span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;MAX;k++)&#123;  <span class="comment">// k控制数组a和b共同的部分。</span></span><br><span class="line">                sum +=a[i][k]*b[k][j];   <span class="comment">// 开始计算。</span></span><br><span class="line">            &#125;</span><br><span class="line">            c[i][j] = sum;  <span class="comment">// 将结果赋值给Cij 。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>　　串：就是字符串，它是一种特殊的线性表，它的数据元素只能是字符，串可以为空，空串是任意串的子串。</p>
<blockquote>
<p>基本操作： 合并(插入和连接)、删除子串、比较、倒置。</p>
</blockquote>
<p>　　本节不会去介绍字符串的基本操作，而是会着重介绍字符串的“模式匹配”算法。</p>
<p>　　<strong>模式匹配</strong><br>　　所谓模式匹配，就是找到子串（也称为模式串）在主串（也称为目标串）中出现的下标。<br>　　模式匹配有两种方法： </p>
<blockquote>
<p>朴素模式匹配：朴素模式匹配没有KMP算法效率高，当目标串和模式串过长时，效率很低。<br>KMP模式匹配：KMP算法就是在目标串和模式串过长时使用的匹配算法。</p>
</blockquote>
<h3 id="朴素模式匹配"><a href="#朴素模式匹配" class="headerlink" title="朴素模式匹配"></a>朴素模式匹配</h3><p>　　朴素模式匹配(Brute-Fore)算法又称为BF算法，算法的思想：</p>
<blockquote>
<p>使用子串从主串的第一个字符依次开始匹配。<br>如果失配，则用主串的下一个字符重新和子串的第一个字符比较，然后一次类推，若到最后仍匹配失败，则返回-1。</p>
</blockquote>
<p>　　例： 在主串 abcd中匹配子串cd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">cd   失败</span><br><span class="line">abcd</span><br><span class="line"> cd  失败</span><br><span class="line">abcd</span><br><span class="line">  cd 成功</span><br></pre></td></tr></table></figure></p>
<p>　　每次比较失配后，模式串的指针都要回退到第一个字符，重新和主串下一个字符比较。<br>　　算法最多会匹配<code>(m-n+1)</code>次，其中<code>m</code>和<code>n</code>分别是主串和子串的长度。<br>　　时间复杂度为<code>T(n)=O((m-n+1)*n)</code>，共比较了<code>(m-n+1)</code>遍，每遍比较子串长度个字符。<br><br>　　范例1：BF模式匹配。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//super代表主串。Sub代表子串。m代表主串的长度。n代表子串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span> <span class="keyword">super</span>[],<span class="keyword">char</span> sub[],<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,index=-<span class="number">1</span>; <span class="comment">//i用来遍历主串，j用来遍历子串。</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;m &amp;&amp; j&lt;n)&#123;  <span class="comment">//如果，子串和主串都没有到结尾，则继续匹配。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">super</span>[i] == sub[j])&#123;  <span class="comment">//如果主串的当前字符和子串相同。</span></span><br><span class="line">            i++;j++;   <span class="comment">//则继续比较下一个字符。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果主串的当前字符和子串不相同。</span></span><br><span class="line">            i = i-j+<span class="number">1</span>;  <span class="comment">//则主串回到本次比较的起点之后的那个位置。</span></span><br><span class="line">            j = <span class="number">0</span>;  <span class="comment">//子串回到开头。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==n)&#123; <span class="comment">//如果子串到达了串尾，则证明匹配成功了。</span></span><br><span class="line">        index = i-j;  <span class="comment">//计算子串在主串中出现的位置。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;  <span class="comment">//返回这个位置，如果没找到子串，则返回index的本身值 -1 。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h3><p>　　KMP算法是模式匹配专用算法，它是在已知模式串的<code>next</code>或<code>nextval</code>数组的基础上执行的，如果不知道它们二者之一，就没法使用KMP算法，因此我们需要先计算它们。</p>
<p>　　KMP算法由两部分组成。</p>
<blockquote>
<p>第一部分，计算模式串的<code>next</code>或<code>nextval</code>数组（二者选一即可）。<br>第二部分，利用计算好的模式串的<code>next</code>或<code>nextval</code>数组，进行模式匹配。</p>
</blockquote>
<p>　　问：<code>next</code>和<code>nextval</code>数组是干什么用的？<br>　　答：</p>
<blockquote>
<p>首先，next和nextval数组它们都是隶属于子串的。<br>然后，子串中每一个字符都有一个next或nextval数组的元素与之对应，也就是说如果子串长度为6，则该子串的next和nextval数组的长度就是6，如果子串长度为5，则next和nextval数组长度也就是5。<br>接着，子串中每个字符对应一个next或nextval数组的元素，当子串和主串进行匹配且失配时，子串不再像BF算法那样，直接回到串首了，而是看子串在哪个字符上失配，就找到那个字符对应的next或nextval数组中的元素，然后跳到该元素所指向的位置上去。</p>
</blockquote>
<p>　　说白了<code>next</code>和<code>nextval</code>数组就是在子串失配时，指明子串应前往的位置，这样就大大减少了比较次数，因此说KMP算法比BF算法性能要高。</p>
<blockquote>
<p>KMP算法中有next数组和nextval数组之分，他们代表的意义和作用完全一样，完全可以混用。 唯一不同的是，next数组在一些情况下有些缺陷，而nextval是为了弥补这个缺陷而产生的。  至于什么缺陷，一会说。</p>
</blockquote>
<p>　　<strong>Next数组计算方法</strong></p>
<blockquote>
<p>首先，正如前面所说，子串在哪个字符上失配，就找到那个字符对应的next数组中的元素。<br>然后，next数组中的元素值是由它前面位置上的字符的next值推导出。即 “abc”中b字符的next值，由a的next值推导出，c的next值由a或b的next值推导出。</p>
<p>最后，开始计算：<br>1、第1个字符的next数组的值固定为0。<br>2、计算第n（n&gt;1）个字符的next值时，看第n-1个字符是否和第n-1个字符的next值指向位上的字符相等。<br>如果相等，则第n个字符的next值就是第n-1个字符的next值+1，即<code>next[n]=next[n-1]+1</code>。<br>如果不相等，则继续向前找，看第n-1个字符是否和<code>next[next[n-1]]</code>指向的字符相等，如果相等则<code>next[n]=next[next[n-1]]+1</code>，然后重复下去。若直到最后next值=0了都没有找个任何一个字符与第n-1个字符相同，则next[n]=1；</p>
</blockquote>
<p><br>　　范例1：计算串“A=<code>ababaabab</code>”的<code>next</code>数组。</p>
<blockquote>
<p>我们假设数组的下标是从1开始计算。<br>第一步，按照规定第一个<code>a</code>的<code>next</code>值为0，即<code>next[1]=0;</code>。<br>第二步，计算第二个字符<code>b</code>的<code>next</code>值，由于<code>b</code>的下标为<code>2</code>，所以进行：<br>　　判断<code>A[2-1]</code>是否等于<code>A[next[2-1]]</code>，由于<code>next[2-1]</code>值为<code>0</code>，所以<code>next[2]=1</code>。<br>第三步，计算第三个字符<code>a</code>的<code>next</code>值，由于<code>a</code>的下标为3，所以进行：<br>　　判断<code>A[3-1]</code>是否等于<code>A[next[3-1]]</code>，结果<code>b!=a</code>。<br>　　继续判断<code>A[3-1]</code>是否等于<code>A[next[next[3-1]]]</code>，后者<code>next</code>值为<code>0</code>，所以<code>next[3]=1</code>。<br>第四步，计算第四个字符<code>b</code>的<code>next</code>值，由于<code>b</code>的下标为4，所以进行：<br>　　判断<code>A[4-1]</code>是否等于<code>A[next[4-1]]</code>，结果<code>a==a</code>，所以<code>next[4]=1+1</code>。<br>第五步，计算第五个字符<code>a</code>的<code>next</code>值，由于<code>a</code>的下标为5，所以进行：<br>　　判断<code>A[5-1]</code>是否等于<code>A[next[5-1]]</code>，结果<code>b==b</code>，所以<code>next[5]=2+1</code>。<br>第六步，计算第六个字符<code>a</code>的<code>next</code>值，由于<code>a</code>的下标为6，所以进行：<br>　　判断<code>A[6-1]</code>是否等于<code>A[next[6-1]]</code>，结果<code>a==a</code>，所以<code>next[6]=3+1</code>。<br>第七步，计算第七个字符<code>b</code>的<code>next</code>值，由于<code>b</code>的下标为7，所以进行：<br>　　判断<code>A[7-1]</code>是否等于<code>A[next[7-1]]</code>，后者为<code>A[4]</code>，结果<code>a!=b</code>。<br>　　继续判断<code>A[7-1]</code>是否等于<code>A[next[next[7-1]]]</code>，后者为<code>A[2]</code>，结果<code>a!=b</code>。<br>　　继续判断<code>A[7-1]</code>是否等于<code>A[next[next[next[7-1]]]]</code>，后者为<code>A[1]</code>，结果<code>a==a</code>，所以<code>next[7]=next[2]+1</code>。　<br>第八步和第九步，省略。</p>
</blockquote>
<p>　　最终串“ababaabab”的<code>next</code>数组为：</p>
<blockquote>
<p>0  1  1  2  3  4  2  3  4</p>
</blockquote>
<p><br>　　<strong>Nextval数组计算方法</strong><br>　　首先要知道nextval数组是在next数组的基础上计算出来的，计算过程：</p>
<blockquote>
<p>1、第1个字符的nextval数组的值固定为0。<br>2、计算第n(n&gt;1)个字符的nextval值时，看第n个字符和它的next值指向位上的字符是否相等。<br>若相等，则第n位字符的<code>nextval[n]=nextval[next[n]]</code>。<br>若不相等，则第n位字符的<code>nextval[n]=next[n]</code>。</p>
</blockquote>
<p><br>　　范例2：计算串“A=<code>ababaabab</code>”的<code>nextval</code>数组。</p>
<blockquote>
<p>我们假设数组的下标是从1开始计算。<br>第一步，按照规定第一个<code>a</code>的<code>nextval</code>值为0，即<code>nextval[1]=0;</code>。<br>第二步，计算第二个字符<code>b</code>的<code>nextval</code>值，由于<code>b</code>的下标为<code>2</code>，所以进行：<br>　　判断<code>A[2]</code>是否等于<code>A[next[2]]</code>，结果<code>b!=a</code>，则<code>nextval[2]=1</code><br>第三步，计算第三个字符<code>a</code>的<code>nextval</code>值，由于<code>a</code>的下标为3，所以进行：<br>　　判断<code>A[3]</code>是否等于<code>A[next[3]]</code>，结果<code>a==a</code>，则<code>nextval[3]=0</code><br>其它以此类推。</p>
</blockquote>
<p>　　最终串“ababaabab”的<code>nextval</code>数组为：</p>
<blockquote>
<p>0  1  0  1  0  4  1  0  1</p>
</blockquote>
<p>　　<strong>匹配的过程</strong><br>　　得到了模式串的<code>next</code>数组后，就可以开始进行匹配了。</p>
<blockquote>
<p>假设主串是“<code>aab1234</code>”，模式串为“<code>aac</code>”，通过计算模式串的<code>next</code>数组为<code>012</code>。<br>1、依次比较主串和子串的每一字符，当比较到第三字符<code>c</code>的时候，失配了。<br>2、此时会将模式串的指针调整到next[3]的值所指向的位置（也就是2），对应的字符是<code>a</code>。<br>3、接着用<code>a</code>继续和主串中的<code>b</code>比较，显然不相等。<br>4、接着会将模式串的指针调整到next[2]的值所指向的位置（也就是1），对应的字符是<code>a</code>。<br>5、接着用<code>a</code>继续和主串中的<code>b</code>比较，显然不相等。<br>6、接着会将模式串的指针调整到next[1]的值所指向的位置（也就是0），此时已经到头了，说明主串的前三个字符无法匹配子串了，于是将主串的位置后移一位。</p>
</blockquote>
<p>　　将上面的匹配过程带入到<code>nextval</code>数组的话，匹配的次数会比<code>next</code>要少，因而我们实际开发中使用最多的就是<code>nextval</code>数组。</p>
<p>　　实际开发中，使用<code>C++</code>和<code>Java</code>等语言的人占大多数，它们的下标都是从<code>0</code>开始的，而上面计算<code>next</code>数组时下标都是从<code>1</code>开始的。其实我们规定第一个字符的<code>next</code>值为<code>0</code>，不是完全不能改变的，只要不影响计算结果，第一位的<code>next</code>值也可以不是<code>0</code>。</p>
<blockquote>
<p>也就是说，我们可以将下标和next值都-1，即元素的下标的取值从0开始，第一位字符的next数组的值相应的改为-1即next[0]=-1;</p>
</blockquote>
<p><br>　　范例3：Java版KMP模式匹配。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getNextVal(String str)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=-<span class="number">1</span>,strLen=str.length();</span><br><span class="line">        <span class="keyword">int</span>[] nextval=<span class="keyword">new</span> <span class="keyword">int</span>[strLen];</span><br><span class="line">        <span class="keyword">char</span>[] strArr=str.toCharArray();</span><br><span class="line">        nextval[i]=j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;strLen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==-<span class="number">1</span> || strArr[i]==strArr[nextval[j]])&#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;strLen)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(strArr[i]!=strArr[j])</span><br><span class="line">                        nextval[i]=j;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        nextval[i]=nextval[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j=nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String sup,String sub)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,supLen=sup.length();</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,subLen=sub.length();</span><br><span class="line">        <span class="keyword">int</span>[] nextval=getNextVal(sub);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;supLen &amp;&amp; j&lt;subLen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==-<span class="number">1</span> || sup.charAt(i)==sub.charAt(j))&#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j=nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==subLen)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   i代表当前字符的前一个字符的位置，j最初代表第i个字符的的nextval值。
-   因为有i++操作，因此又判断了一次i，以防止数组越界。
</code></pre><h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><p>　　树形结构指的是数据元素之间存在着“<font color="red">一对多</font>”的树形关系的数据结构，是一类重要的非线性数据结构。树是由n个结点构成的有限集(n&gt;=0)。</p>
<center><br><img src="/img/base/base001_07.jpg" alt=""><br></center>

<blockquote>
<p>上图就是一个树形结构，A被称为根节点，其它所有节点被称为非根节点。<br>非根节点有一个父根节点和0个或多个子节点。<br>B、C、D都有各自的子节点，它们与各自的子节点构成了A节点的子树。</p>
</blockquote>
<p>　　<strong>二叉树</strong><br>　　二叉树是是一种特殊的树，根节点下只有两个子树，左右子树互不相交。</p>
<blockquote>
<p>树高为k的二叉树，最多有2k-1个结点(k&gt;=1)。<br>二叉树主要采用链式存储.</p>
</blockquote>
<p>　　二叉树最常见的操作就是遍历，遍历分为先序遍历、中序遍历、后序遍历、层次遍历。</p>
<p><br>　　范例1：遍历。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(BinaryTree *root)</span></span>&#123; <span class="comment">//本函数用来先序遍历二叉树。</span></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;  <span class="comment">//如果当前结点不为空 则开始遍历。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);  <span class="comment">//先输出当前结点的数据域。</span></span><br><span class="line">        first(root-&gt;left);   <span class="comment">//遍历其左孩子结点。</span></span><br><span class="line">        first(root-&gt;right);  <span class="comment">//遍历其右孩子结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle</span><span class="params">(BinaryTree *root)</span></span>&#123; <span class="comment">//本函数用来中序遍历二叉树。</span></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;     <span class="comment">//如果当前结点不为空 则开始遍历。</span></span><br><span class="line">        middle(root-&gt;left);  <span class="comment">//先遍历其左孩子结点。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);  <span class="comment">//再输出当前结点的数据域。</span></span><br><span class="line">        middle(root-&gt;right);  <span class="comment">//最后遍历其右孩子结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last</span><span class="params">(BinaryTree *root)</span></span>&#123;  <span class="comment">//本函数用来后序遍历二叉树。</span></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;  <span class="comment">//如果当前结点不为空 则开始遍历。</span></span><br><span class="line">        last(root-&gt;left);  <span class="comment">//先遍历其左孩子结点。</span></span><br><span class="line">        last(root-&gt;right);  <span class="comment">//再遍历其右孩子结点。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);  <span class="comment">//最后输出当前结点的数据域。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   先遍历根结点称为先序遍历，其他的类推。
</code></pre><p><br>　　范例2：Java版层次遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floor</span><span class="params">(Tree root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// list就代表一个数组，用来存储结点。</span></span><br><span class="line">        ArrayList&lt;Tree&gt; list = <span class="keyword">new</span> ArrayList&lt;Tree&gt;(); </span><br><span class="line">        <span class="comment">// 先将根节点存储到数组中的最后一个位置。</span></span><br><span class="line">        <span class="comment">// 由于此时数组中一个元素都没有，所以root也是第一个元素。</span></span><br><span class="line">        list.add(root);  </span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            Tree current = list.remove(<span class="number">0</span>); <span class="comment">//则取出数组中当前第一个元素。</span></span><br><span class="line">            System.out.println(current.getData());<span class="comment">//输出这个元素中的数据。</span></span><br><span class="line">            list.add(current.getLchild());<span class="comment">//将这个元素的左孩子放入数组最后。</span></span><br><span class="line">            list.add(current.getRchild());<span class="comment">//将这个元素的右孩子放入数组最后。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   思想“从上到下，从左到右”，利用list的特点实现的。
</code></pre><h1 id="图状结构"><a href="#图状结构" class="headerlink" title="图状结构"></a>图状结构</h1><p>　　图状结构(Graph)，是由“<font color="red">顶点</font>”和“<font color="red">边</font>”所组成的集合，通常⽤G=(V,E)来表⽰，其中V是顶点的集合，E是边的结合，其中顶点之间是多对多关系。</p>
<center><br><img src="/img/base/base001_08.png" alt=""><br></center>

<p>　　图按照边的方向分为：</p>
<blockquote>
<p>无向图：顶点之间没有前后顺序，从A可以到B，从B也可以到A。<br>有向图：顶点之间有前后顺序，在上方右侧的图中，只能从A到B，不能从B到A。</p>
</blockquote>
<p>　　图的存储结构分为：顺序式和链式，分别使用邻接矩阵和邻接表来表示。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>　　根据排序过程使用的存储器不同分为：</p>
<blockquote>
<p>内排序：在内存中进行排序。<br>外排序：由于待排序数过多内存容不下，因此排序过程中，需要不断地与外存进行数据交换。</p>
</blockquote>
<p>　　衡量排序算法时，从以下三方面观察：</p>
<blockquote>
<p>运行时间、关键字比较次数、记录的移动次数。</p>
</blockquote>
<p>　　排序具体的类型有：</p>
<blockquote>
<p>插入排序、交换排序、选择排序和一些其它排序。</p>
</blockquote>
<center><br><img src="/img/base/base001_09.png" alt=""><br></center>

<pre><code>-   最好的情况是： 数据已有序。
-   最坏的情况是： 数据反序存放。
-   平均情况： 随机存放。
</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><br>　　范例1：直接插入排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;    <span class="comment">//从第2个元素开始排序，一直到最后一个元素结束。</span></span><br><span class="line">        temp = array[i];  <span class="comment">//将当前元素的值，先存储起来，以方便一会使用。</span></span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;  <span class="comment">//使用当前元素依次和已排序的元素比较。</span></span><br><span class="line">            <span class="keyword">if</span>(temp&lt;array[j])&#123;  <span class="comment">//如果当前元素比其前面的那个元素小。</span></span><br><span class="line">                array[j+<span class="number">1</span>] = array[j]; <span class="comment">//则将该元素后移一个位置。</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果当前元素大于或等于其前面的元素。</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//则不再继续比较。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j+<span class="number">1</span>] = temp;  <span class="comment">//将当前元素放到指定位置。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   直插排序是将第一个数当作成已排好的数，然后不断的拿待排序元素，跟已排好的元素比较：
-   若待插入元素小，则将当前元素后移一位，然后待插入元素继续和再前一位上的元素比较。
-   若待插入元素大于或等于当前元素，则将待插入元素放到当前位置+1处，接着继续排序下一个数。
-   一般来说，如果数据量少时，可以使用此方法排序，如果数据过多，元素后移的次数也就增加了。
</code></pre><p><br>　　范例2：折半插入排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本函数用来返回元素应该插入的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> high,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,temp;  <span class="comment">//从0开始比较，temp用来存放临时位置。</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;  <span class="comment">//如果位置还没有计算出来，则继续计算。</span></span><br><span class="line">        temp = (low+high)/<span class="number">2</span>;  <span class="comment">//计算位置。</span></span><br><span class="line">        <span class="keyword">if</span>(array[temp] &lt;= num)&#123;  <span class="comment">//如果待插入元素大于temp位置上的元素。</span></span><br><span class="line">            low = temp + <span class="number">1</span>;  <span class="comment">//则更新low指针。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = temp - <span class="number">1</span>;  <span class="comment">//否则更新high指针。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> high+<span class="number">1</span>;  <span class="comment">//返回元素应该插入的位置。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本函数用来实现折半插入排序。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i,j,temp,index;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;   <span class="comment">//依旧是将第一个元素看作为是已经排好序。</span></span><br><span class="line">        temp = array[i];  <span class="comment">//将当前元素保存起来。</span></span><br><span class="line">        <span class="comment">//计算出当前元素应该插入的位置。</span></span><br><span class="line">        index = indexOf(array,i-<span class="number">1</span>,array[i]);</span><br><span class="line">        <span class="comment">//从最后一个元素开始，一直到index之间的元素 后退1位。</span></span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=index;j--)&#123;</span><br><span class="line">            array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j+<span class="number">1</span>] = temp;  <span class="comment">//将当前元素，插入到数组中。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   所谓折半插入排序，即在折半插入排序中，不再使用顺序比较来获得插入位置，而是使用折半查找的方法获取插入位置。
</code></pre><p><br>　　<strong>希尔排序</strong></p>
<p>　　希尔排序算法由两部分组成：分组和排序。</p>
<p>　　分组：将一个数组进行多次分组，其中第一次分组时，分出的组数最多、每一小组中元素个数最少，最后一次分组时 分出的组数最少、组中元素个数最多。</p>
<blockquote>
<p>比如待排序数组中有10个元素：<br>第一次分组 咱们把它分成5组 每组2个元素。<br>第二次分组 咱们把它分成2组 每组5个元素。<br>第三次分组 咱们把它分成1组 每组10个元素。</p>
</blockquote>
<p>　　问：分组之后干什么呢？</p>
<blockquote>
<p>分组之后咱们就开始对每一组中的数据进行排序，当所有组都排序完后，再进行下一次分组。</p>
</blockquote>
<p>　　问：那按什么规则分组呢？</p>
<blockquote>
<p>比如说数组中十个元素为10 、9、8、7、6、5、4、3、2、1，第一次分组分了5组，每组的内容如下：<br>第一组：10 和 5<br>第二组：9  和 4<br>第三组：8  和 3<br>第四组：7  和 2<br>第五组：6  和 1</p>
</blockquote>
<p>　　问：排序的规则是什么？</p>
<blockquote>
<p>排完第一组的前2个元素后，就去排第2组的前两个元素，然后如果还有第3组，则就去排第3组的前两个元素，等所有组中的前两个元素都排完后，接着从第一组开始，再对每组第2和第3个元素进行比较排序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//本函数用来实现希尔插入排序。</span></span><br><span class="line">    <span class="keyword">int</span> group,i,j,temp; <span class="comment">//group用来保存分出的组的数量。</span></span><br><span class="line">    <span class="keyword">for</span>(group=n/<span class="number">2</span>;group&gt;<span class="number">0</span>;group/=<span class="number">2</span>)&#123; <span class="comment">//最初，将元素分成：每两个一组。</span></span><br><span class="line">        <span class="keyword">for</span>(i=group;i&lt;n;i++)&#123; <span class="comment">//i从每组的第二个元素开始，一直指向到数组尾。</span></span><br><span class="line">            <span class="keyword">for</span>(j=i-group;j&gt;=<span class="number">0</span>;j-=group)&#123; <span class="comment">//j从每组第一个元素开始。</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+group])&#123; <span class="comment">//如果前面的元素大于后面的元素。</span></span><br><span class="line">                    temp = array[j]; <span class="comment">//开始交换位置。</span></span><br><span class="line">                    array[j] = array[j+group];</span><br><span class="line">                    array[j+group] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p><br>　　范例1：冒泡排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">//本函数用来进行冒泡排序。</span></span><br><span class="line">    <span class="keyword">int</span> i , j , temp;  </span><br><span class="line">    <span class="comment">// 将数组中最大的元素，不断的放到无序元素中的最后一个位置。</span></span><br><span class="line">    <span class="keyword">for</span>(i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123; </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)&#123; <span class="comment">//从第一个元素开始，一次与其后的元素比较。</span></span><br><span class="line">            <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123; <span class="comment">//如果当前元素大于其后的元素。</span></span><br><span class="line">                temp = array[j]; <span class="comment">//则交换元素位置。</span></span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   外层循环控制内层循环的终点。
-   内层循环从0开始，依次和相邻元素比较，到i-1结束。
-   总的来说，冒泡排序是依次将最大的元素，放到数组的最后一个位置。
</code></pre><p><br>　　范例2：快速排序。<br>　　毫无疑问，快速排序是最流行的排序算法，因为有充足的理由证明，在大多数情况下，快速排序都是最快的(这只对内部排序或随机存储器内而言，而对于外排序来说，其他排序算法可能会更好一些)。快速排序“枢轴”的选择，决定了算法的执行效率，应该避免选择数组中的最大或最小值做枢轴，最好是选择中值，左右两边的长度恰好相等，快速排序是一种不稳定的排序算法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123; <span class="comment">//本函数用来进行快速排序。</span></span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123; <span class="comment">//如果给出的坐标合法，才可以进行排序。</span></span><br><span class="line">        <span class="keyword">int</span> pivot=array[low],i=low,j=high; <span class="comment">//将第一个元素作为枢轴。</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123; <span class="comment">//如果下标合法。</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; array[j]&gt;=pivot) j--;<span class="comment">//从右端开始不断和pivot比较。</span></span><br><span class="line">            array[i]=array[j]; <span class="comment">//将j指向的元素，放到最左边。</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; array[i]&lt;=pivot) i++; <span class="comment">//再从左端开始，不断的比。</span></span><br><span class="line">            array[j]=array[i]; <span class="comment">//将j指向的元素，放到最右边。</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[i]=pivot;  <span class="comment">//此时i和j相等，将枢轴放到i的位置中去。</span></span><br><span class="line">        sort(array,low,i-<span class="number">1</span>); <span class="comment">//对枢轴左边的元素进行快速排序。</span></span><br><span class="line">        sort(array,i+<span class="number">1</span>,high); <span class="comment">//对枢轴右边的元素进行快速排序。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><br>　　范例1：直接选择排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//本函数用来进行直接选择排序。</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;<span class="comment">//总体思想：不断的将当前数组中最小的元素，放到开头。</span></span><br><span class="line">        k=i; <span class="comment">//记录当前元素所在的下标。</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123; <span class="comment">//让当前元素，依次和其后的所有元素比较。</span></span><br><span class="line">            <span class="keyword">if</span>(array[k]&gt;array[j])&#123; <span class="comment">//如果当前元素大。</span></span><br><span class="line">                k = j; <span class="comment">//将另一个参与比较的元素的下标，保存起来。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k != i)&#123; <span class="comment">//如果在排序过程中k的值改变了。</span></span><br><span class="line">            <span class="keyword">int</span> temp=array[k]; <span class="comment">//则说明，i所指向的元素并不是最小的。</span></span><br><span class="line">            array[k]=array[i]; <span class="comment">//所以，交换i和k指向的元素的位置。</span></span><br><span class="line">            array[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   总的来说，直接选择排序是不断将数组中最小的元素，放到数组的开头，它与冒泡排序恰巧相对应。
</code></pre><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>　　查找分为：静态查找和动态查找。</p>
<blockquote>
<p>静态查找：只是纯粹的查找，不修改数据。<br>动态查找：查找时会修改数据。</p>
</blockquote>
<p>　　查找表： </p>
<blockquote>
<p>有n条记录的集合T是实施查找的数据基础，T称为“查找表”(Search Table)。</p>
</blockquote>
<p><br>　　范例1：顺序查找。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> keyword,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//本函数用来进行顺序查找。</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;  <span class="comment">//从数组的第一个元素开始匹配，一直到最后一个元素结束。</span></span><br><span class="line">        <span class="keyword">if</span>(array[i] == keyword)&#123; <span class="comment">//如果匹配成功，则返回这个元素的位置。</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//如果直到最后，都未匹配成功，则返回-1。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：二分查找。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> keyword,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high=n-<span class="number">1</span>,temp;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high) &#123;</span><br><span class="line">        temp=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[temp] == keyword)</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[temp]&gt;keyword) &#123;</span><br><span class="line">            high = temp-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            low=temp+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-   二分查找又被称为折半查找，要求数组中的元素必须是有序存放的，否则无法查找成功。
-   折半查找是建立在顺序存储结构之上的，插入和删除不方便。
</code></pre><p>　　<strong> 二叉查找树 </strong><br>　　二叉查找树(Binary Search Tree) 又称二叉排序树、二叉搜索树、有序二叉树，它就是一棵普通的二叉树。二叉查找树的特点：</p>
<blockquote>
<p>若当前结点的左子树非空，则它左子树上的所有结点的值都小于它。<br>若当前结点的右子树非空，则它右子树上的所有结点的值都大于它。<br>它的左右子树本身也是一棵二叉查找树。<br>对二叉查找树进行中序遍历可得到从小到大的排列。<br>二叉查找树的查找次数不会超过树的深度，其进行查找时的效率与树的形状有关(单支时最坏)。<br>BST中不能有重复元素。</p>
</blockquote>
<p><br>　　范例1：C语言版二叉查找树。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;   // 导入头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  // 导入头文件。</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>  <span class="comment">// 定义一个结点结构体。</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">// 结点的数据域。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span>  <span class="comment">// 结点的左子树。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span> <span class="comment">// 结点的右子树。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Tree</span>;</span>  <span class="comment">// 给这个结点结构体起一个别名Tree。</span></span><br><span class="line"></span><br><span class="line"><span class="function">Tree* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;  <span class="comment">// 本函数用来建立一个结点。</span></span><br><span class="line">    Tree* node = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree *)); <span class="comment">// 从内存中开辟空间。</span></span><br><span class="line">    node-&gt;data = data;  <span class="comment">// 初始化数据域。</span></span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;  <span class="comment">// 将新结点的左子树设为NULL。</span></span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>; <span class="comment">// 将新结点的右子树设为NULL。</span></span><br><span class="line">    <span class="keyword">return</span> node; <span class="comment">// 返回新建立的结点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">insert</span><span class="params">(Tree *root,<span class="keyword">int</span> data)</span></span>&#123; <span class="comment">// 本函数用来向BST中插入一个元素。</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;  <span class="comment">// 如果当前结点为空，则建立这个结点。</span></span><br><span class="line">        <span class="keyword">return</span> create(data);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 如果当前结点不为空。</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data == data)&#123;  <span class="comment">// 判断要插入的结点的数据域，是否已经存在。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 如果存在，则不允许插入。</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;data)&#123;  <span class="comment">// 如果当前结点的data大于参数data的值。</span></span><br><span class="line">            <span class="comment">// 则将欲插入结点插入到本结点的左子树。</span></span><br><span class="line">            Tree *temp = insert(root-&gt;left,data); </span><br><span class="line">            <span class="keyword">if</span>(temp !=<span class="literal">NULL</span>)&#123;  <span class="comment">// 如果当前结点的左子树本来为空。</span></span><br><span class="line">                root-&gt;left = temp; <span class="comment">// 则将新结点，放到本结点的左子树中。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 接着，再返回NULL。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前结点的data小于参数data的值。</span></span><br><span class="line">            <span class="comment">// 将欲插入结点插入到本结点的右子树。</span></span><br><span class="line">            Tree *temp = insert(root-&gt;right,data);</span><br><span class="line">            <span class="keyword">if</span>(temp !=<span class="literal">NULL</span>)&#123; <span class="comment">// 如果当前结点的右子树本来为空。</span></span><br><span class="line">                root-&gt;right = temp; <span class="comment">// 则将新结点，放到本结点的右子树中。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 接着，再返回NULL。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Tree *root)</span></span>&#123;  <span class="comment">// 本函数用来中序遍历一个二叉树。</span></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;  <span class="comment">// 如果根节点不为NULL 则继续遍历。</span></span><br><span class="line">        print(root-&gt;left);  <span class="comment">// 先递归遍历其左子树。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data); <span class="comment">// 然后输出当前结点的data域。</span></span><br><span class="line">        print(root-&gt;right);  <span class="comment">// 最后再变量当前结点的右子树。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;  <span class="comment">// 本函数用来测试BST。</span></span><br><span class="line">    Tree *root = <span class="literal">NULL</span>;  <span class="comment">// 首先建立一个根节点指针。</span></span><br><span class="line">    root = insert(root,<span class="number">5</span>); <span class="comment">// 将根节点插入到BST中。</span></span><br><span class="line">    insert(root,<span class="number">3</span>);  <span class="comment">// 再插入3到BST中。</span></span><br><span class="line">    insert(root,<span class="number">4</span>); <span class="comment">// 再插入4到BST中。</span></span><br><span class="line">    print(root);  <span class="comment">// 中序遍历BST。</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);  <span class="comment">// 换行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">search</span><span class="params">(Tree *root,<span class="keyword">int</span> data)</span></span>&#123; <span class="comment">// 本函数用来从BST中查找一个元素。</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;  <span class="comment">// 如果一直到最后都没有找到，则返回NULL。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 若当前根结点不等于NULL。</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data == data)&#123; <span class="comment">// 则判断当前节点的data域是否和参数data相等。</span></span><br><span class="line">            <span class="keyword">return</span> root; <span class="comment">// 如果相等，则代表找到了这个结点。</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;data)&#123; <span class="comment">// 如果当前结点的data域大，则去其左子树找。</span></span><br><span class="line">            <span class="keyword">return</span> search(root-&gt;left,data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果当前结点的data域小，则去其右子树中找，并返回其查找结果。</span></span><br><span class="line">            <span class="keyword">return</span> search(root-&gt;right,data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　BST删除元素时有三种情况： </p>
<blockquote>
<p>待删结点无孩子结点，此时直接删掉这个结点即可。<br>待删节点只有左孩子或只有右孩子，此时将此结点的左孩子或者右孩子上移即可。<br>待删节点左右孩子都存在，此时可以这么处理：用左子树根结点或右子树根节点取代待删节点，若使用左子树替代，且左子树本身还也有右子树，则左子树的右子树，放到待删结点右子树的最左端。反过来如果用右子树顶替，且右子树本身也有左子树，则将右子树的左子树放到待删结点左子树的最右端。</p>
</blockquote>
<p>　　<strong> 散列查找 </strong></p>
<p>　　顺序、折半、索引表、二叉查找树的查找效率都与查找表的长度紧密相关，需要使用关键字不断的和查找表中的元素进行匹配。而查找的理想做法是不去或很少进行匹配，散列查找就是通过散列函数来计算元素的位置，从而尽可能的减少匹配次数。</p>
<p>　　在散列查找中使用的函数称为“散列函数”或哈希函数。<br>　　在散列查找中的查找表称为散列表或哈希表。<br>　　如果两个不同的关键字的散列函数值相同，则这种现象就称为“冲突”，这两个关键字被称为“同义词”，由“同义词”产生的冲突称为同义词冲突。</p>
<p>　　冲突处理，即使计算的再准确，散列函数值也难免会有冲突出现，常用的冲突处理的方法：</p>
<blockquote>
<p>开放定址法：采用开放定址法时,散列表被存储在一个一维数组中，把散列表里的可用位置向处理冲突开放。<br>　　线性探索：如果当前位置起了冲突,则走向下一个位置,如果走到最后,则从0开始重走,如果散列表已满,则停止。<br>　　二次探索：如果当前位置起了冲突,则依次使当前下标加上一个位移量,然后再重新尝试插入,位移量为：(12,-12, 22,-22,… ,k2,-k2) 其中k&lt;=m/2 m为散列表的长度。<br>　　随机探测：如果当前位置起了冲突，使当前下标+一个数随机出来的数。<br>链地址法 ：将同义词用单链表接在一起，组成同义词链表。如图：</p>
</blockquote>
<center><br><img src="/img/base/base001_10.png" alt=""><br></center>


<p><br><br></p>

      
    </div>

    <footer class="post-footer">
      

      
      
    </footer>
  </article>


  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="c-base-002/"
           data-title="第二章 数据结构" data-url="http://yoursite.com/c-base-002/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="键盘" />
          <p class="site-author-name" itemprop="name">键盘</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://weishu.me/" title="weishu" target="_blank">weishu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ryanhoo.github.io/" title="ryanhoo" target="_blank">ryanhoo</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础入门"><span class="nav-number">1.</span> <span class="nav-text">基础入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑结构"><span class="nav-number">1.1.</span> <span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储结构"><span class="nav-number">1.2.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法分析"><span class="nav-number">1.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线性结构"><span class="nav-number">2.</span> <span class="nav-text">线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线性表"><span class="nav-number">2.1.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序表"><span class="nav-number">2.1.1.</span> <span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">2.1.2.</span> <span class="nav-text">链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈"><span class="nav-number">2.2.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">2.2.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迷宫"><span class="nav-number">2.2.2.</span> <span class="nav-text">迷宫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式求值"><span class="nav-number">2.2.3.</span> <span class="nav-text">表达式求值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">2.3.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组、矩阵"><span class="nav-number">2.4.</span> <span class="nav-text">数组、矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对称矩阵压缩"><span class="nav-number">2.4.1.</span> <span class="nav-text">对称矩阵压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三角矩阵压缩"><span class="nav-number">2.4.2.</span> <span class="nav-text">三角矩阵压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#稀疏矩阵"><span class="nav-number">2.4.3.</span> <span class="nav-text">稀疏矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵乘积"><span class="nav-number">2.4.4.</span> <span class="nav-text">矩阵乘积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串"><span class="nav-number">2.5.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#朴素模式匹配"><span class="nav-number">2.5.1.</span> <span class="nav-text">朴素模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP模式匹配"><span class="nav-number">2.5.2.</span> <span class="nav-text">KMP模式匹配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树形结构"><span class="nav-number">3.</span> <span class="nav-text">树形结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图状结构"><span class="nav-number">4.</span> <span class="nav-text">图状结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序"><span class="nav-number">5.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">5.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交换排序"><span class="nav-number">5.2.</span> <span class="nav-text">交换排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">5.3.</span> <span class="nav-text">选择排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找"><span class="nav-number">6.</span> <span class="nav-text">查找</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">键盘</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
